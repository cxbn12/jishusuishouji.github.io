[{"title":"VAGRANT 和 Docker的使用场景和区别?","date":"2017-01-25T06:20:57.000Z","path":"2017/01/25/xunihua/VAGRANT_和_Docker的使用场景和区别_/","text":"本质区别Vagrant并不提供虚拟化技术，本质上是一个虚拟机外挂，通过虚拟机的管理接口来管理虚拟机，让用户更轻松的进行一些常用配置，比如：CPU/Memory/IP/DISK等分配。并且提供了一些其它的管理操作：比如开机运行指定命令，镜像二次打包，插件编写等等。vagrant官方有介绍: To achieve its magic, Vagrant stands on the shoulders of giants. Machines are provisioned on top of VirtualBox, VMware, AWS, or any other provider. Then, industry-standard provisioning tools such as shell scripts, Chef, or Puppet, can be used to automatically install and configure software on the machine. 而docker是一个容器引擎，每一个实例是一个相对隔离的空间，与宿主机共享操作系统内核，并且共享宿主机资源。相对于披着虚拟机皮的vagrant，docker更加轻量，消耗更少的资源。 应用场景关于应用场景没有绝对，把两个东西都用熟，自己觉得用哪个方便用哪个好管理就用哪个。既然vagrant本质是虚拟机外挂，那么它的应用场景就是，节省你用原生虚拟机管理软件的时间。原来我们新增一台虚拟机需要配置好内存、硬盘、CPU等，然后添加iso，安装。创建用户，等等。一套下来好几十分钟是吧？聪明点你可能会想到复制一个创建好的镜像然后粘贴。但这一切vagrant都帮你想好了,安装vagrant后你只需要6步就能创建一台新的虚拟机，其中两步是创建文件夹和切换文件夹。从安装到创建一台新的虚拟机就成功了。如果你想要再添加一台虚拟机，你只需要执行最后两步，添加一个不同名字的配置就能再新建一台虚拟机。还支持镜像、开机自动运行脚本、插件编写等。dockerdocker主要应用于解决环境依赖以及为应用程序提供一个相对隔离的空间，一个实例像操作系统里运行的一个程序。原来部署一套环境是不是得自己编写自动化部署依赖环境以及程序的脚本？如果有两个依赖同一程序或库的不同版本怎么办？绝对路径？软连接？docker能很好的解决你的烦恼。把需要的依赖环境打包成一个镜像，再把程序放镜像里面运行。 总的来说vagrant更适合给开发大爷们创造一个统一的开发、测试、接近于完全隔离的环境，以及提高对高配机的闲置利用。docker更方便地解决了同一机器上的环境隔离，以及提高运维锅们解决部署时环境依赖的效率。","tags":[{"name":"docker","slug":"docker","permalink":"http://jishusuishouji.github.io/tags/docker/"}]},{"title":"使用 Velocity 模板引擎快速生成代码","date":"2017-01-21T23:35:11.000Z","path":"2017/01/22/java/velocity/使用_Velocity_模板引擎快速生成代码/","text":"Velocity 模板引擎介绍在现今的软件开发过程中，软件开发人员将更多的精力投入在了重复的相似劳动中。特别是在如今特别流行的MVC架构模式中，软件各个层次的功能更加独立，同时代码的相似度也更加高。所以我们需要寻找一种来减少软件开发人员重复劳动的方法，让程序员将更多的精力放在业务逻辑以及其他更加具有创造力的工作上。Velocity这个模板引擎就可以在一定程度上解决这个问题。Velocity是一个基于Java的模板引擎框架，提供的模板语言可以使用在Java中定义的对象和变量上。Velocity是Apache基金会的项目，开发的目标是分离MVC模式中的持久化层和业务层。但是在实际应用过程中，Velocity不仅仅被用在了MVC的架构中，还可以被用在以下一些场景中。 1.Web应用：开发者在不使用JSP的情况下，可以用Velocity让HTML具有动态内容的特性。2.源代码生成：Velocity可以被用来生成Java代码、SQL或者PostScript。有很多开源和商业开发的软件是使用Velocity来开发的。3.自动Email：很多软件的用户注册、密码提醒或者报表都是使用Velocity来自动生成的。使用Velocity可以在文本文件里面生成邮件内容，而不是在Java代码中拼接字符串。4.转换xml：Velocity提供一个叫 Anakia 的ant任务，可以读取XML文件并让它能够被 Velocity模板读取。一个比较普遍的应用是将xdoc文档转换成带样式的HTML文件。 Hello Velocity和学习所有新的语言或者框架的顺序一样，我们从Hello Velocity开始学习。首先在Velocity的官网上下载最新的发布包，之后使用Eclipse建立普通的Java项目。引入解压包中的 velocity-1.7.jar和lib文件夹下面的jar包。这样我们就可以在项目中使用Velocity了。在做完上面的准备工作之后，就可以新建一个叫HelloVelocity的类，代码如下： 清单 1. HelloVelocity.java1234567891011121314151617181920212223242526public class HelloVelocity &#123; public static void main(String[] args) &#123; VelocityEngine ve = new VelocityEngine(); ve.setProperty(RuntimeConstants.RESOURCE_LOADER, &quot;classpath&quot;); ve.setProperty(&quot;classpath.resource.loader.class&quot;, ClasspathResourceLoader.class.getName()); ve.init(); Template t = ve.getTemplate(&quot;hellovelocity.vm&quot;); VelocityContext ctx = new VelocityContext(); ctx.put(&quot;name&quot;, &quot;velocity&quot;); ctx.put(&quot;date&quot;, (new Date()).toString()); List temp = new ArrayList(); temp.add(&quot;1&quot;); temp.add(&quot;2&quot;); ctx.put(&quot;list&quot;, temp); StringWriter sw = new StringWriter(); t.merge(ctx, sw); System.out.println(sw.toString()); &#125;&#125; 在HelloVelocity的代码中，首先new了一个VelocityEngine类，这个类设置了Velocity使用的一些配置，在初始化引擎之后就可以读取hellovelocity.vm这个模板生成的Template这个类。之后的VelocityContext类是配置Velocity模板读取的内容。这个context可以存入任意类型的对象或者变量，让template来读取。这个操作就像是在使用JSP开发时，往request里面放入key-value，让JSP 读取一样。接下来就是写hellovelocity.vm文件了，这个文件实际定义了Velocity的输出内容和格式。hellovelocity.vm的内容如下： 清单 2. Hellovelocity.vm1234567#set( $iAmVariable = &quot;good!&quot; )Welcome $name to velocity.comtoday is $date.#foreach ($i in $list)$i#end$iAmVariable 输出结果如下：Welcome velocity to velocity.comtoday is Sun Mar 23 19:19:04 CST 2014.12good!在输出结果中我们可以看到，$name、$date 都被替换成了在 HelloVelocity.java 里面定义的变量，在 foreach 语句里面遍历了 list 的每一个元素，并打印出来。而$iAmVariable 则是在页面中使用 #set 定义的变量。回页首基本模板语言语法使用在 hellovelocity.vm 里面可以看到很多以 # 和$符开头的内容，这些都是 Velocity 的语法。在 Velocity 中所有的关键字都是以 # 开头的，而所有的变量则是以$开头。Velocity 的语法类似于 JSP 中的 JSTL，甚至可以定义类似于函数的宏，下面来看看具体的语法规则。一、变量和我们所熟知的其他编程语言一样，Velocity 也可以在模板文件中有变量的概念。 变量定义#set($name =“velocity”)等号后面的字符串 Velocity 引擎将重新解析，例如出现以$开始的字符串时，将做变量的替换。#set($hello =“hello $name”)上面的这个等式将会给$hello 赋值为“hello velocity” 变量的使用在模板文件中使用$name 或者${name} 来使用定义的变量。推荐使用${name} 这种格式，因为在模板中同时可能定义了类似$name 和$names 的两个变量，如果不选用大括号的话，引擎就没有办法正确识别$names 这个变量。对于一个复杂对象类型的变量，例如$person，可以使用${person.name} 来访问 person 的 name 属性。值得注意的是，这里的${person.name} 并不是直接访问 person 的 name 属性，而是访问 person 的 getName() 方法，所以${person.name} 和${person.getName()} 是一样的。 变量赋值在第一小点中，定义了一个变量，同时给这个变量赋了值。对于 Velocity 来说，变量是弱数据类型的，可以在赋了一个 String 给变量之后再赋一个数字或者数组给它。可以将以下六种数据类型赋给一个 Velocity 变量：变量引用, 字面字符串, 属性引用, 方法引用, 字面数字, 数组列表。#set($foo = $bar)#set($foo =“hello”)#set($foo.name = $bar.name)#set($foo.name = $bar.getName($arg))#set($foo = 123)#set($foo = [“foo”,$bar])二、循环在 Velocity 中循环语句的语法结构如下：#foreach($element in $list)This is $element$velocityCount#endVelocity 引擎会将 list 中的值循环赋给 element 变量，同时会创建一个$velocityCount 的变量作为计数，从 1 开始，每次循环都会加 1.三、条件语句条件语句的语法如下#if(condition)…#elseif(condition)…#else…#end四、关系操作符Velocity 引擎提供了 AND、OR 和 NOT 操作符，分别对应&amp;&amp;、||和! 例如：#if($foo &amp;&amp; $bar)#end五、宏Velocity 中的宏可以理解为函数定义。定义的语法如下：#macro(macroName arg1 arg2 …)…#end调用这个宏的语法是：#macroName(arg1 arg2 …)这里的参数之间使用空格隔开，下面是定义和使用 Velocity 宏的例子：#macro(sayHello $name)hello $name#end#sayHello(“velocity”)输出的结果为 hello velocity六、#parse 和 #include#parse 和 #include 指令的功能都是在外部引用文件，而两者的区别是，#parse 会将引用的内容当成类似于源码文件，会将内容在引入的地方进行解析，#include 是将引入文件当成资源文件，会将引入内容原封不动地以文本输出。分别看以下例子：foo.vm 文件：#set($name =“velocity”)parse.vm：#parse(“foo.vm”)输出结果为：velocityinclude.vm：#include(“foo.vm”)输出结果为：#set($name =“velocity”)以上内容包含了部分 Velocity 的语法，详细的语法内容可以参考 Velocity 的官方文档。回页首自动生成代码的例子在上个例子中我们可以生成任意的字符串并且打印出来，那为什么我们不能生成一些按照既定格式定义的代码并且写入文件呢。在这里我们以一个实际的 demo 来完成这部分内容。相关内容的源码可以参照附件。这个 demo 的功能是要实现一个学生和老师的管理，实际上都是单张表的维护。我们希望能够只定义 model 层，来生成 MVC 的所有代码。在这个 demo 中，只自动生成 action 和 JSP 的内容，因为现在有很多工具都可以帮助我们自动生成这两个包的代码。首先在 eclipse 中建立一个 Java web 工程，在例子中为了方便管理 jar 包，使用的是 maven 来建立和管理工程。建立好的工程目录结构如下图所示：图 1. 项目目录结构项目目录结构Java Resource 中放的是 Java 源码以及资源文件，Deployed Resources 中放的是 web 相关的文件。在 Java 文件中使用了类似 Spring 的 @Component 和 @Autowired 的注解来实现 IoC，使用 @Action 这样的注解实现 MVC，而在 JSP 中则使用了 JSTL 来输出页面。在上图所示的目录中，annotation、filter、framework 和 util 这四个 package 是作为这个项目框架的，跟业务没有关系，类似于 spring 和 struts 的功能。在实际的项目中我们当然希望能够一开始就编写一个通用的模板文件，然后一下子生成所有的代码，但是很多时候这样做是不可能的，或者说比较困难。为了解决这个问题，我们可以在编写 Velocity 模板文件之前先按照原本的流程编写代码，暂时先忘掉 Velocity。编写的代码应该能够在一个功能上完整的调通涉及 MVC 中所有层次的内容。在这个例子中，先编写好 StudentAction.java 文件，以及上图中 webapp 目录中所示的文件。在写好以上代码，同时也能顺利运行之后，我们可以参照之前编写的代码来写模板文件。这里我们来分别看一个 Java 文件和 JSP 的例子。清单 3. ActionTemplate.vm#parse (“macro.vm”) @Action(“${classNameLowCase}Action”)public class ${classNameUpCase}Action extends BaseAction{ @Autowired public ${classNameUpCase}Dao ${classNameLowCase}Dao; private List&lt;${classNameUpCase}&gt; ${classNameLowCase}s; private ${classNameUpCase} ${classNameLowCase}; #foreach ($attr in ${attrs}) private ${attr[0]} ${attr[1]}; #end public String ${classNameLowCase}List() { ${classNameLowCase}s = ${classNameLowCase}Dao.retrieveAll${classNameUpCase}s(); return “${classNameLowCase}List.jsp”; } …}上面的代码展示了一个 Java 类转换成 vm 模板之后的部分内容，完整内容请参考附件。macro.vm 文件中定义了一些使用的宏。JSP 的改造相对于 Java 文件来说稍微有点复杂，因为 JSP 中使用 JSTL 取 request 中的值也是使用${name} 这样的语法，所以想要输出${name} 这样的字符串而不是被模板引擎所替换，则需要使用转义字符，就像这样：\\${name}。为了能够让这个文件中的 table 得到复用，我们将这个文件中的表格单独拿出来，使用 #parse 命令来包含。下面是 ListJspTemplate.vm 和 ListTableTemplate.vm 的内容：清单 4. ListJspTemplate.vm&lt;%@ page language=”java” contentType=”text/html; charset=UTF-8” pageEncoding=”UTF-8”%&gt;&lt;%@taglib prefix=”c” uri=”http://java.sun.com/jsp/jstl/core“ %&gt;&lt;!DOCTYPE html PUBLIC “-//W3C//DTD HTML 4.01 Transitional//EN” “http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;%@ include file=”includeJS.jsp” %&gt; var pageConfig = { “list” : { “action” : “${classNameLowCase}Action!${classNameLowCase}List.action” } … “idName” : “${classNameLowCase}Id” }; ${classNameUpCase} List ${classNameUpCase} List Add #parse (“ListTableTemplate.vm”) 清单 5. ListTableTemplate.vm #parse (“macro.vm”) #set($plus = “status.index+1”) No.#generateTH($attrs) ${${plus}}#generateTD($classNameLowCase $attrs) Modify Delete 在定义好所有的模板文件之后，需要做的是读取这些文件，然后根据这些文件将 model 的数据类型以及名称设置到 context 中，最后将解析出来的内容写到相应的目录中去。这些工作我们放在了一个叫做 VelocityGenerator 的类中来做，它的源码如下：清单 6. TemplateGenerator.javapublic class VelocityGenerator { public static void main(String[] args) { VelocityEngine ve = new VelocityEngine(); ve.setProperty(RuntimeConstants.RESOURCE_LOADER, “classpath”); ve.setProperty(“classpath.resource.loader.class”, ClasspathResourceLoader.class.getName()); ve.init(); Template actionTpt = ve.getTemplate(“ActionTemplate.vm”); Template listJspTpt = ve.getTemplate(“ListJspTemplate.vm”); Template addTpt = ve.getTemplate(“AddTemplate.vm”); Template modifyTpt = ve.getTemplate(“ModifyTemplate.vm”); VelocityContext ctx = new VelocityContext(); ctx.put(“classNameLowCase”, “teacher”); ctx.put(“classNameUpCase”, “Teacher”); String[][] attrs = { {“Integer”,”id”}, {“String”,”name”}, {“String”,”serializeNo”}, {“String”,”titile”}, {“String”,”subject”} }; ctx.put(“attrs”, attrs); String rootPath = VelocityGenerator.class.getClassLoader().getResource(“”).getFile() + “../../src/main”; merge(actionTpt,ctx,rootPath+”/java/com/liuxiang/velocity/action/TeacherAction.java”); merge(listJspTpt,ctx,rootPath+”/webapp/teacherList.jsp”); merge(addTpt,ctx,rootPath+”/webapp/teacherAdd.jsp”); merge(modifyTpt,ctx,rootPath+”/webapp/teacherModify.jsp”); System.out.println(“success…”); } private static void merge(Template template, VelocityContext ctx, String path) { PrintWriter writer = null; try { writer = new PrintWriter(path); template.merge(ctx, writer); writer.flush(); } catch (FileNotFoundException e) { e.printStackTrace(); } finally { writer.close(); } }}在运行以上代码之后，项目文件夹中将会出现与 Teacher 相关的代码文件。在实际项目中可能不会出现很多这种单张表维护的情况，而且业务逻辑和系统架构会更加复杂，编写模板文件就更加不容易。但是无论多复杂的系统，不同的业务逻辑之间一定或多或少会有相似的代码，特别是在 JSP 和 JS 显示端文件中，因为我们在一个系统中要求显示风格、操作方式一致的时候就免不了会有相似内容的代码出现。在总结这些相似性之后我们还是可以使用 Velocity 来帮助我们生成部分内容的代码，而且即使有一些非共性的内容，我们也可以在生成的代码中继续修改。使用 Velocity 的另外一个好处是生成出来的代码更好维护，风格更加统一。回页首结束语Velocity 可以被应用在各种各样的情景下，本文介绍的只是它的一种用途而已，它还可以被用来做 MVC 结构中的 view 层，或者动态内容静态化等。另外，Velocity 并不是唯一的模板框架，同样很优秀的 Freemarker 也获得了非常广泛的应用，有兴趣的读者可以去深入研究更多的功能和用途。","tags":[{"name":"Velocity","slug":"Velocity","permalink":"http://jishusuishouji.github.io/tags/Velocity/"}]},{"title":"Spring中提示元素 'ref' 中不允许出现属性 'local'","date":"2017-01-17T07:58:44.000Z","path":"2017/01/17/spring/Spring中提示元素__ref__中不允许出现属性__local_/","text":"这个问题在Spring4.X以前的版本不存在。通过查询Spring的官方文档Spring4.X的以上版本不支持该属性了。下面是官方说明： The local attribute on the ref element is no longer supported in the 4.0 beans xsd since it does not provide value over a regular bean reference anymore. Simply change your existing ref local references to ref bean when upgrading to the 4.0 schema. 官方建议使用bean在Spring4.0以上的版本。 案例重现抛错：1234567891011121314151617181920212223242526272829303132333435363738394041Exception in thread &quot;main&quot; org.springframework.beans.factory.xml.XmlBeanDefinitionStoreException: Line 37 in XML document from class path resource [application_dependencies.xml] is invalid; nested exception is org.xml.sax.SAXParseException; lineNumber: 37; columnNumber: 27; cvc-complex-type.3.2.2: 元素 &apos;ref&apos; 中不允许出现属性 &apos;local&apos;。 at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:399) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:336) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:304) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:181) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:217) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:188) at org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:252) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:127) at org.springframework.context.support.AbstractXmlApplicationContext.loadBeanDefinitions(AbstractXmlApplicationContext.java:93) at org.springframework.context.support.AbstractRefreshableApplicationContext.refreshBeanFactory(AbstractRefreshableApplicationContext.java:129) at org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:604) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:509) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:83) at com.mxsm.spring.SpringDependencies.main(SpringDependencies.java:64)Caused by: org.xml.sax.SAXParseException; lineNumber: 37; columnNumber: 27; cvc-complex-type.3.2.2: 元素 &apos;ref&apos; 中不允许出现属性 &apos;local&apos;。 at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:198) at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.error(ErrorHandlerWrapper.java:134) at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:437) at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:368) at com.sun.org.apache.xerces.internal.impl.XMLErrorReporter.reportError(XMLErrorReporter.java:325) at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator$XSIErrorReporter.reportError(XMLSchemaValidator.java:453) at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.reportSchemaError(XMLSchemaValidator.java:3232) at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.processAttributes(XMLSchemaValidator.java:2709) at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.handleStartElement(XMLSchemaValidator.java:2051) at com.sun.org.apache.xerces.internal.impl.xs.XMLSchemaValidator.emptyElement(XMLSchemaValidator.java:761) at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.scanStartElement(XMLNSDocumentScannerImpl.java:353) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl$FragmentContentDriver.next(XMLDocumentFragmentScannerImpl.java:2717) at com.sun.org.apache.xerces.internal.impl.XMLDocumentScannerImpl.next(XMLDocumentScannerImpl.java:607) at com.sun.org.apache.xerces.internal.impl.XMLNSDocumentScannerImpl.next(XMLNSDocumentScannerImpl.java:116) at com.sun.org.apache.xerces.internal.impl.XMLDocumentFragmentScannerImpl.scanDocument(XMLDocumentFragmentScannerImpl.java:489) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:835) at com.sun.org.apache.xerces.internal.parsers.XML11Configuration.parse(XML11Configuration.java:764) at com.sun.org.apache.xerces.internal.parsers.XMLParser.parse(XMLParser.java:123) at com.sun.org.apache.xerces.internal.parsers.DOMParser.parse(DOMParser.java:237) at com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderImpl.parse(DocumentBuilderImpl.java:300) at org.springframework.beans.factory.xml.DefaultDocumentLoader.loadDocument(DefaultDocumentLoader.java:76) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadDocument(XmlBeanDefinitionReader.java:429) at org.springframework.beans.factory.xml.XmlBeanDefinitionReader.doLoadBeanDefinitions(XmlBeanDefinitionReader.java:391) ... 14 more spring xml文件配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;animals&quot; class=&quot;com.mxsm.spring.bean.Animal&quot;&gt; &lt;constructor-arg&gt; &lt;ref bean=&quot;dog&quot;/&gt; &lt;/constructor-arg&gt; &lt;constructor-arg&gt; &lt;ref bean=&quot;cat&quot;/&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; &lt;!--使用type属性--&gt; &lt;bean id=&quot;dog&quot; class=&quot;com.mxsm.spring.bean.Dog&quot;&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;aa&quot;/&gt; &lt;constructor-arg type=&quot;int&quot; value=&quot;1&quot;/&gt; &lt;constructor-arg type=&quot;java.lang.String&quot; value=&quot;meat&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;dog_2&quot; class=&quot;com.mxsm.spring.bean.Dog&quot;&gt; &lt;constructor-arg index=&quot;0&quot; value=&quot;ssss&quot;/&gt; &lt;constructor-arg index=&quot;1&quot; value=&quot;3333&quot;/&gt; &lt;constructor-arg index=&quot;2&quot; value=&quot;8888&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;cat&quot; class=&quot;com.mxsm.spring.bean.Cat&quot;&gt; &lt;constructor-arg name=&quot;a&quot; value=&quot;ssss&quot;/&gt; &lt;constructor-arg name=&quot;b&quot; value=&quot;3333&quot;/&gt; &lt;/bean&gt; &lt;!-- setter 依赖注入bean --&gt; **&lt;bean id=&quot;man&quot; class=&quot;com.mxsm.spring.bean.Man&quot;&gt; &lt;property name=&quot;white&quot;&gt; &lt;ref local=&quot;whiteMan&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;yellow&quot;&gt; &lt;ref local =&quot;yellowMan&quot;/&gt; &lt;/property&gt; &lt;property name=&quot;id&quot; value=&quot;1&quot;/&gt; &lt;/bean&gt;** &lt;bean id=&quot;whiteMan&quot; class=&quot;com.mxsm.spring.bean.WhitePerson&quot;&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;1&quot;/&gt; &lt;constructor-arg name=&quot;color&quot; value=&quot;white&quot;/&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;USA&quot;/&gt; &lt;constructor-arg name=&quot;sex&quot; value=&quot;男&quot;/&gt; &lt;/bean&gt; &lt;bean id=&quot;yellowMan&quot; class=&quot;com.mxsm.spring.bean.YellowPerson&quot;&gt; &lt;constructor-arg name=&quot;age&quot; value=&quot;1&quot;/&gt; &lt;constructor-arg name=&quot;color&quot; value=&quot;yellow&quot;/&gt; &lt;constructor-arg name=&quot;name&quot; value=&quot;China&quot;/&gt; &lt;constructor-arg name=&quot;sex&quot; value=&quot;男&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt;","tags":[{"name":"spring","slug":"spring","permalink":"http://jishusuishouji.github.io/tags/spring/"}]},{"title":"nodejs的require模块及路径","date":"2017-01-13T17:30:53.000Z","path":"2017/01/14/nodejs/nodejs的require模块及路径/","text":"在nodejs中，模块分为核心模块和文件模块。 核心模块是被编译成二进制代码，引用的时候只需require即可，如require(&#39;net&#39;)。文件模块，则是指js文件、json文件或者是.node文件。在引用文件模块的时候要加上文件的路径：如果既不加/.../...、../又不加./的话，则该模块要么是核心模块，要么是从一个node_modules文件夹加载。 如果’/home/ry/projects/foo.js‘ 中的文件调用了`require(‘bar.js’)`` ，node将在下面的位置进行搜索： •/home/ry/projects/node_modules/bar.js•/home/ry/node_modules/bar.js•/home/node_modules/bar.js•/node_modules/bar.js 文件夹作为模块：首先在./some-library文件夹下建立package.json文件，它标识了一个主模块。一个package.json中的内容可能如下：1234&#123; &quot;name&quot; : &quot;some-library&quot;, &quot;main&quot; : &quot;./lib/some-library.js&quot; &#125; require(&#39;./some-library&#39;)(和some-library相同路径的js文件)时将试图加载./some-library/lib/some-library.js如果在这个目录下没有package.json文件，node将试图从这个目录下加载index.js或index.node文件。例如，如果上面没有package.json文件，那么require(&#39;./some-library&#39;)时，将试图加载下面的文件：•./some-library/index.js•./some-library/index.node 分类: javascript,nodejs标签: javascript, nodejs","tags":[{"name":"nodejs","slug":"nodejs","permalink":"http://jishusuishouji.github.io/tags/nodejs/"}]},{"title":"Spring MVC事务配置","date":"2017-01-09T14:36:01.000Z","path":"2017/01/09/java/spring/Spring_MVC事务配置/","text":"","tags":[]},{"title":"是该抛弃Spring HibernateTemplate的时候了","date":"2017-01-09T14:26:48.000Z","path":"2017/01/09/java/spring/是该抛弃Spring_HibernateTemplate的时候了/","text":"在spring2.0之前，我们在使用hibernate和spring的时候，都会被HibernateTemplate为我们提供benefits（资源和事务管理以及把那个“丑陋”的checked exception转换为runtime exception-DataAccessException ）而折服，在项目中不由自主、不假思索地使用它和那个经典的callback方法。而如今，hibernate3.0.1+ 、spring 2.0+版本以后，我们可以在数据访问层直接使用hinberate的session API(例如SessionFactory.getCurrentSession)，不并担心session和transaction management。至于error handling可以通过spring的@Repository annotation和post processor-PersistenceExceptionTranslationPostProcessor来解决。让我们来看一些代码片段：123456789&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate3. LocalSessionFactoryBean&quot;&gt; &lt;!-- the properties setting--&gt; &lt;/bean&gt; &lt;bean id=&quot;accountRepo&quot; class=&quot;com.mycompany.HibernateAccountRepository&quot;&gt; &lt;constructor-arg ref=&quot;sessionFactory&quot;&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.dao.annotation. PersistenceExceptionTranslationPostProcessor&quot;/&gt; 数据访问层代码片段：123456789101112131415@Repository public class HibernateAccountRepository implements AccountRepository &#123; private SessionFactory factory; public HibernateAccountRepository(SessionFactory factory) &#123; this.factory = factory; &#125; public Account loadAccount(String username) &#123; return (Account)factory.getCurrentSession() .createQuery(&quot;from Account acc where acc.name = :name&quot;) .setParameter(&quot;name&quot;, &quot;thethirdpart&quot;).uniqueResult(); &#125; &#125; 在xml配置文件里面通过配置的post processor会自动检测@Repository标注的bean并为该bean打开exception转换功能。 如果不支持annotations，可以通过AOP来实现，更方便123456&lt;bean id=&quot;persistenceExceptionInterceptor&quot; class=&quot;org.springframework.dao.support.PersistenceExceptionTranslationInterceptor&quot;/&gt; &lt;aop:config&gt; &lt;aop:advisor pointcut=&quot;execution(* *..*Repository+.*(..))&quot; advice-ref=&quot;persistenceExceptionInterceptor&quot; /&gt; &lt;/aop:config&gt; 总结，我们应该选择哪种方式呢？还是那句话，根据不同的情况来做最正确的选择。但我建议是丢弃template，而直接使用hibernate的API，毕竟灵活性更大，更何况遇到复杂的情况我们始终得面对hibernate的API。spring并不强制你做任何事情，记得它是一个非侵入性的framework。","tags":[{"name":"spring","slug":"spring","permalink":"http://jishusuishouji.github.io/tags/spring/"},{"name":"java","slug":"java","permalink":"http://jishusuishouji.github.io/tags/java/"}]},{"title":"So should you still use Spring's HibernateTemplate and/or JpaTemplate??","date":"2017-01-09T14:20:51.000Z","path":"2017/01/09/java/spring/So_should_you_still_use_Spring_s_HibernateTemplate_and_or_JpaTemplate__/","text":"I was reading an article by Vigil Bose on TSS the other day and saw the usage of the HibernateDaoSupport class. Since this is no longer a recommended way of using Hibernate from Spring, I thought I might as well just blog about it another time. 不建议使用HibernateDaoSupport。 With the advent(n. 到来；出现；) of Spring 2.0, it has become possible to start using the Hibernate Session API directly again. The question is whether or not it is wise to abandon the use of the HibernateTemplate when working with Hibernate, or any other template-based approaches Spring features. Using Spring XxxTemplatesIn Spring 1.0, we introduced a revolutionary way of working with data access APIs that threw checked exceptions. The template approach Spring features along with its transaction synchronization manager and the extensive(adj. 广泛的；大量的；广阔的) use of runtime exceptions makes any TCFTC (short for try/catch-finally-try/catch as we coined(杜撰) it back in 2005) often found in data access code entirely obsolete. Below you can see (a simplified version and not entirely precise version of) what Spring’s template approach does for you (with specific code snippets that you would otherwise have to write). Acquisition of connection: If transaction synchronization is active (which it is, if you’re using Spring’s transaction management infrastructure), most of the times any of the Spring templates are using the same connection across the entire thread (things are actually a bit more complicated than that, but that would lead us too much into the gory details). Participation in a transaction Again, when using transaction management features, Spring will automatically associated any new connection with the current transaction. This again, all depends on the current propagations settings and so on, but whichever way you look at it, your core code is not affected by it. Specification of the SQL: This is what you (obviously) have to do yourself. The SQL ideally uses bind parameters, to avoid any chances of SQL injection from happening. Parameters are passed to the JDBC template as arguments. Creation / execution of statement and iterating over result set: After you’ve specified the SQL, Spring is going to create the statement for you, set any parameters you may have specified, execute it and loop over the result set for you. Parse result from result set: You can opt for parsing the result set yourself if you like (or if you have complex parsing requirements), or you can have Spring result a list of primitives, or just one value from the result set. Handling and translation of exceptions: This is where Spring translates any exceptions that might have occurred to Spring’s own DataAccessException hierarchy, automatically insulating calling code from the data access technology in use. Releasing of connection: This is the last piece of the puzzle where Spring releases any resources used. Of course, if transaction synchronization is active, the resources might not be released immediately. Templates are available for several APIs such as: JDBC (JdbcTemplate) Hibernate (HibernateTemplate) iBatis (SqlMapClientTemplate) JDO (JdoTemplate) TopLink (TopLinkTemplate) Messaging (JmsTempate) Transaction management (TransactionTemplate) JNDI (JndiTemplate) Are templates really necessary?The templates add a lot of value when using an API that uses checked exceptions (as opposed to runtime exceptions or unchecked exceptions), but also add a lot of consistency to your code base. People having learnt Spring’s JdbcTemplate can pretty easily start using Spring’s JdoTemplate or Spring’s HibernateTemplate–the approach to using those is similar for each one of them. The most visible impact of the Spring template approach is the code reduction for for example JDBC. This is primarily because the checked exceptions are translated to runtime exceptions inside the template, removing the need to catch the exception in your mainline code. Other reasons are the transparent resource management and automatic synchronization with the currently running transaction. Of course it’s fairly easy to change a framework to use runtime exceptions natively instead of Spring having to do this and this is what for example Hibernate has started to do from version 3.0 onwards. Hibernate is not the only technology to do this–the Java Persistence API is also using runtime exceptions.","tags":[{"name":"spring","slug":"spring","permalink":"http://jishusuishouji.github.io/tags/spring/"},{"name":"java","slug":"java","permalink":"http://jishusuishouji.github.io/tags/java/"},{"name":"hibernate","slug":"hibernate","permalink":"http://jishusuishouji.github.io/tags/hibernate/"},{"name":"HibernateTemplate","slug":"HibernateTemplate","permalink":"http://jishusuishouji.github.io/tags/HibernateTemplate/"}]},{"title":"java分布式事务(JTA)实现 jotm和atomikos","date":"2017-01-08T02:03:52.000Z","path":"2017/01/08/java/jta/java分布式事务_JTA_实现 jotm和atomikos/","text":"本地事务：只对单一数据源(单个数据库)事务进行控制。分布式事务：处理多种异构的数据源， 比如某个业务操作中同时包含JDBC和JMS或者某个操作需要访问多个不同的数据库，在不同数据库之间进行事务控制。 在Java中，分布式事务主要的规范是JTA/XA。其中：JTA是Java的事务管理器规范，XA是工业标准的X/Open CAE规范，可被两阶段提交及回滚的事务资源定义。比如某数据库实现了XA规范，则不管是JTA，还是MSDTC，都可以基于同样的行为对该数据库进行事务处理。 JTA全称为Java Transaction API，顾名思义JTA定义了一组统一的事务编程的接口，这些接口如下： XAResource：XAResource接口是对实现了X/Open CAE规范的资源管理器 (Resource Manager，数据库就是典型的资源管理器) 的抽象，它由资源适配器 (Resource Apdater) 提供实现。XAResource是支持事务控制的核心。Transaction：Transaction接口是一个事务实例的抽象，通过它可以控制事务内多个资源的提交或者回滚。二阶段提交过程也是由Transaction接口的实现者来完成的。TransactionManager：托管模式 (managed mode) 下，TransactionManager接口是被应用服务器调用，以控制事务的边界的。UserTransaction：非托管模式 (non-managed mode) 下，应用程序可以通过UserTransaction接口控制事务的边界 在tomcat下是没有分布式事务的，可以借助于第三方Jotm和Automikos实现，在spring中分布式事务是通过jta（jotm，atomikos）来进行实现。即：通过代码的方式来决定是否是分布式事务。 注：推荐用服务器自己的数据源(也就是 lookup JNDI)，这样的话，是不是XA事务就由服务器的配置来定制，代码就不需要任何配置来决定是不是XA了。事务本身是不是XA (分布式的）是服务器的事，服务器来管理“资源” （包括数据源，JMS 连接等，一个资源（JDBC连接）如何参与事务是“资源管理器”（驱动程序）的职责，跟程序无关），服务器提供事务管理并作为“事务协调者”来处理多个“资源管理器”（不同的数据库连接）之间的事务一致性。 jotm和automikos网址：1、http://jotm.objectweb.org/2、http://www.atomikos.com/Main/TransactionsEssentials Spring 通过AOP技术可以让我们在脱离EJB的情况下享受声明式事务的丰盛大餐。此外，通过配合使用ObjectWeb的JOTM开源项目，不需要Java EE应用服务器，Spring也可以提供JTA事务。 正因为AOP让Spring拥有了脱离EJB容器的声明式事务能力，而JOTM让我们在脱离Java EE应用服务器下拥有JTA事务能力。所以，人们将AOP和JOTM称为Java软件开发的两个圣杯。 JTA的实现框架有：GeronimoTM/Jencks 官方文档比较少，不适合学习和维护。SimpleJTA 没有实现JTS (Java Transaction Service)而且不是活跃的。Atomikos 是一个另人钦佩的产品。有丰富的文档，而且有很好的支持。JBossTS 是一个应用在JBOSS服务器上的，肯定是一个成熟的产品，也有好的支持，详细信息可以看这里：http://www.theserverside.com/news/thread.tss?thread_id=37941最常见的二个如下：JOTM JOTM(Java Open Transaction Manager)是ObjectWeb的一个开源JTA实现，它本身也是开源应用程序服务器JOnAS(Java Open Application Server)的一部分，为其提供JTA分布式事务的功能。 存在的问题：使用中不能自动rollback，无论什么情况都commit。注：spring3开始已经不再支持jotm Atomikos 大家推荐最多的。和JOTM相比Atomikos Transactions Essentials更加稳定，它原来是商业项目，现在开源了。象MySQL一样卖服务支持的。而且论坛页比较活跃，有问题很快可以解决。","tags":[{"name":"java","slug":"java","permalink":"http://jishusuishouji.github.io/tags/java/"},{"name":"jta","slug":"jta","permalink":"http://jishusuishouji.github.io/tags/jta/"},{"name":"分布式事务","slug":"分布式事务","permalink":"http://jishusuishouji.github.io/tags/分布式事务/"},{"name":"jotm","slug":"jotm","permalink":"http://jishusuishouji.github.io/tags/jotm/"},{"name":"atomikos","slug":"atomikos","permalink":"http://jishusuishouji.github.io/tags/atomikos/"}]},{"title":"java分布式事务:spring+JTA+jotm","date":"2017-01-08T01:23:24.000Z","path":"2017/01/08/java/jta/java分布式事务_spring_JTA_jotm/","text":"业务背景当新建用户时需插入一条用户记录，同时还需在另一个DB中记录日志。因为是不同的DB操作，所以及到分布式事务的处理。 1、代码结构： 2、建表语句：1234567create database log; DROP TABLE IF EXISTS `log`; CREATE TABLE `log` ( `id` varchar(20) NOT NULL, `content` varchar(100) default NULL, PRIMARY KEY (`id`) ); 1234567create database user; DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` varchar(20) NOT NULL, `name` varchar(40) default NULL, PRIMARY KEY (`id`) ); 3、配置文件application.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;!--?xml version=1.0 encoding=UTF-8?--&gt; &lt;beans aop=&quot;&quot; beans=&quot;&quot; http:=&quot;&quot; schema=&quot;&quot; spring-aop.xsd=&quot;&quot; spring-beans.xsd=&quot;&quot; spring-tx.xsd=&quot;&quot; tx=&quot;&quot; www.springframework.org=&quot;&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemalocation=&quot;http://www.springframework.org/schema/beans&quot;&gt; &lt;!-- 引用Spring内部所提供的对JOTM支持的工厂类 --&gt; &lt;bean class=&quot;org.springframework.transaction.jta.JotmFactoryBean&quot; id=&quot;jotm&quot;/&gt; &lt;!-- 配置JTA事务管理器, 并在管理器中使用上面所配置的JOTM --&gt; &lt;bean class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot; id=&quot;txManager&quot;&gt; &lt;property name=&quot;userTransaction&quot; ref=&quot;jotm&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置多个数据源 --&gt; &lt;bean class=&quot;org.enhydra.jdbc.pool.StandardXAPoolDataSource&quot; destroy-method=&quot;shutdown&quot; id=&quot;db1&quot;&gt; &lt;property name=&quot;dataSource&quot;&gt; &lt;bean class=&quot;org.enhydra.jdbc.standard.StandardXADataSource&quot; destroy-method=&quot;shutdown&quot;&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;jotm&quot;/&gt; &lt;property name=&quot;driverName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:MySQL://localhost:3306/user&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.enhydra.jdbc.pool.StandardXAPoolDataSource&quot; destroy-method=&quot;shutdown&quot; id=&quot;db2&quot;&gt; &lt;property name=&quot;dataSource&quot;&gt; &lt;bean class=&quot;org.enhydra.jdbc.standard.StandardXADataSource&quot; destroy-method=&quot;shutdown&quot;&gt; &lt;property name=&quot;transactionManager&quot; ref=&quot;jotm&quot;/&gt; &lt;property name=&quot;driverName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:MySQL://localhost:3306/log&quot;/&gt; &lt;/bean&gt; &lt;/property&gt; &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/bean&gt; &lt;!-- 根据不同的数据源配置两个jdbcTemplate --&gt; &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot; id=&quot;jdbcTemplate1&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;db1&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot; id=&quot;jdbcTemplate2&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;db2&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;com.zdp.dao.UserDao&quot; id=&quot;userDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate1&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;com.zdp.dao.LogDao&quot; id=&quot;logDao&quot;&gt; &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate2&quot;/&gt; &lt;/bean&gt; &lt;bean class=&quot;com.zdp.service.UserService&quot; id=&quot;userService&quot;/&gt; &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt; &lt;property name=&quot;logDao&quot; ref=&quot;logDao&quot;/&gt; &lt;/bean&gt; &lt;!-- JTA事务传播特性 --&gt; &lt;tx:advice id=&quot;txAdviceJTA&quot; transaction-manager=&quot;txManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method isolation=&quot;DEFAULT&quot; name=&quot;save*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception/&quot;&gt; &lt;tx:method isolation=&quot;DEFAULT&quot; name=&quot;add*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception/&quot;&gt; &lt;tx:method isolation=&quot;DEFAULT&quot; name=&quot;create*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception/&quot;&gt; &lt;tx:method isolation=&quot;DEFAULT&quot; name=&quot;insert*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception/&quot;&gt; &lt;tx:method isolation=&quot;DEFAULT&quot; name=&quot;del*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception/&quot;&gt; &lt;tx:method isolation=&quot;DEFAULT&quot; name=&quot;update*&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception/&quot;&gt; &lt;tx:method name=&quot;*&quot; read-only=&quot;true/&quot;&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;/beans&gt; 4、service业务类：1234567891011121314151617181920212223242526public class UserService &#123; private UserDao userDao; private LogDao logDao; public void saveUser(String id, String name) &#123; userDao.insertUser(id, name); // int i = 1 / 0; // 制造异常 logDao.insertLog(id, id + _ + name); &#125; public UserDao getUserDao() &#123; return userDao; &#125; public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public LogDao getLogDao() &#123; return logDao; &#125; public void setLogDao(LogDao logDao) &#123; this.logDao = logDao; &#125; &#125; 5、dao类：123456public class UserDao extends JdbcDaoSupport &#123; public void insertUser(String id, String name) &#123; JdbcTemplate template = getJdbcTemplate(); template.execute(insert into user values(&apos; + id + &apos;,&apos; + name + &apos;)); &#125; &#125; 123456public class LogDao extends JdbcDaoSupport &#123; public void insertLog(String id, String content) &#123; JdbcTemplate template = getJdbcTemplate(); template.execute(insert into log values(&apos; + id + &apos;,&apos; + content + &apos;)); &#125; &#125; 6、测试类：12345678public class UserTest &#123; @Test public void testSave() &#123; ApplicationContext cxt = new ClassPathXmlApplicationContext(ApplicationContext.xml); UserService us = (UserService) cxt.getBean(userService); us.saveUser(1, zhangsan); &#125; &#125;","tags":[{"name":"spring","slug":"spring","permalink":"http://jishusuishouji.github.io/tags/spring/"},{"name":"java","slug":"java","permalink":"http://jishusuishouji.github.io/tags/java/"},{"name":"jta","slug":"jta","permalink":"http://jishusuishouji.github.io/tags/jta/"},{"name":"jotm","slug":"jotm","permalink":"http://jishusuishouji.github.io/tags/jotm/"}]}]