<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="技术随手记" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="如何配置Policy文件进行Java安全策略的设置">
<meta property="og:type" content="article">
<meta property="og:title" content="如何配置Policy文件进行Java安全策略的设置">
<meta property="og:url" content="http://jishusuishouji.github.io/2017/05/09/如何配置Policy文件进行Java安全策略的设置.md/如何配置Policy文件进行Java安全策略的设置/index.html">
<meta property="og:site_name" content="技术随手记">
<meta property="og:description" content="如何配置Policy文件进行Java安全策略的设置">
<meta property="og:updated_time" content="2017-05-08T19:52:26.021Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="如何配置Policy文件进行Java安全策略的设置">
<meta name="twitter:description" content="如何配置Policy文件进行Java安全策略的设置">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://jishusuishouji.github.io/2017/05/09/如何配置Policy文件进行Java安全策略的设置.md/如何配置Policy文件进行Java安全策略的设置/"/>





  <title> 如何配置Policy文件进行Java安全策略的设置 | 技术随手记 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">技术随手记</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://jishusuishouji.github.io/2017/05/09/如何配置Policy文件进行Java安全策略的设置.md/如何配置Policy文件进行Java安全策略的设置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="技术随手记">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="技术随手记">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                如何配置Policy文件进行Java安全策略的设置
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-09T03:08:09+08:00">
                2017-05-09
              </time>
            

            

            
          </span>

          

          
            
            <!--noindex-->
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/05/09/如何配置Policy文件进行Java安全策略的设置.md/如何配置Policy文件进行Java安全策略的设置/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count hc-comment-count" data-xid="2017/05/09/如何配置Policy文件进行Java安全策略的设置.md/如何配置Policy文件进行Java安全策略的设置/" itemprop="commentsCount"></span>
                </a>
              </span>
              <!--/noindex-->
            
          

          
          

          

          

          
              <div class="post-description">
                  如何配置Policy文件进行Java安全策略的设置
              </div>
          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Java语言具有完善的安全框架，从编程语言、编译器、解释程序到Java虚拟机，都能确保Java系统不被恶意的代码或敌对的编译器暗中破坏，它们能够保证Java代码按预定的规则运作。但是如果需要逾越这些限制时，比如读写文件，监听和读写Socket，退出Java系统，就必须使用数字签名或安全策略文件（<code>*.Policy</code>）。 </p>
<p> 在企业内部网中，推荐使用安全策略文件来设置java程序权限。企业内部网中各台计算机的位置、用途和安全性明确，更适于使用安全策略文件来设置java的权限，软件的安装、设置、升级和迁移都非常的方便，并且还可以和数字签名配合使用，更重要的是可以细分每个java程序的权限，使用起来灵活方便。 </p>
<h2 id="Java中安全策略的概念"><a href="#Java中安全策略的概念" class="headerlink" title="Java中安全策略的概念"></a>Java中安全策略的概念</h2><p> Java安全策略详细说明了不同的代码所拥有的不同资源的许可，由一个<code>Policy</code>对象来表达。比如为了让applet（或者运行在<code>SecurityManager</code>下的应用程序）能够执行受保护的行为，例如读写文件，applet（或Java应用程序）必须获得那项操作的许可,安全策略文件可以配置这些许可。<br>在程序中可以通过调用<code>getPolicy</code>方法得到当前安装的<code>Policy</code>对象，也可以通过调用<code>setPolicy</code>方法改变。<code>Policy</code>对象评估整个策略，返回一个适当的<code>Permissions</code>对象，详细说明那些代码可以访问那些资源。 </p>
<p>策略文件可以储存在无格式的ASCII文件，或<code>Policy</code>类的二进制文件，或数据库中。本文仅讨论无格式的ASCII文件的形式。 </p>
<h2 id="Policy文件的格式"><a href="#Policy文件的格式" class="headerlink" title="Policy文件的格式"></a><code>Policy</code>文件的格式</h2><p>\jdk1.8.0_111\jre\lib\security\java.policy<br>\jdk1.8.0_111\jre\lib\security\java.security</p>
<h3 id="Policy文件的语法格式与说明"><a href="#Policy文件的语法格式与说明" class="headerlink" title="Policy文件的语法格式与说明"></a><code>Policy</code>文件的语法格式与说明</h3><p><code>Policy</code>文件实质上是一个记录列表，它可能含有一个“keystore”记录，以及含有零个或多个“<code>grant</code>”记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">keystore &quot;some_keystore_url&quot;, &quot;keystore_type&quot;;</div><div class="line"></div><div class="line">grant [SignedBy &quot;signer_names&quot;] [, CodeBase &quot;URL&quot;] &#123;</div><div class="line">    Permission permission_class_name [ &quot;target_name&quot; ] [, &quot;action&quot;] [, SignedBy &quot;signer_names&quot;];</div><div class="line">    Permission ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="keystore记录"><a href="#keystore记录" class="headerlink" title="keystore记录"></a><code>keystore</code>记录</h4><p><code>keystore</code>是一个私有密钥（private keys）数据库和相应的数字签名，例如X.509证书。Policy文件中可能只有一条keystore记录（也可能不含有该记录），它可以出现在文件中<code>grant</code>记录以外的任何地方。Policy配置文件中指定的keystores用于寻找grant记录中指定的、签名者的公共密钥（public keys），如果任何grant记录指定签名者（signer_names），那么，keystore记录必须出现在policy配置文件中。 </p>
<p>—- “some_keystore_url”是指keystore的URL位置，”keystore_type”是指keystore的类型。第二个选项是可选项，如果没有指定，该类型则假定由安全属性文件（java.security）中的”keystore.type”属性来确定。keystore类型定义了keystore信息的存储和数据格式，用于保护keystore中的私有密钥和keystore完整性的算法。Sun Microsystems支持的缺省类型为“JKS”。 </p>
<h4 id="grant记录"><a href="#grant记录" class="headerlink" title="grant记录"></a><code>grant</code>记录</h4><p>在`Policy文件中的每一个grant记录含有一个CodeSource（一个指定的代码）及其permission(许可)。 </p>
<p>Policy文件中的每一条grant记录遵循下面的格式，以保留字“grant”开头，表示一条新的记录的开始，“Permission”是另一个保留字，在记录中用来标记一个新的许可的开始。每一个grant记录授予一个指定的代码（CodeBase）一套许可（Permissions）。 </p>
<p><code>permission_class_name</code>必须是一个合格并存在的类名，例如<code>java.io.FilePermission</code>，不能使用缩写（例如<code>FilePermission</code>）。<br>target_name用来指定目标类的位置，action用于指定目标类拥有的权限。<br>target_name可以直接指定类名（可以是绝对或相对路径），目录名，也可以是下面的通配符： </p>
<p>directory/<em> 目录下的所有文件
</em>当前目录的所有文件<br>directory/-目录下的所有文件，包括子目录</p>
<ul>
<li>当前目录下的所有文件，包括子目录<br>《ALL FILES》文件系统中的所有文件<br>对于java.io.FilePermission，action可以是：<br>read, write, delete和execute。<br>对于java.net.SocketPermission，action可以是：<br>listen，accept，connect，read，write。</li>
</ul>
<p>—- 1.3 Policy文件中的属性扩展（Property Expansion）<br>—- 属性扩展与shell中使用的变量扩展类似，它的格式为： </p>
<p>“${some.property}”<br>实际使用的例子为：<br>permission java.io.FilePermission<br>“${user.home}”, “read”;<br>“${user.home}”的值为”d:\Project”，<br>因此，下面的语句和上面的语句是一样的：<br>permission java.io.FilePermission “<br>d:\Project “, “read”;</p>
<p>三. 实例<br>—- 当初始化Policy时，首先装载系统Policy，然后再增加用户Policy，如果两者都不存在，则使用缺省的Policy，即原始的沙箱模型。<br>—- 系统Policy文件的缺省位置为： </p>
<p>{java.home}/lib/security/java.policy (Solaris)<br>{java.home}\lib\security\java.policy (Windows)<br>用户Policy文件的缺省位置为：<br>{user.home}/.java.policy (Solaris)<br>{user.home}.java.policy (Windows)</p>
<p>—- 其实，在实际使用中，我们可能不会象上面介绍的那么复杂，特别是在不使用数字签名时。这时，我们完全可以借鉴JDK 1.2提供给我们的现成的\jdk1.2\jre\lib\security\java.policy文件，根据我们的需要作相应的修改，本文就针对不使用数字签名情况详细说明安全策略文件的用法。<br>—- 下面，是一个完整的在Windows 95/98/NT下使用的.java.policy文件。在文件中，分别使用注释的形式说明了每个“permission”记录的用途。 </p>
<p>// For LanServerTalk.java and LanClientTalk.java</p>
<p>grant {<br>//对系统和用户目录“读”的权限<br>permission java.util.PropertyPermission<br>“user.dir”, “read”;<br>permission java.util.PropertyPermission<br>“user.home”, “read”;<br>permission java.util.PropertyPermission<br>“java.home”, “read”;<br>permission java.util.PropertyPermission<br>“java.class.path”, “read”;<br>permission java.util.PropertyPermission<br>“user.name”, “read”; </p>
<p>//对线程和线程组的操作权限<br>permission java.lang.RuntimePermission<br>“modifyThread”;<br>permission java.lang.RuntimePermission<br>“modifyThreadGroup”;</p>
<p>//操作Socket端口的各种权限<br>permission java.net.SocketPermission<br>“-“, “listen”;<br>permission java.net.SocketPermission<br>“-“, “accept”;<br>permission java.net.SocketPermission<br>“-“, “connect”;<br>permission java.net.SocketPermission “-“, “read”;<br>permission java.net.SocketPermission “-“, “write”;</p>
<p>//读写文件的权限<br>permission java.io.FilePermission “-“, “read”;<br>permission java.io.FilePermission “-“, “write”;</p>
<p>//退出系统的权限，例如System.exit(0)<br>permission java.lang.RuntimePermission “exitVM”;<br>};</p>
<p>四. java.policy文件的使用<br>—- 对于windows 95/98/NT，使用.java.policy文件的方法主要有下面两种。<br>—- 1． 使用缺省目录 </p>
<p>—- 我们可以简单地将编辑好的.java.policy文件拷贝到windows 95/98/NT的HOME目录，这时，所有的applet(或Java应用程序)可能都拥有某些相同的权限，使用起来简单，但不灵活（例如：对于java.io.FilePermission ，其目标类的target_name必须使用绝对路径），如果不是在企业内部网中使用，还可能存在一定安全隐患。 </p>
<p>—- 2． 在命令行中指定 </p>
<p>—- 在命令行，如果我们希望传递一个Policy文件给appletviewer，还可以使用”-J-Djava.security.policy”参数来指定policy的位置： </p>
<p>appletviewer -J-Djava.security.<br>policy=pURL myApplet</p>
<p>—- pURL为Policy文件的位置。下面，是一个实际的例子，以当前目录的.java.policy文件所指定的安全策略运行当前目录的LanServerTalk.html（文件中装载并运行LanServerTalk.java）：<br>appletviewer -J-Djava.security.policy<br>=.java.policy LanServerTalk.html </p>
<p>—- 这种方法使用灵活，特别是作为一个软件包在企业内部网中发布时，安装、设置和迁移软件，基本无须修改Policy文件的内容，使用起来相当简单，而且，安全许可的范围控制较精细。</p>
<hr>
<p>缺省策略实现和策略文件语法<br>上次修改时间： 1998 年 10 月 30 日</p>
<p>Java 应用程序环境的策略（对不同来源的代码指定权限）由 Policy 对象来表示。更明确地说，就是由 Policy 类（包含在 java.security 包中）的实现抽象方法的 Policy 子类来表示。</p>
<p>Policy 对象所用策略信息的源位置由 Policy 实现决定。缺省 Policy 实现从静态策略配置文件获得自己的信息。本文档的其余部分叙述了缺省 Policy 实现及其所读取的策略文件中必须使用的语法。有关使用 Policy Tool 来创建策略文件（不必知道所需语法）的详细信息，请参阅《策略工具文档》 (for Solaris) (for Windows)。</p>
<p>以下是本文档其余部分的概要：</p>
<p>缺省 Policy 实现<br>缺省策略文件位置<br>更改 Policy 实现<br>策略文件语法<br>策略文件示例<br>策略文件中的属性扩展<br>相关文档</p>
<p>缺省 Policy 实现<br>在缺省 Policy 实现中，可在一个或多个策略配置文件中指定策略。配置文件的作用是指定特定代码源的代码所能获得的权限。</p>
<p>可利用简单的文本编辑器或 Policy Tool 实用程序来编写策略文件。</p>
<p>缺省情况下，系统上只有单个全系统策略文件和唯一的（可选）用户策略文件。</p>
<p>首次调用缺省 Policy 对象的 getPermissions 方法或在任何时候调用 Policy 对象 refresh 方法时，即对其进行初始化。初始化包括分析策略配置文件（请参阅策略文件语法）及组装 Policy 对象。</p>
<p>缺省策略文件位置<br>如前所述，系统在缺省情况下具有单个全系统策略文件和唯一的用户策略文件。</p>
<p>系统策略文件的缺省位置为：</p>
<p>java.home/lib/security/java.policy  (Solaris)<br>java.home\lib\security\java.policy  (Windows)<br>注意： java.home 指的是名为“java.home”的系统属性的值，它指定 JDK 的安装目录。</p>
<p>系统策略文件可用于授予全系统代码权限。与 JDK 一起安装的 java.policy 文件可向标准扩展 (Java standard extensions) 授予全部权限，允许任何用户在无特权要求的端口进行监听，同时允许任何代码读取某些对安全不敏感的“标准”属性（例如“os.name”和“file.separator”属性）。</p>
<p>用户策略文件的缺省位置为：</p>
<p>user.home/.java.policy  (Solaris)<br>user.home.java.policy  (Windows)<br>注意： user.home 指的是名为“user.home”的系统属性的值，它指定用户的主目录。在 Windows 系统中，假定用户名是 uName，“user.home”属性的缺省值为：</p>
<p>C:\Winnt\Profiles\uName（多用户 Windows NT 系统中）<br>C:\Windows\Profiles\uName（多用户 Windows 95 系统中）<br>C:\Windows（单用户 Windows 95 系统中）<br>初始化 Policy 时，将首先加载系统策略，然后在 Policy 中添加用户策略。如果两种策略均不存在，则采用内置策略。该内置策略与原始的沙箱策略相同。</p>
<p>策略文件的位置在安全属性文件中指定。安全属性文件的位置为：</p>
<p>java.home/lib/security/java.security  (Solaris)<br>java.home\lib\security\java.security  (Windows)<br>如上所述，java.home 指示 JDK 的安装目录。策略文件的位置被指定为其名称具有以下形式的属性的值：</p>
<p>policy.url.n<br>其中 n 为数字。应采用以下形式的语句行来指定每个属性值：</p>
<p>policy.url.n=URL<br>其中，URL 为 URL 规范。</p>
<p>例如，安全属性文件中将把缺省系统和用户策略文件定义为：</p>
<p>policy.url.1=file:${java.home}/lib/security/java.policy<br>policy.url.2=file:${user.home}/.java.policy<br>有关利用特殊语法（例如利用 ${java.home} 来指定 java.home 属性值）来指定属性值的详细信息，请参阅属性扩展。</p>
<p>实际上，用户可以指定多个 URL（包括“<a href="http://”形式的" target="_blank" rel="external">http://”形式的</a> URL）,从而加载所有指定的策略文件。也可注释掉或更改第二个 URL，从而禁止读取缺省用户策略文件。</p>
<p>该算法自 policy.url.1 开始，然后不断递增直到查不到 URL 为止。因此，如果有了 policy.url.1 和 policy.url.3，就不会读取 policy.url.3。</p>
<p>运行时指定其它策略文件</p>
<p>在执行应用程序时也可以指定附加的或不同的策略文件，方法是用“-Djava.security.policy”命令行参数来指定（该命令行参数设置 java.security.policy 属性值）。例如，如果使用</p>
<pre><code>java -Djava.security.manager -Djava.security.policy=someURL SomeApp
</code></pre><p>这里 someURL 是指定策略文件位置的 URL，则除了加载安全属性文件中指定的所有策略文件外，还会加载本方法所指定的策略文件。</p>
<p>注意：</p>
<p>URL 可以是任何标准 URL，也可以只是当前目录下策略文件的文件名，如下例所示：<br>    java -Djava.security.manager -Djava.security.policy=mypolicy WriteFile<br>“-Djava.security.manager”参数可确保缺省安全管理器已被安装，这样就容易对应用程序进行策略检查。如果应用程序 SomeApp 安装有安全管理器，则不需要该参数。<br>如果使用</p>
<pre><code>java -Djava.security.manager -Djava.security.policy==someURL SomeApp
</code></pre><p>（请注意双等号），就会仅使用指定的策略文件，而安全属性文件中指出的策略文件将被忽略。</p>
<p>如果要将策略文件传递给 appletviewer，就应使用参数“-J-Djava.security.policy”，如下所示：</p>
<pre><code>appletviewer -J-Djava.security.policy=someURL myApplet
</code></pre><p>请注意：如果将安全属性文件中的“policy.allowSystemProperty”属性设置为“false”，就会忽略“-Djava.security.policy”策略文件值（对于 java 和 appletviewer 命令）。缺省值为“true”。</p>
<p>更改 Policy 实现<br>可以用其它 policy 类来代替缺省 Policy 实现类，前提是前者属于抽象 Policy 类的子类并可实现 getPermissions 方法（及其它必要的方法）。</p>
<p>缺省 Policy 实现的更改可通过编辑安全属性文件来完成，其中安全属性文件指 JDK lib/security 目录中的 java.security 文件。</p>
<p>下面给出一种可在 java.security 中设置的属性类型的形式：</p>
<pre><code>policy.provider=PolicyClassName
</code></pre><p>PolicyClassName 必须指定所需 Policy 实现类的完整名称。该属性的缺省安全属性文件项如下所示：</p>
<pre><code>policy.provider=sun.security.provider.PolicyFile
</code></pre><p>要想自定义安全属性文件项，可通过更改属性值来指定另一个类，如下例所示：</p>
<p>   policy.provider=com.mycom.MyPolicy<br>策略文件语法<br>JDK 的策略配置文件可用于指定来自特定代码源的代码所能获得的权限（何种系统资源访问类型）。</p>
<p>为了使 applet（或在安全管理器下运行的应用程序）能够执行受保护的动作（例如读写文件），必须向 applet（或应用程序）授予进行该动作的权限。在缺省 Policy 实现中，必须由策略配置文件中的 grant 项授予该权限。有关详细信息，请参阅以下内容及 “Java 安全体系结构规范”（唯一的例外是：代码对位于与它自身同一 (URL) 位置并且对那一位置子目录下的文件总是自动拥有读权限，而无需授予明确的权限）。</p>
<p>策略配置文件主要包含授权项列表。其中可能包含“keystore”（密钥仓库）项及零个或多个“grant”（授权）项。</p>
<p>Keystore 项</p>
<p>keystore 是存放私钥及相关数字证书（例如验证对应的公钥的 X.509 证书链）的数据库。keytool 实用程序 (for Solaris) (for Windows) 用于创建和管理密钥仓库。策略配置文件中所指定的 keystore 用于查找在该文件的授权项中所指定的签名人公钥。如果某一授权项指定了签名人别名（请参阅以下内容），则在策略配置文件中必须含有 keystore 项。</p>
<p>目前，在策略文件中只能有一个 keystore 项（第一项后的其它 keystore 项将被忽略），且该项可位于文件授权项以外的任何位置。其语法如下所示：</p>
<pre><code>keystore &quot;some_keystore_url&quot;, &quot;keystore_type&quot;;
</code></pre><p>其中“some_keystore_url”指定密钥仓库的 URL 位置，而“keystore_type”指定密钥仓库的类型。</p>
<p>URL 是相对于策略文件位置而言。因此，如果在安全属性文件中按以下方式指定策略文件：</p>
<pre><code>policy.url.1=http://foo.bar.com/fum/some.policy
</code></pre><p>而且策略文件中含有以下项：</p>
<pre><code>keystore &quot;.keystore&quot;;
</code></pre><p>就会从下列位置加载密钥仓库：</p>
<pre><code>http://foo.bar.com/fum/.keystore
</code></pre><p>URL 也可以是绝对 URL。</p>
<p>keystore type 定义密钥仓库信息的存储和数据格式，同时也定义用于保护密钥仓库中私钥及密钥仓库自身完整性的算法。Sun Microsystems 所支持的缺省类型是名为“JKS”的专用密钥仓库类型。因此，如果密钥仓库类型属于“JKS”，就无需在 keystore 项中加以指定。</p>
<p>授权项</p>
<p>通常认为执行代码来自于某“代码源”（由 CodeSource 类型的对象表示）。代码源不仅包含代码的源位置 (URL)，而且还包括对包含与签写代码的私钥相对应的公钥的证书之引用。代码源中的证书通过用户密钥仓库中的符号别名引用。</p>
<p>每个授权项包括一个或多个“权限项”，前面为可选 codeBase 和 signedBy 名字/值对，用于指定要授予权限的代码。授权项的基本格式如下所示：</p>
<p>  grant signedBy “signer_names”, codeBase “URL” {<br>    permission permission_class_name “target_name”, “action”,<br>        signedBy “signer_names”;<br>    ….<br>    permission permission_class_name “target_name”, “action”,<br>        signedBy “signer_names”;<br>  };</p>
<p>以上所有非斜体的项必须按原样出现（尽管大小写无关紧要且部分为可选项，如下所示）。 斜体项代表变量值。</p>
<p>授权项必须以 grant 开头。</p>
<p>SignedBy 和 CodeBase 域</p>
<p>signedBy 和 codeBase 名字/值对为可选域，其间的顺序无关紧要。</p>
<p>signedBy 值表示存储在密钥仓库中的证书别名。该证书内的公钥用于验证代码上的数字签名；用户可以向由私钥（私钥对应于该别名所指定的 keystore 项中的公钥）签名的代码授予权限。</p>
<p>signedBy 的值可以是由逗号分隔的多个别名。 例如“Adam,Eve,Charles”，其含义为“Adam，Eve 和 Charles 签名”；它们之间的关系是 AND（与）而非 OR（或）。更确切地说，“Adam 签名的代码”语句的含义是“JAR 文件中有含类文件的代码，这个 JAR 文件已用密钥仓库中别名为 Adam 的项中与公钥所对应的私钥签名”。</p>
<p>signedBy 域可选，这是因为如果省略该域，则表示“任何签名人”。代码是否有签名或由谁签名都没有关系。</p>
<p>codeBase 值表示的是代码源位置；用户可向来自该位置的代码授权。空 codeBase 项表示“任何代码”；代码来源于何处没有关系。</p>
<p>注意： codeBase 值是 URL，因此应该始终用正斜杠（而不要用反斜杠）作为目录分隔符，即使代码源实际在 Windows 系统上。这样，如果 Windows 系统上代码的源位置实际上是 C:\somepath\api\，则 codeBase 策略项的外观将如下所示：</p>
<pre><code>grant codeBase &quot;file:/C:/somepath/api/&quot; {
  ...
}
</code></pre><p>codeBase</p>
<p>值的准确含义要取决于最后的字符。后面跟着“/”的 codeBase 将匹配指定目录下的所有类文件（非 JAR 文件）。后面跟着“/*”的 codeBase 将匹配该目录下的所有文件（类文件和 JAR 文件）。后面跟着“/-”的 codeBase 将匹配该目录下的所有文件（类文件和 JAR 文件）及该目录下子目录中的所有文件。下表说明了各种不同的情况。<br>下载代码的 Codebase URL  策略中的 Codebase URL   是否匹配?<br>java.sun.com/people/gong/   java.sun.com/people/gong<br>是</p>
<p>java.sun.com/people/gong/   java.sun.com/people/gong/<br>是</p>
<p>java.sun.com/people/gong/   java.sun.com/people/gong/*<br>是</p>
<p>java.sun.com/people/gong/   java.sun.com/people/gong/-<br>是</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/gong/<br>否</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/gong/-<br>是</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/gong/*<br>是</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/-<br>是</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/*<br>否</p>
<p>java.sun.com/people/gong/   java.sun.com/people/-<br>是</p>
<p>java.sun.com/people/gong/   java.sun.com/people/*<br>否</p>
<p>权限项</p>
<p>权限项必须以 permission 开头。上述模板中的字 permission_class_name 的实际值可以是特定的权限类型（例如 java.io.FilePermission 或 java.lang.RuntimePermission）。</p>
<p>“action” 对于许多权限类型而言都是必需的，例如 java.io.FilePermission（指定允许何种类型的文件访问权限）。 对于诸如 java.lang.RuntimePermission 等权限类型则为可选项：既可以在 permission_class_name 之后的 “target_name” 值中指定权限，也可以不指定权限。</p>
<p>权限项的 signedBy 名字/值对为可选项。如果有名字/值对，则表示为已签名权限。意即必须由给定的别名对权限类签名，方可授予权限。例如，假定有以下授权项：</p>
<p>  grant {<br>    permission Foo “foobar”, signedBy “FooSoft”;<br>  }<br>如果将 Foo.class 权限放到 JAR 文件中，且该 JAR 文件已由与 “FooSoft” 别名所指定的证书中的公钥相对应的私钥签名，或在 Foo.class 是系统类（因为系统类不受策略限制）的情况下，即可授予 Foo 权限类型。</p>
<p>权限项中出现的项目必须按指定顺序出现（permission，permission_class_name，”target_name”，”action” 和 signedBy “signer_names”）。分号表示项终止。</p>
<p>大小写对于标识符（permission、signedBy、codeBase 等）来说并不重要，但对于 permission_class_name 或作为值传递过来的字符串而言就很重要了。</p>
<p>有关 Windows 系统上文件路径规范的注意事项</p>
<p>请注意：在指定 java.io.FilePermission 时，”target_name” 是文件路径。在 Windows 系统上，无论何时在字符串中（而不是在 codeBase URL 中）直接指定文件路径，路径中都需要两个反斜杠来代表一个实际的反斜杠，如下例所示：</p>
<p>  grant {<br>      permission java.io.FilePermission “C:\users\cathy\foo.bat”, “read”;<br>  };<br>原因在于：字符串是由符号处理器 (java.io.StreamTokenizer) 来处理的。符号处理器允许将“\”用作转义字符串（例如，“\n”表示换行），因此需要用两个反斜杠来表示一个反斜杠。符号处理器处理完以上文件路径字符串后，将把双反斜杠转换成单个反斜杠，其最终结果为：</p>
<pre><code>&quot;C:\users\cathy\foo.bat&quot;
</code></pre><p>策略文件示例<br>策略配置文件中两项的示例如下所示：</p>
<p>  // 如果代码由 “Duke” 签字，则向 /tmp 中的所有文件<br>  // 授予读/写访问权限：</p>
<p>  grant signedBy “Duke” {<br>    permission java.io.FilePermission “/tmp/*”, “read,write”;<br>  };<br>// 授予所有用户以下权限：</p>
<p>grant { permission java.util.PropertyPermission “java.vendor”; };</p>
<p>另一个示例策略配置文件如下所示。</p>
<p>  grant signedBy “sysadmin”, codeBase “file:/home/sysadmin/<em>“ {<br>    permission java.security.SecurityPermission “Security.insertProvider.</em>“;<br>    permission java.security.SecurityPermission “Security.removeProvider.<em>“;<br>    permission java.security.SecurityPermission “Security.setProperty.</em>“;<br>  };<br>本示例规定：只有满足以下条件的代码才能调用 Security 类中的方法以添加或删除提供者或者设置 Security 属性：</p>
<p>代码将从位于本地文件系统上“/home/sysadmin/”目录下的签名 JAR 文件中加载。<br>可以用密钥仓库中别名“sysadmin”所引用的公钥来校验签名。<br>可以忽略代码源中两个组件的任何一个（或两者）。下面是忽略 codeBase 的示例：</p>
<p>  grant signedBy “sysadmin” {<br>    permission java.security.SecurityPermission “Security.insertProvider.<em>“;<br>    permission java.security.SecurityPermission “Security.removeProvider.</em>“;<br>  };<br>如果该策略生效，则来自 JAR 文件（由 “sysadmin” 签名）的代码可以添加/删除提供者，而不管 JAR 文件来源于何处。</p>
<p>下面是没有签名人的示例：</p>
<p>  grant codeBase “file:/home/sysadmin/-“ {<br>    permission java.security.SecurityPermission “Security.insertProvider.<em>“;<br>    permission java.security.SecurityPermission “Security.removeProvider.</em>“;<br>  };<br>这里，来自本地文件系统“/home/sysadmin/”目录下任意位置的代码都可以添加/删除提供者。 该代码不必签名。</p>
<p>下面是既不含 codeBase 也不含 signedBy 的示例：</p>
<p>  grant {<br>    permission java.security.SecurityPermission “Security.insertProvider.<em>“;<br>    permission java.security.SecurityPermission “Security.removeProvider.</em>“;<br>  };<br>此处，由于两个代码源组件均被忽略，因此任何代码（不管来自于何处，是否已签名或由何人签名）都可添加/删除提供者。</p>
<p>策略文件中的属性扩展<br>策略文件和安全属性文件中可以进行属性扩展。</p>
<p>属性扩展类似于扩展 shell 中的变量。也就是说，当类似</p>
<pre><code>${some.property}
</code></pre><p>的字符串出现在策略文件或安全属性文件中时，它将被扩展为系统属性的值。 例如，</p>
<pre><code>permission java.io.FilePermission &quot;${user.home}&quot;, &quot;read&quot;;
</code></pre><p>将把 “${user.home}” 扩展为使用 “user.home” 系统属性的值。如果该属性的值是 “/home/cathy”，则以上示例等价于：</p>
<pre><code>permission java.io.FilePermission &quot;/home/cathy&quot;, &quot;read&quot;;
</code></pre><p>为了能在与平台无关的策略文件中使用，也可采用特殊记号 “${/}”。该记号是 “${file.separator}” 的简化表示。这种方式允许使用下列字符串：</p>
<pre><code>permission java.io.FilePermission &quot;${user.home}${/}*&quot;, &quot;read&quot;;
</code></pre><p>如果 “user.home” 属性的值是 /home/cathy，而且是在 Solaris 系统上，则以上字符串将转换为：</p>
<pre><code>permission java.io.FilePermission &quot;/home/cathy/*&quot;, &quot;read&quot;;
</code></pre><p>如果 “user.home” 值是 C:\users\cathy，而且是在 Windows 系统上，则以上字符串将转换为：</p>
<pre><code>permission java.io.FilePermission &quot;C:\users\cathy\*&quot;, &quot;read&quot;;
</code></pre><p>同样，作为一种特例，如果扩展 codebase 中的属性，例如</p>
<pre><code>grant codeBase &quot;file:${java.home}/lib/ext/&quot;
</code></pre><p>则任何文件分隔符都将自动转换为“/”。这样，在 Windows 系统上，以上字符串将转换为：</p>
<pre><code>grant codeBase &quot;file:C:/jdk1.2/lib/ext/&quot;
</code></pre><p>即使 “java.home” 被设置为 C:\jdk1.2。因此，用户就不必也不应该在 codeBase 字符串中使用 ${/}。</p>
<p>策略文件中允许使用双引号字符串的地方都可进行属性扩展。其中包括 “signer_names”、”URL”、”target_name” 和 “action” 域。</p>
<p>是否允许属性扩展由安全属性文件中的“policy.expandProperties”属性控制。如果该属性为真（缺省值），则允许扩展。</p>
<p>请注意：不能使用嵌套属性；嵌套属性将无效。 例如，</p>
<pre><code>&quot;${user.${foo}}&quot;
</code></pre><p>是无效的，即使将“foo”属性设置为“home”。原因在于属性解析程序不能识别嵌套属性；解析程序只是简单地搜索第一个“${”，然后继续搜索直到找到第一个“}”为止，同时试图将搜索结果（这里是 “${user.$foo}”）解释为属性。如果没有这种属性，则解析程序就会发生解释失败。</p>
<p>也请注意：如果在 grant 项、permission 项或 keystore 项中无法扩展某个属性，则该项将被忽略。例如，如果在没有定义系统属性“foo”的情况下使用语句：</p>
<pre><code>grant codeBase &quot;${foo}&quot; {
  permission ...;
  permission ...;
};
</code></pre><p>则该 grant 项中的所有权限都将被忽略。如果使用语句：</p>
<pre><code>grant {
  permission Foo &quot;${foo}&quot;;
  permission Bar;
};
</code></pre><p>则将仅忽略“permission Foo…”项。最后，如果使用语句：</p>
<pre><code>keystore &quot;${foo}&quot;;
</code></pre><p>则将忽略 keystore 项。</p>
<p>Windows 系统、文件路径和属性的扩展</p>
<p>如上所述，在 Windows 系统上，当直接在字符串中（而不是在 codeBase URL 中）指定文件路径时，用户需要用两个反斜杠来代表文件路径中一个实际的反斜杠，如下例所示：</p>
<pre><code>grant {
    permission java.io.FilePermission &quot;C:\\users\\cathy\\foo.bat&quot;, &quot;read&quot;;
};
</code></pre><p>原因在于：字符串是由符号处理器 (java.io.StreamTokenizer) 来处理的。符号处理器允许将“\”用作转义字符串（例如，“\n”表示换行），因此需要用两个反斜杠来表示一个反斜杠。符号处理器处理完以上文件路径字符串后，将把双反斜杠转换成单个反斜杠，其最终结果为：</p>
<pre><code>&quot;C:\users\cathy\foo.bat&quot;
</code></pre><p>符号处理器处理完字符串后，即进行字符串中的属性扩展。因此，如果使用字符串：</p>
<pre><code>&quot;${user.home}\\foo.bat&quot;
</code></pre><p>则符号处理器首先处理字符串，即将双反斜杠转换成单个反斜杠，其结果为：</p>
<pre><code>&quot;${user.home}\foo.bat&quot;
</code></pre><p>随即扩展 ${user.home} 属性，其最终结果为：</p>
<pre><code>&quot;C:\users\cathy\foo.bat&quot;
</code></pre><p>以上假定 “user.home” 的值是 C:\users\cathy。当然，为实现与平台无关，最好在开始指定字符串时不要显式带上斜杠，即可以用 ${/} 属性来代替，如下例所示：</p>
<pre><code>&quot;${user.home}${/}foo.bat&quot;
</code></pre>
      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/05/09/java安全管理器SecurityManager.md/java安全管理器SecurityManager/" rel="next" title="java安全管理器SecurityManager">
                <i class="fa fa-chevron-left"></i> java安全管理器SecurityManager
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/09/java/Java虚拟机：Java类加载机制/" rel="prev" title="Java虚拟机：Java类加载机制">
                Java虚拟机：Java类加载机制 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="hypercomments_widget"></div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="技术随手记" />
          <p class="site-author-name" itemprop="name">技术随手记</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">63</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">40</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">47</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java中安全策略的概念"><span class="nav-number">1.</span> <span class="nav-text">Java中安全策略的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Policy文件的格式"><span class="nav-number">2.</span> <span class="nav-text">Policy文件的格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Policy文件的语法格式与说明"><span class="nav-number">2.1.</span> <span class="nav-text">Policy文件的语法格式与说明</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#keystore记录"><span class="nav-number">2.1.1.</span> <span class="nav-text">keystore记录</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#grant记录"><span class="nav-number">2.1.2.</span> <span class="nav-text">grant记录</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">技术随手记</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	

		<script type="text/javascript">
		_hcwp = window._hcwp || [];

		_hcwp.push({widget:"Bloggerstream", widget_id: 89144, selector:".hc-comment-count", label: "{\%COUNT%\}" });

		
		_hcwp.push({widget:"Stream", widget_id: 89144, xid: "2017/05/09/如何配置Policy文件进行Java安全策略的设置.md/如何配置Policy文件进行Java安全策略的设置/"});
		

		(function() {
		if("HC_LOAD_INIT" in window)return;
		HC_LOAD_INIT = true;
		var lang = (navigator.language || navigator.systemLanguage || navigator.userLanguage || "en").substr(0, 2).toLowerCase();
		var hcc = document.createElement("script"); hcc.type = "text/javascript"; hcc.async = true;
		hcc.src = ("https:" == document.location.protocol ? "https" : "http")+"://w.hypercomments.com/widget/hc/89144/"+lang+"/widget.js";
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(hcc, s.nextSibling);
		})();
		</script>

	












  





  

  

  

  

</body>
</html>
