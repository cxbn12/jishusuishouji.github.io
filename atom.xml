<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术随手记</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jishusuishouji.github.io/"/>
  <updated>2017-05-12T08:59:16.199Z</updated>
  <id>http://jishusuishouji.github.io/</id>
  
  <author>
    <name>技术随手记</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java信号量Semaphore类的简单介绍</title>
    <link href="http://jishusuishouji.github.io/2017/05/12/Java%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D.md/Java%E4%BF%A1%E5%8F%B7%E9%87%8FSemaphore%E7%B1%BB%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"/>
    <id>http://jishusuishouji.github.io/2017/05/12/Java信号量Semaphore类的简单介绍.md/Java信号量Semaphore类的简单介绍/</id>
    <published>2017-05-12T08:57:38.000Z</published>
    <updated>2017-05-12T08:59:16.199Z</updated>
    
    <content type="html"><![CDATA[<p> <code>Semaphore</code>可以完成信号量控制，<code>Semaphore</code>可以控制某个资源可被同时访问的数目，通过<code>acquire()</code>获取一个许可，如果没有就等待，而<code>release()</code>释放一个许可。比如在Windows下可以设置共享文件的最大客户端访问个数。 </p>
<p>Semaphore实现的功能就类似厕所有5个坑，假如有10个人要上厕所，那么同时只能有多少个人去上厕所呢？同时只能有5个人能够占用，当5个人中 的任何一个人让开后，其中等待的另外5个人中又有一个人可以占用了。另外等待的5个人中可以是随机获得优先机会，也可以是按照先来后到的顺序获得机会，这取决于构造Semaphore对象时传入的参数选项。单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另一个线程释放“锁”，这可应用于死锁恢复的一些场合。</p>
<p>Semaphore维护了当前访问的个数，提供同步机制，控制同时访问的个数。在数据结构中链表可以保存“无限”的节点，用Semaphore可以实现有限大小的链表。另外重入锁 ReentrantLock 也可以实现该功能，但实现上要复杂些。 </p>
<p>下面的Demo中申明了一个只有5个许可的Semaphore，而有20个线程要访问这个资源，通过acquire()和release()获取和释放访问许可。</p>
<p>package com.test;</p>
<p>import java.util.concurrent.ExecutorService;</p>
<p>import java.util.concurrent.Executors;</p>
<p>import java.util.concurrent.Semaphore;</p>
<p>public class TestSemaphore {</p>
<pre><code>         public static void main(String[] args) {

         // 线程池

         ExecutorService exec = Executors.newCachedThreadPool();

         // 只能5个线程同时访问

         final Semaphore semp = new Semaphore(5);

          // 模拟20个客户端访问

          for (int index = 0; index &lt; 20; index++) {

                       final int NO = index;

                       Runnable run = new Runnable() {

                                          public void run() {

                                                     try {

                                                             // 获取许可

                                                             semp.acquire();

                                                             System.out.println(&quot;Accessing: &quot; + NO);

                                                             Thread.sleep((long) (Math.random() * 10000));

                                                             // 访问完后，释放

                                                             semp.release();

                                                             System.out.println(&quot;-----------------&quot;+semp.availablePermits());

                                                     } catch (InterruptedException e) {

                                                             e.printStackTrace();

                                                     }

                                           }

                               };

               exec.execute(run);

      }

      // 退出线程池

      exec.shutdown();

}
</code></pre><p>} </p>
<p>执行结果如下：</p>
<p>Accessing: 0</p>
<p>Accessing: 1</p>
<p>Accessing: 3</p>
<p>Accessing: 4</p>
<p>Accessing: 2</p>
<p>—————–0</p>
<p>Accessing: 6</p>
<p>—————–1</p>
<p>Accessing: 7</p>
<p>—————–1</p>
<p>Accessing: 8</p>
<p>—————–1</p>
<p>Accessing: 10</p>
<p>—————–1</p>
<p>Accessing: 9</p>
<p>—————–1</p>
<p>Accessing: 5</p>
<p>—————–1</p>
<p>Accessing: 12</p>
<p>—————–1</p>
<p>Accessing: 11</p>
<p>—————–1</p>
<p>Accessing: 13</p>
<p>—————–1</p>
<p>Accessing: 14</p>
<p>—————–1</p>
<p>Accessing: 15</p>
<p>—————–1</p>
<p>Accessing: 16</p>
<p>—————–1</p>
<p>Accessing: 17</p>
<p>—————–1</p>
<p>Accessing: 18</p>
<p>—————–1</p>
<p>Accessing: 19</p>
]]></content>
    
    <summary type="html">
    
      Java信号量Semaphore类的简单介绍
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>彻底理解ThreadLocal</title>
    <link href="http://jishusuishouji.github.io/2017/05/11/java/%E5%BD%BB%E5%BA%95%E7%90%86%E8%A7%A3ThreadLocal/"/>
    <id>http://jishusuishouji.github.io/2017/05/11/java/彻底理解ThreadLocal/</id>
    <published>2017-05-11T13:08:23.000Z</published>
    <updated>2017-05-11T13:15:42.751Z</updated>
    
    <summary type="html">
    
      彻底理解ThreadLocal
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用实例揭示notify()和notifyAll()的本质区别</title>
    <link href="http://jishusuishouji.github.io/2017/05/11/java/%E7%94%A8%E5%AE%9E%E4%BE%8B%E6%8F%AD%E7%A4%BAnotify__%E5%92%8CnotifyAll__%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB/"/>
    <id>http://jishusuishouji.github.io/2017/05/11/java/用实例揭示notify__和notifyAll__的本质区别/</id>
    <published>2017-05-11T12:17:54.000Z</published>
    <updated>2017-05-11T12:44:55.401Z</updated>
    
    <content type="html"><![CDATA[<p><code>notify()</code>和<code>notifyAll()</code>都是<code>Object</code>对象用于通知等待该对象的线程的方法。</p>
<p><code>notifyAll</code>使所有原来在该对象上等待的线程统统退出<code>wait</code>的状态，变成等待该对象上的锁，一旦该对象被解锁，它们就会去竞争。<br>notify则只是选择一个<code>wait</code>状态线程进行通知，并使它获得该对象上的锁，但不惊动其他同样在等待被该对象<code>notify</code>的线程们，当第一个线程运行完毕以后释放对象上的锁此时如果该对象没有再次使用<code>notify</code>语句，则即便该对象已经空闲，其他<code>wait</code>状态等待的线程由于没有得到该对象的通知，继续处在<code>wait</code>状态，直到这个对象发出一个<code>notify</code>或<code>notifyAll</code>，它们等待的是被<code>notify</code>或<code>notifyAll</code>，而不是锁。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">import java.util.ArrayList;</div><div class="line">import java.util.List;</div><div class="line">import java.util.concurrent.ExecutorService;</div><div class="line">import java.util.concurrent.Executors;</div><div class="line"></div><div class="line">class Cafe &#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class CafeFactory &#123;</div><div class="line">    List&lt;Cafe&gt; finishedCafe = new ArrayList&lt;Cafe&gt;();</div><div class="line"></div><div class="line">    public void addCafe() &#123;</div><div class="line">        try &#123;</div><div class="line">            while (true) &#123;</div><div class="line">                Thread.sleep(5000);// act busy</div><div class="line">                Cafe w = new Cafe();</div><div class="line">                // 也就是说需要5秒钟才能新产生一个Widget，这决定了一定要用notify而不是notifyAll</div><div class="line">                // 因为上面两行代码不是同步的，如果用notifyAll则所有线程都企图冲出wait状态</div><div class="line">                // 第一个线程得到了锁，并取走了Widget（这个过程的时间小于5秒，新的Widget还没有生成）</div><div class="line">                // 并且解开了锁，然后第二个线程获得锁(因为用了notifyAll其他线程不再等待notify语句</div><div class="line">                // ，而是等待finishedWidgets上的锁，一旦锁放开了，他们就会竞争运行)，运行</div><div class="line">                // finishedWidgets.remove(0)，但是由于finishedWidgets现在还是空的，</div><div class="line">                // 于是产生异常</div><div class="line">                // ***********这就是为什么下面的那一句不能用notifyAll而是要用notify</div><div class="line"></div><div class="line">                synchronized (finishedCafe) &#123;</div><div class="line">                    System.out.println(Thread.currentThread() + &quot; Adding cafe:&quot; + w);</div><div class="line">                    finishedCafe.add(w);</div><div class="line">                    finishedCafe.notify(); // 这里只能是notify而不能是notifyAll</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (InterruptedException e) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public Cafe getCafe() &#123;</div><div class="line">        synchronized (finishedCafe) &#123;</div><div class="line">            if (finishedCafe.size() == 0) &#123;</div><div class="line">                try &#123;</div><div class="line">                    finishedCafe.wait();</div><div class="line">                &#125; catch (InterruptedException e) &#123;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            Cafe c = finishedCafe.remove(0);</div><div class="line">            System.out.println(Thread.currentThread() + &quot;Getting cafe:&quot; + c);</div><div class="line">            return c;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class AddingCafeTask implements Runnable &#123;</div><div class="line">    private CafeFactory cafeFactory;</div><div class="line"></div><div class="line">    public AddingCafeTask(CafeFactory cafeFactory) &#123;</div><div class="line">        this.cafeFactory = cafeFactory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        cafeFactory.addCafe();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">class GetingCafeTask implements Runnable &#123;</div><div class="line">    private CafeFactory cafeFactory;</div><div class="line"></div><div class="line">    public GetingCafeTask(CafeFactory cafeFactory) &#123;</div><div class="line">        this.cafeFactory = cafeFactory;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void run() &#123;</div><div class="line">        cafeFactory.getCafe();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">public class CafeTest extends Thread &#123;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        CafeFactory cafeFactory = new CafeFactory();</div><div class="line"></div><div class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</div><div class="line"></div><div class="line">        executorService.execute(new GetingCafeTask(cafeFactory));</div><div class="line">        executorService.execute(new GetingCafeTask(cafeFactory));</div><div class="line">        executorService.execute(new GetingCafeTask(cafeFactory));</div><div class="line"></div><div class="line">        executorService.execute(new AddingCafeTask(cafeFactory));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      用实例揭示notify()和notifyAll()的本质区别
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java8 lambda学习笔记之编译与运行过程</title>
    <link href="http://jishusuishouji.github.io/2017/05/11/java/java8_lambda%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E7%BC%96%E8%AF%91%E4%B8%8E%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <id>http://jishusuishouji.github.io/2017/05/11/java/java8_lambda学习笔记之编译与运行过程/</id>
    <published>2017-05-10T16:08:57.000Z</published>
    <updated>2017-05-10T16:08:57.227Z</updated>
    
    <summary type="html">
    
      java8 lambda学习笔记之编译与运行过程
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>一个Java类被JVM虚拟机加载的详细流程</title>
    <link href="http://jishusuishouji.github.io/2017/05/10/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.md/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://jishusuishouji.github.io/2017/05/10/Java的类加载机制.md/Java的类加载机制/</id>
    <published>2017-05-09T16:52:35.000Z</published>
    <updated>2017-05-09T17:13:02.393Z</updated>
    
    <content type="html"><![CDATA[<p>类的生命周期：加载、验证、准备、解析、初始化、使用、卸载<br>类加载过程  ：加载、验证、准备、解析、初始化<br>              加载、验证、准备、初始化、解析</p>
<p>解析阶段可以在初始化之前或之后开始，在之后开始可以实现动态绑定。</p>
<h2 id="类加载过程五阶段的第一阶段——加载"><a href="#类加载过程五阶段的第一阶段——加载" class="headerlink" title="类加载过程五阶段的第一阶段——加载"></a>类加载过程五阶段的第一阶段——加载</h2><p>1、根据类的全限定名来加载类.class文件的字节流。<br>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p>
<p>3、在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</p>
<p>注意，这里第1条中的二进制字节流并不只是单纯地从Class文件中获取，比如它还可以从Jar包中获取、从网络中获取（最典型的应用便是Applet）、由其他文件生成（JSP应用）等。</p>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的 二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<p>说到加载，不得不提到类加载器，下面就具体讲述下类加载器。</p>
<p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类的加载阶段。对于任意一个类，都需要由它的类加载器和这个类本身一同确定其在就Java虚拟机中的唯一性，也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。</p>
<p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：</p>
<p>启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分。<br>所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。<br>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<p>启动类加载器：Bootstrap ClassLoader，跟上面相同。它负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.<em>开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。<br>扩展类加载器：Extension ClassLoader，该加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.</em>开头的类），开发者可以直接使用扩展类加载器。<br>应用程序类加载器：Application ClassLoader，该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。<br>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<p>1）在执行非置信代码之前，自动验证数字签名。</p>
<p>2）动态地创建符合用户特定需要的定制化构建类。</p>
<p>3）从特定的场所取得java class，例如数据库中和网络中。</p>
<p>事实上当使用Applet的时候，就用到了特定的ClassLoader，因为这时需要从网络上加载java class，并且要检查相关的安全信息，应用服务器也大都使用了自定义的ClassLoader技术。</p>
<p>这几种类加载器的层次关系如下图所示：</p>
<p>这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。</p>
<p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个很明显的好处，就是Java类随着它的类加载器（说白了，就是它所在的目录）一起具备了一种带有优先级的层次关系，这对于保证Java程序的稳定运作很重要。例如，类java.lang.Object类存放在JDK\jre\lib下的rt.jar之中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器进行加载，这边保证了Object类在程序中的各种类加载器中都是同一个类。</p>
<p>验证</p>
<p>验证的目的是为了确保Class文件中的字节流包含的信息符合当前虚拟机的要求，而且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。</p>
<p>文件格式的验证：验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理，该验证的主要目的是保证输入的字节流能正确地解析并存储于方法区之内。经过该阶段的验证后，字节流才会进入内存的方法区中进行存储，后面的三个验证都是基于方法区的存储结构进行的。<br>元数据验证：对类的元数据信息进行语义校验（其实就是对类中的各数据类型进行语法校验），保证不存在不符合Java语法规范的元数据信息。<br>字节码验证：该阶段验证的主要工作是进行数据流和控制流分析，对类的方法体进行校验分析，以保证被校验的类的方法在运行时不会做出危害虚拟机安全的行为。<br>符号引用验证：这是最后一个阶段的验证，它发生在虚拟机将符号引用转化为直接引用的时候（解析阶段中发生该转化，后面会有讲解），主要是对类自身以外的信息（常量池中的各种符号引用）进行匹配性的校验。<br>准备</p>
<p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p>
<p>1、这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</p>
<p>2、这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为：</p>
<p>public static int value = 3；</p>
<p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<clinit>（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</clinit></p>
<p>下表列出了Java中所有基本数据类型以及reference类型的默认零值：</p>
<p>这里还需要注意如下几点：</p>
<p>对基本数据类型来说，对于类变量（static）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。<br>对于同时被static和final修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被final修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。<br>对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即null。<br>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。<br>3、如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p>
<p>假设上面的类变量value被定义为：</p>
<p>public static final int value = 3；</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。回忆上一篇博文中对象被动引用的第2个例子，便是这种情况。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。</p>
<p>解析</p>
<p>   解析阶段是虚拟机将常量池中的符号引用转化为直接引用的过程。在Class类文件结构一文中已经比较过了符号引用和直接引用的区别和关联，这里不再赘述。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析（初始化之前），还是等到一个符号引用将要被使用前才去解析它（初始化之后）。<br>    对同一个符号引用进行多次解析请求时很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。<br>    解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info四种常量类型。<br>    1、类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。<br>    2、字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下图所示：</p>
<p>   从下面一段代码的执行结果中很容易看出来字段解析的搜索顺序：<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>class Super{<br>    public static int m = 11;<br>    static{<br>        System.out.println(“执行了super类静态语句块”);<br>    }<br>}</p>
<p>class Father extends Super{<br>    public static int m = 33;<br>    static{<br>        System.out.println(“执行了父类静态语句块”);<br>    }<br>}</p>
<p>class Child extends Father{<br>    static{<br>        System.out.println(“执行了子类静态语句块”);<br>    }<br>}</p>
<p>public class StaticTest{<br>    public static void main(String[] args){<br>        System.out.println(Child.m);<br>    }<br>}<br>执行结果如下：</p>
<pre><code>执行了super类静态语句块
执行了父类静态语句块
33
</code></pre><p>如果注释掉Father类中对m定义的那一行，则输出结果如下：<br>    执行了super类静态语句块<br>    11<br>   另外，很明显这就是上篇博文中的第1个例子的情况，这里我们便可以分析如下：static变量发生在静态解析阶段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由于在子类中没有查找到与m相匹配的字段，那么m便不会与子类关联在一起，因此并不会触发子类的初始化。<br>    最后需要注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译。如果对上面的代码做些修改，将Super改为接口，并将Child类继承Father类且实现Super接口，那么在编译时会报出如下错误：<br>StaticTest.java:24: 对 m 的引用不明确，Father 中的 变量 m 和 Super 中的 变量 m<br>都匹配<br>                System.out.println(Child.m);<br>                                        ^<br>1 错误<br>    3、类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。<br>    4、接口方法解析：与类方法解析步骤类似，知识接口不会有父类，因此，只递归向上搜索父接口就行了。<br>初始化</p>
<p>初始化是类加载过程的最后一步，到了此阶段，才真正开始执行类中定义的Java程序代码。在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。</clinit></p>
<p>   这里简单说明下<clinit>（）方法的执行规则:<br>    1、<clinit>（）方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。<br>    2、<clinit>（）方法与实例构造器<init>（）方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<clinit>（）方法执行之前，父类的<clinit>（）方法已经执行完毕。因此，在虚拟机中第一个被执行的<clinit>（）方法的类肯定是java.lang.Object。<br>    3、<clinit>（）方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<clinit>（）方法。<br>    4、接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成<clinit>（）方法。但是接口鱼类不同的是：执行接口的<clinit>（）方法不需要先执行父接口的<clinit>（）方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>（）方法。<br>    5、虚拟机会保证一个类的<clinit>（）方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>（）方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>（）方法完毕。如果在一个类的<clinit>（）方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。<br>    下面给出一个简单的例子，以便更清晰地说明如上规则：<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>class Father{<br>    public static int a = 1;<br>    static{<br>        a = 2;<br>    }<br>}</clinit></clinit></clinit></clinit></clinit></clinit></clinit></clinit></clinit></clinit></clinit></clinit></clinit></init></clinit></clinit></clinit></p>
<p>class Child extends Father{<br>    public static int b = a;<br>}</p>
<p>public class ClinitTest{<br>    public static void main(String[] args){<br>        System.out.println(Child.b);<br>    }<br>}<br>执行上面的代码，会打印出2，也就是说b的值被赋为了2。</p>
<pre><code>我们来看得到该结果的步骤。首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用&lt;clinit&gt;（）方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的&lt;clinit&gt;（）方法，根据规则2，在此之前，要先执行完其父类Father的&lt;clinit&gt;（）方法，又根据规则1，在执行&lt;clinit&gt;（）方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，因此当触发执行Father的&lt;clinit&gt;（）方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的&lt;clinit&gt;（）方法，这样便会将b的赋值为2.
如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。很明显是根据规则1，执行Father的&lt;clinit&gt;（）方法时，根据顺序先执行了static语句块中的内容，后执行了“public static int a = 1;”语句。
另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量），在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问。
</code></pre><p>总结</p>
<pre><code>整个类加载过程中，除了在加载阶段用户应用程序可以自定义类加载器参与之外，其余所有的动作完全由虚拟机主导和控制。到了初始化才开始执行类中定义的Java程序代码（亦及字节码），但这里的执行代码只是个开端，它仅限于&lt;clinit&gt;（）方法。类加载过程中主要是将Class文件（准确地讲，应该是类的二进制字节流）加载到虚拟机内存中，真正执行字节码的操作，在加载完成后才真正开始。
</code></pre>]]></content>
    
    <summary type="html">
    
      Java的类加载机制
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机：Java类加载机制</title>
    <link href="http://jishusuishouji.github.io/2017/05/09/java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://jishusuishouji.github.io/2017/05/09/java/Java虚拟机：Java类加载机制/</id>
    <published>2017-05-09T14:57:56.000Z</published>
    <updated>2017-05-09T16:03:43.800Z</updated>
    
    <content type="html"><![CDATA[<p>源代码(<code>.java</code>)会被编译为class文件(<code>.class</code>文件)，<code>.class</code>文件描述了类的各种信息，<code>.class</code>文件需要加载到虚拟机之后才能运行和使用。</p>
<h2 id="类加载使用的7个阶段"><a href="#类加载使用的7个阶段" class="headerlink" title="类加载使用的7个阶段"></a>类加载使用的7个阶段</h2><p>类从加载到虚拟机到到卸载出内存，整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initiallization）、使用（Using）和卸载（Unloading）这7个阶段。<br><img src="/img/类加载使用的7个阶段.png" alt="类加载使用的7个阶段"><br>其中验证、准备、解析这个三个阶段统称为连接（Linking）<br>加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，而解析阶段不一定：它在某些情况下可以初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定）。<br>加载、验证、准备、解析、初始化五个阶段组成了一个完整的类加载过程。<br>卸载属于GC的工作。</p>
<h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><h4 id="有两种时机会触发类加载："><a href="#有两种时机会触发类加载：" class="headerlink" title="有两种时机会触发类加载："></a>有两种时机会触发类加载：</h4><p>1、预加载。虚拟机启动时加载，加载的是<code>JAVA_HOME/lib/</code>下的<code>rt.jar</code>中的<code>.class</code>文件，由于<code>rt.jar</code>包中的类经常被使用，因此随着虚拟机启动一起被加载。</p>
<h5 id="验证rt-java包中的类是否在虚拟器启动的时候被加载"><a href="#验证rt-java包中的类是否在虚拟器启动的时候被加载" class="headerlink" title="验证rt.java包中的类是否在虚拟器启动的时候被加载"></a>验证<code>rt.java</code>包中的类是否在虚拟器启动的时候被加载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译运行该类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;javac Test.java</div><div class="line">&gt;java -XX:+TraceClassLoading Test</div><div class="line">[Opened C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.Object from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.io.Serializable from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.Comparable from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.CharSequence from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.String from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.reflect.AnnotatedElement from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.reflect.GenericDeclaration from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.reflect.Type from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.Class from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.Cloneable from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.ClassLoader from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>2、运行时加载。虚拟机在用到一个<code>.class</code>文件的时会先去内存中查看一下这个<code>.class</code>文件有没有被加载，如果没有就会按照类的全限定名来加载这个类。</p>
<h4 id="加载阶段做的事情"><a href="#加载阶段做的事情" class="headerlink" title="加载阶段做的事情"></a>加载阶段做的事情</h4><p>1、获取.class文件的二进制流<br>2、将<code>.class</code>文件中包含的类信息、静态变量、字节码、常量等内容放入方法区中<br>3、在内存中生成一个代表这个<code>.class</code>文件的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。一般这个Class是在堆里的，不过HotSpot虚拟机是放在方法区中的。</p>
<p>虚拟机规范对这三点并没有做详细的规定，因此虚拟机实现的灵活度是相当大的。<br>加载阶段对于开发者来说是可控性最强的一个阶段。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>连接阶段的第一步，主要是为了确保<code>.class</code>文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p><code>.class</code>文件不一定要从Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生<code>.class</code>文件。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p>
<h4 id="验证阶段主要包含以下几个工作："><a href="#验证阶段主要包含以下几个工作：" class="headerlink" title="验证阶段主要包含以下几个工作："></a>验证阶段主要包含以下几个工作：</h4><p>1、文件格式验证<br><code>.class</code>文件的第5~第8个字节表示的是该<code>.class</code>文件的主次版本号，验证的时候会对这4个字节做一个验证，高版本的JDK能向下兼容以前版本的<code>.class</code>文件，但不能运行以后的class文件，即使文件格式未发生任何变化，虚拟机也必须拒绝执行超过其版本号的<code>.class</code>文件。例如有一段java代码是JDK1.6编译的，那么JDK1.6、JDK1.7能运行编译出来<code>.class</code>文件，而JDK1.5、JDK1.4以及更低的JDK版本是无法运行这个<code>.class</code>文件的。如果运行，会抛出<code>java.lang.UnsupportedClassVersionError</code>。</p>
<p>2、元数据验证</p>
<p>3、字节码验证</p>
<p>4、符号引用验证</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置其初始值的阶段，这些变量所使用的内存都将在方法区中分配。<br>1、这时候进行内存分配的仅仅是类变量（被<code>static</code>修饰的变量），而不是实例变量，实例变量将会在对象实例化的时候随着对象一起分配在Java堆中<br>2、这个阶段赋初始值的变量指的是那些不被<code>final</code>修饰的<code>static</code>变量，比如<code>public static int value = 123;</code>，<code>value</code>在准备阶段过后是<code>0</code>而不是<code>123</code>，给<code>value</code>赋值为<code>123</code>的动作是在初始化阶段才进行的；而<code>public static final int value = 123;</code>,在准备阶段，虚拟机就会给<code>value</code>赋值为<code>123</code>。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载过程的最后一步，初始化阶段是真正执行类中定义的Java字节码的过程。初始化过程是一个执行类构造器<code>&lt;clinit&gt;()</code>方法的过程，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。初始化阶段做的事就是给<code>static</code>变量赋予用户指定的值以及执行静态代码块。</p>
<p>注意一下，虚拟机会保证类的初始化在多线程环境中被正确地加锁、同步，即如果多个线程同时去初始化一个类，那么只会有一个类去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都要阻塞等待，直至活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。因此如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个进程阻塞。不过其他线程虽然会阻塞，但是执行<code>&lt;clinit&gt;()</code>方法的那条线程退出<code>&lt;clinit&gt;()</code>方法后，其他线程不会再次进入<code>&lt;clinit&gt;()</code>方法了，因为同一个类加载器下，一个类只会初始化一次。实际应用中这种阻塞往往是比较隐蔽的，要小心。</p>
<p>Java虚拟机规范严格规定了有且只有5种场景必须立即对类进行初始化，这4种场景也称为对一个类进行主动引用：</p>
<p>1、使用<code>new</code>关键字实例化对象、读取或者设置一个类的静态字段（被<code>final</code>修饰的静态字段除外）、调用一个类的静态方法的时候<br>2、使用<code>java.lang.reflect</code>包中的方法对类进行反射调用的时候<br>3、初始化一个类，发现其父类还没有初始化过的时候<br>4、虚拟机启动的时候，虚拟机会先初始化用户指定的包含<code>main()</code>方法的那个类</p>
<p>除了上面4种场景外，所有引用类的方式都不会触发类的初始化，称为被动引用：</p>
<p>1、子类引用父类静态字段，不会导致子类初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class SuperClass &#123;</div><div class="line">    public static String value = &quot;value&quot;;</div><div class="line">    static &#123;</div><div class="line">        System.out.println(&quot;SuperClass init&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class SubClass extends SuperClass &#123;</div><div class="line">    static &#123;</div><div class="line">        System.out.println(&quot;SubClass init&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class TestMain &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(SubClass.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SuperClass init</div><div class="line">value</div></pre></td></tr></table></figure></p>
<p>2、通过数组定义引用类，不会触发此类的初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class TestMain &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        SuperClass[] scs = new SuperClass[10];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行之后没有任何输出</p>
<p>3、引用静态常量时，常量在编译阶段会存入类的常量池中，本质上并没有直接引用到定义常量的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Constant &#123;</div><div class="line">    public static final String CONSTANT = &quot;CONSTANT&quot;;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        System.out.println(&quot;Constant init&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class TestMain &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(Constant.CONSTANT);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CONSTANT</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      Java虚拟机：Java类加载机制
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>如何配置Policy文件进行Java安全策略的设置</title>
    <link href="http://jishusuishouji.github.io/2017/05/09/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEPolicy%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8CJava%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BE%E7%BD%AE.md/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEPolicy%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8CJava%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
    <id>http://jishusuishouji.github.io/2017/05/09/如何配置Policy文件进行Java安全策略的设置.md/如何配置Policy文件进行Java安全策略的设置/</id>
    <published>2017-05-08T19:08:09.000Z</published>
    <updated>2017-05-08T19:52:26.021Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言具有完善的安全框架，从编程语言、编译器、解释程序到Java虚拟机，都能确保Java系统不被恶意的代码或敌对的编译器暗中破坏，它们能够保证Java代码按预定的规则运作。但是如果需要逾越这些限制时，比如读写文件，监听和读写Socket，退出Java系统，就必须使用数字签名或安全策略文件（<code>*.Policy</code>）。 </p>
<p> 在企业内部网中，推荐使用安全策略文件来设置java程序权限。企业内部网中各台计算机的位置、用途和安全性明确，更适于使用安全策略文件来设置java的权限，软件的安装、设置、升级和迁移都非常的方便，并且还可以和数字签名配合使用，更重要的是可以细分每个java程序的权限，使用起来灵活方便。 </p>
<h2 id="Java中安全策略的概念"><a href="#Java中安全策略的概念" class="headerlink" title="Java中安全策略的概念"></a>Java中安全策略的概念</h2><p> Java安全策略详细说明了不同的代码所拥有的不同资源的许可，由一个<code>Policy</code>对象来表达。比如为了让applet（或者运行在<code>SecurityManager</code>下的应用程序）能够执行受保护的行为，例如读写文件，applet（或Java应用程序）必须获得那项操作的许可,安全策略文件可以配置这些许可。<br>在程序中可以通过调用<code>getPolicy</code>方法得到当前安装的<code>Policy</code>对象，也可以通过调用<code>setPolicy</code>方法改变。<code>Policy</code>对象评估整个策略，返回一个适当的<code>Permissions</code>对象，详细说明那些代码可以访问那些资源。 </p>
<p>策略文件可以储存在无格式的ASCII文件，或<code>Policy</code>类的二进制文件，或数据库中。本文仅讨论无格式的ASCII文件的形式。 </p>
<h2 id="Policy文件的格式"><a href="#Policy文件的格式" class="headerlink" title="Policy文件的格式"></a><code>Policy</code>文件的格式</h2><p>\jdk1.8.0_111\jre\lib\security\java.policy<br>\jdk1.8.0_111\jre\lib\security\java.security</p>
<h3 id="Policy文件的语法格式与说明"><a href="#Policy文件的语法格式与说明" class="headerlink" title="Policy文件的语法格式与说明"></a><code>Policy</code>文件的语法格式与说明</h3><p><code>Policy</code>文件实质上是一个记录列表，它可能含有一个“keystore”记录，以及含有零个或多个“<code>grant</code>”记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">keystore &quot;some_keystore_url&quot;, &quot;keystore_type&quot;;</div><div class="line"></div><div class="line">grant [SignedBy &quot;signer_names&quot;] [, CodeBase &quot;URL&quot;] &#123;</div><div class="line">    Permission permission_class_name [ &quot;target_name&quot; ] [, &quot;action&quot;] [, SignedBy &quot;signer_names&quot;];</div><div class="line">    Permission ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="keystore记录"><a href="#keystore记录" class="headerlink" title="keystore记录"></a><code>keystore</code>记录</h4><p><code>keystore</code>是一个私有密钥（private keys）数据库和相应的数字签名，例如X.509证书。Policy文件中可能只有一条keystore记录（也可能不含有该记录），它可以出现在文件中<code>grant</code>记录以外的任何地方。Policy配置文件中指定的keystores用于寻找grant记录中指定的、签名者的公共密钥（public keys），如果任何grant记录指定签名者（signer_names），那么，keystore记录必须出现在policy配置文件中。 </p>
<p>—- “some_keystore_url”是指keystore的URL位置，”keystore_type”是指keystore的类型。第二个选项是可选项，如果没有指定，该类型则假定由安全属性文件（java.security）中的”keystore.type”属性来确定。keystore类型定义了keystore信息的存储和数据格式，用于保护keystore中的私有密钥和keystore完整性的算法。Sun Microsystems支持的缺省类型为“JKS”。 </p>
<h4 id="grant记录"><a href="#grant记录" class="headerlink" title="grant记录"></a><code>grant</code>记录</h4><p>在`Policy文件中的每一个grant记录含有一个CodeSource（一个指定的代码）及其permission(许可)。 </p>
<p>Policy文件中的每一条grant记录遵循下面的格式，以保留字“grant”开头，表示一条新的记录的开始，“Permission”是另一个保留字，在记录中用来标记一个新的许可的开始。每一个grant记录授予一个指定的代码（CodeBase）一套许可（Permissions）。 </p>
<p><code>permission_class_name</code>必须是一个合格并存在的类名，例如<code>java.io.FilePermission</code>，不能使用缩写（例如<code>FilePermission</code>）。<br>target_name用来指定目标类的位置，action用于指定目标类拥有的权限。<br>target_name可以直接指定类名（可以是绝对或相对路径），目录名，也可以是下面的通配符： </p>
<p>directory/<em> 目录下的所有文件
</em>当前目录的所有文件<br>directory/-目录下的所有文件，包括子目录</p>
<ul>
<li>当前目录下的所有文件，包括子目录<br>《ALL FILES》文件系统中的所有文件<br>对于java.io.FilePermission，action可以是：<br>read, write, delete和execute。<br>对于java.net.SocketPermission，action可以是：<br>listen，accept，connect，read，write。</li>
</ul>
<p>—- 1.3 Policy文件中的属性扩展（Property Expansion）<br>—- 属性扩展与shell中使用的变量扩展类似，它的格式为： </p>
<p>“${some.property}”<br>实际使用的例子为：<br>permission java.io.FilePermission<br>“${user.home}”, “read”;<br>“${user.home}”的值为”d:\Project”，<br>因此，下面的语句和上面的语句是一样的：<br>permission java.io.FilePermission “<br>d:\Project “, “read”;</p>
<p>三. 实例<br>—- 当初始化Policy时，首先装载系统Policy，然后再增加用户Policy，如果两者都不存在，则使用缺省的Policy，即原始的沙箱模型。<br>—- 系统Policy文件的缺省位置为： </p>
<p>{java.home}/lib/security/java.policy (Solaris)<br>{java.home}\lib\security\java.policy (Windows)<br>用户Policy文件的缺省位置为：<br>{user.home}/.java.policy (Solaris)<br>{user.home}.java.policy (Windows)</p>
<p>—- 其实，在实际使用中，我们可能不会象上面介绍的那么复杂，特别是在不使用数字签名时。这时，我们完全可以借鉴JDK 1.2提供给我们的现成的\jdk1.2\jre\lib\security\java.policy文件，根据我们的需要作相应的修改，本文就针对不使用数字签名情况详细说明安全策略文件的用法。<br>—- 下面，是一个完整的在Windows 95/98/NT下使用的.java.policy文件。在文件中，分别使用注释的形式说明了每个“permission”记录的用途。 </p>
<p>// For LanServerTalk.java and LanClientTalk.java</p>
<p>grant {<br>//对系统和用户目录“读”的权限<br>permission java.util.PropertyPermission<br>“user.dir”, “read”;<br>permission java.util.PropertyPermission<br>“user.home”, “read”;<br>permission java.util.PropertyPermission<br>“java.home”, “read”;<br>permission java.util.PropertyPermission<br>“java.class.path”, “read”;<br>permission java.util.PropertyPermission<br>“user.name”, “read”; </p>
<p>//对线程和线程组的操作权限<br>permission java.lang.RuntimePermission<br>“modifyThread”;<br>permission java.lang.RuntimePermission<br>“modifyThreadGroup”;</p>
<p>//操作Socket端口的各种权限<br>permission java.net.SocketPermission<br>“-“, “listen”;<br>permission java.net.SocketPermission<br>“-“, “accept”;<br>permission java.net.SocketPermission<br>“-“, “connect”;<br>permission java.net.SocketPermission “-“, “read”;<br>permission java.net.SocketPermission “-“, “write”;</p>
<p>//读写文件的权限<br>permission java.io.FilePermission “-“, “read”;<br>permission java.io.FilePermission “-“, “write”;</p>
<p>//退出系统的权限，例如System.exit(0)<br>permission java.lang.RuntimePermission “exitVM”;<br>};</p>
<p>四. java.policy文件的使用<br>—- 对于windows 95/98/NT，使用.java.policy文件的方法主要有下面两种。<br>—- 1． 使用缺省目录 </p>
<p>—- 我们可以简单地将编辑好的.java.policy文件拷贝到windows 95/98/NT的HOME目录，这时，所有的applet(或Java应用程序)可能都拥有某些相同的权限，使用起来简单，但不灵活（例如：对于java.io.FilePermission ，其目标类的target_name必须使用绝对路径），如果不是在企业内部网中使用，还可能存在一定安全隐患。 </p>
<p>—- 2． 在命令行中指定 </p>
<p>—- 在命令行，如果我们希望传递一个Policy文件给appletviewer，还可以使用”-J-Djava.security.policy”参数来指定policy的位置： </p>
<p>appletviewer -J-Djava.security.<br>policy=pURL myApplet</p>
<p>—- pURL为Policy文件的位置。下面，是一个实际的例子，以当前目录的.java.policy文件所指定的安全策略运行当前目录的LanServerTalk.html（文件中装载并运行LanServerTalk.java）：<br>appletviewer -J-Djava.security.policy<br>=.java.policy LanServerTalk.html </p>
<p>—- 这种方法使用灵活，特别是作为一个软件包在企业内部网中发布时，安装、设置和迁移软件，基本无须修改Policy文件的内容，使用起来相当简单，而且，安全许可的范围控制较精细。</p>
<hr>
<p>缺省策略实现和策略文件语法<br>上次修改时间： 1998 年 10 月 30 日</p>
<p>Java 应用程序环境的策略（对不同来源的代码指定权限）由 Policy 对象来表示。更明确地说，就是由 Policy 类（包含在 java.security 包中）的实现抽象方法的 Policy 子类来表示。</p>
<p>Policy 对象所用策略信息的源位置由 Policy 实现决定。缺省 Policy 实现从静态策略配置文件获得自己的信息。本文档的其余部分叙述了缺省 Policy 实现及其所读取的策略文件中必须使用的语法。有关使用 Policy Tool 来创建策略文件（不必知道所需语法）的详细信息，请参阅《策略工具文档》 (for Solaris) (for Windows)。</p>
<p>以下是本文档其余部分的概要：</p>
<p>缺省 Policy 实现<br>缺省策略文件位置<br>更改 Policy 实现<br>策略文件语法<br>策略文件示例<br>策略文件中的属性扩展<br>相关文档</p>
<p>缺省 Policy 实现<br>在缺省 Policy 实现中，可在一个或多个策略配置文件中指定策略。配置文件的作用是指定特定代码源的代码所能获得的权限。</p>
<p>可利用简单的文本编辑器或 Policy Tool 实用程序来编写策略文件。</p>
<p>缺省情况下，系统上只有单个全系统策略文件和唯一的（可选）用户策略文件。</p>
<p>首次调用缺省 Policy 对象的 getPermissions 方法或在任何时候调用 Policy 对象 refresh 方法时，即对其进行初始化。初始化包括分析策略配置文件（请参阅策略文件语法）及组装 Policy 对象。</p>
<p>缺省策略文件位置<br>如前所述，系统在缺省情况下具有单个全系统策略文件和唯一的用户策略文件。</p>
<p>系统策略文件的缺省位置为：</p>
<p>java.home/lib/security/java.policy  (Solaris)<br>java.home\lib\security\java.policy  (Windows)<br>注意： java.home 指的是名为“java.home”的系统属性的值，它指定 JDK 的安装目录。</p>
<p>系统策略文件可用于授予全系统代码权限。与 JDK 一起安装的 java.policy 文件可向标准扩展 (Java standard extensions) 授予全部权限，允许任何用户在无特权要求的端口进行监听，同时允许任何代码读取某些对安全不敏感的“标准”属性（例如“os.name”和“file.separator”属性）。</p>
<p>用户策略文件的缺省位置为：</p>
<p>user.home/.java.policy  (Solaris)<br>user.home.java.policy  (Windows)<br>注意： user.home 指的是名为“user.home”的系统属性的值，它指定用户的主目录。在 Windows 系统中，假定用户名是 uName，“user.home”属性的缺省值为：</p>
<p>C:\Winnt\Profiles\uName（多用户 Windows NT 系统中）<br>C:\Windows\Profiles\uName（多用户 Windows 95 系统中）<br>C:\Windows（单用户 Windows 95 系统中）<br>初始化 Policy 时，将首先加载系统策略，然后在 Policy 中添加用户策略。如果两种策略均不存在，则采用内置策略。该内置策略与原始的沙箱策略相同。</p>
<p>策略文件的位置在安全属性文件中指定。安全属性文件的位置为：</p>
<p>java.home/lib/security/java.security  (Solaris)<br>java.home\lib\security\java.security  (Windows)<br>如上所述，java.home 指示 JDK 的安装目录。策略文件的位置被指定为其名称具有以下形式的属性的值：</p>
<p>policy.url.n<br>其中 n 为数字。应采用以下形式的语句行来指定每个属性值：</p>
<p>policy.url.n=URL<br>其中，URL 为 URL 规范。</p>
<p>例如，安全属性文件中将把缺省系统和用户策略文件定义为：</p>
<p>policy.url.1=file:${java.home}/lib/security/java.policy<br>policy.url.2=file:${user.home}/.java.policy<br>有关利用特殊语法（例如利用 ${java.home} 来指定 java.home 属性值）来指定属性值的详细信息，请参阅属性扩展。</p>
<p>实际上，用户可以指定多个 URL（包括“<a href="http://”形式的" target="_blank" rel="external">http://”形式的</a> URL）,从而加载所有指定的策略文件。也可注释掉或更改第二个 URL，从而禁止读取缺省用户策略文件。</p>
<p>该算法自 policy.url.1 开始，然后不断递增直到查不到 URL 为止。因此，如果有了 policy.url.1 和 policy.url.3，就不会读取 policy.url.3。</p>
<p>运行时指定其它策略文件</p>
<p>在执行应用程序时也可以指定附加的或不同的策略文件，方法是用“-Djava.security.policy”命令行参数来指定（该命令行参数设置 java.security.policy 属性值）。例如，如果使用</p>
<pre><code>java -Djava.security.manager -Djava.security.policy=someURL SomeApp
</code></pre><p>这里 someURL 是指定策略文件位置的 URL，则除了加载安全属性文件中指定的所有策略文件外，还会加载本方法所指定的策略文件。</p>
<p>注意：</p>
<p>URL 可以是任何标准 URL，也可以只是当前目录下策略文件的文件名，如下例所示：<br>    java -Djava.security.manager -Djava.security.policy=mypolicy WriteFile<br>“-Djava.security.manager”参数可确保缺省安全管理器已被安装，这样就容易对应用程序进行策略检查。如果应用程序 SomeApp 安装有安全管理器，则不需要该参数。<br>如果使用</p>
<pre><code>java -Djava.security.manager -Djava.security.policy==someURL SomeApp
</code></pre><p>（请注意双等号），就会仅使用指定的策略文件，而安全属性文件中指出的策略文件将被忽略。</p>
<p>如果要将策略文件传递给 appletviewer，就应使用参数“-J-Djava.security.policy”，如下所示：</p>
<pre><code>appletviewer -J-Djava.security.policy=someURL myApplet
</code></pre><p>请注意：如果将安全属性文件中的“policy.allowSystemProperty”属性设置为“false”，就会忽略“-Djava.security.policy”策略文件值（对于 java 和 appletviewer 命令）。缺省值为“true”。</p>
<p>更改 Policy 实现<br>可以用其它 policy 类来代替缺省 Policy 实现类，前提是前者属于抽象 Policy 类的子类并可实现 getPermissions 方法（及其它必要的方法）。</p>
<p>缺省 Policy 实现的更改可通过编辑安全属性文件来完成，其中安全属性文件指 JDK lib/security 目录中的 java.security 文件。</p>
<p>下面给出一种可在 java.security 中设置的属性类型的形式：</p>
<pre><code>policy.provider=PolicyClassName
</code></pre><p>PolicyClassName 必须指定所需 Policy 实现类的完整名称。该属性的缺省安全属性文件项如下所示：</p>
<pre><code>policy.provider=sun.security.provider.PolicyFile
</code></pre><p>要想自定义安全属性文件项，可通过更改属性值来指定另一个类，如下例所示：</p>
<p>   policy.provider=com.mycom.MyPolicy<br>策略文件语法<br>JDK 的策略配置文件可用于指定来自特定代码源的代码所能获得的权限（何种系统资源访问类型）。</p>
<p>为了使 applet（或在安全管理器下运行的应用程序）能够执行受保护的动作（例如读写文件），必须向 applet（或应用程序）授予进行该动作的权限。在缺省 Policy 实现中，必须由策略配置文件中的 grant 项授予该权限。有关详细信息，请参阅以下内容及 “Java 安全体系结构规范”（唯一的例外是：代码对位于与它自身同一 (URL) 位置并且对那一位置子目录下的文件总是自动拥有读权限，而无需授予明确的权限）。</p>
<p>策略配置文件主要包含授权项列表。其中可能包含“keystore”（密钥仓库）项及零个或多个“grant”（授权）项。</p>
<p>Keystore 项</p>
<p>keystore 是存放私钥及相关数字证书（例如验证对应的公钥的 X.509 证书链）的数据库。keytool 实用程序 (for Solaris) (for Windows) 用于创建和管理密钥仓库。策略配置文件中所指定的 keystore 用于查找在该文件的授权项中所指定的签名人公钥。如果某一授权项指定了签名人别名（请参阅以下内容），则在策略配置文件中必须含有 keystore 项。</p>
<p>目前，在策略文件中只能有一个 keystore 项（第一项后的其它 keystore 项将被忽略），且该项可位于文件授权项以外的任何位置。其语法如下所示：</p>
<pre><code>keystore &quot;some_keystore_url&quot;, &quot;keystore_type&quot;;
</code></pre><p>其中“some_keystore_url”指定密钥仓库的 URL 位置，而“keystore_type”指定密钥仓库的类型。</p>
<p>URL 是相对于策略文件位置而言。因此，如果在安全属性文件中按以下方式指定策略文件：</p>
<pre><code>policy.url.1=http://foo.bar.com/fum/some.policy
</code></pre><p>而且策略文件中含有以下项：</p>
<pre><code>keystore &quot;.keystore&quot;;
</code></pre><p>就会从下列位置加载密钥仓库：</p>
<pre><code>http://foo.bar.com/fum/.keystore
</code></pre><p>URL 也可以是绝对 URL。</p>
<p>keystore type 定义密钥仓库信息的存储和数据格式，同时也定义用于保护密钥仓库中私钥及密钥仓库自身完整性的算法。Sun Microsystems 所支持的缺省类型是名为“JKS”的专用密钥仓库类型。因此，如果密钥仓库类型属于“JKS”，就无需在 keystore 项中加以指定。</p>
<p>授权项</p>
<p>通常认为执行代码来自于某“代码源”（由 CodeSource 类型的对象表示）。代码源不仅包含代码的源位置 (URL)，而且还包括对包含与签写代码的私钥相对应的公钥的证书之引用。代码源中的证书通过用户密钥仓库中的符号别名引用。</p>
<p>每个授权项包括一个或多个“权限项”，前面为可选 codeBase 和 signedBy 名字/值对，用于指定要授予权限的代码。授权项的基本格式如下所示：</p>
<p>  grant signedBy “signer_names”, codeBase “URL” {<br>    permission permission_class_name “target_name”, “action”,<br>        signedBy “signer_names”;<br>    ….<br>    permission permission_class_name “target_name”, “action”,<br>        signedBy “signer_names”;<br>  };</p>
<p>以上所有非斜体的项必须按原样出现（尽管大小写无关紧要且部分为可选项，如下所示）。 斜体项代表变量值。</p>
<p>授权项必须以 grant 开头。</p>
<p>SignedBy 和 CodeBase 域</p>
<p>signedBy 和 codeBase 名字/值对为可选域，其间的顺序无关紧要。</p>
<p>signedBy 值表示存储在密钥仓库中的证书别名。该证书内的公钥用于验证代码上的数字签名；用户可以向由私钥（私钥对应于该别名所指定的 keystore 项中的公钥）签名的代码授予权限。</p>
<p>signedBy 的值可以是由逗号分隔的多个别名。 例如“Adam,Eve,Charles”，其含义为“Adam，Eve 和 Charles 签名”；它们之间的关系是 AND（与）而非 OR（或）。更确切地说，“Adam 签名的代码”语句的含义是“JAR 文件中有含类文件的代码，这个 JAR 文件已用密钥仓库中别名为 Adam 的项中与公钥所对应的私钥签名”。</p>
<p>signedBy 域可选，这是因为如果省略该域，则表示“任何签名人”。代码是否有签名或由谁签名都没有关系。</p>
<p>codeBase 值表示的是代码源位置；用户可向来自该位置的代码授权。空 codeBase 项表示“任何代码”；代码来源于何处没有关系。</p>
<p>注意： codeBase 值是 URL，因此应该始终用正斜杠（而不要用反斜杠）作为目录分隔符，即使代码源实际在 Windows 系统上。这样，如果 Windows 系统上代码的源位置实际上是 C:\somepath\api\，则 codeBase 策略项的外观将如下所示：</p>
<pre><code>grant codeBase &quot;file:/C:/somepath/api/&quot; {
  ...
}
</code></pre><p>codeBase</p>
<p>值的准确含义要取决于最后的字符。后面跟着“/”的 codeBase 将匹配指定目录下的所有类文件（非 JAR 文件）。后面跟着“/*”的 codeBase 将匹配该目录下的所有文件（类文件和 JAR 文件）。后面跟着“/-”的 codeBase 将匹配该目录下的所有文件（类文件和 JAR 文件）及该目录下子目录中的所有文件。下表说明了各种不同的情况。<br>下载代码的 Codebase URL  策略中的 Codebase URL   是否匹配?<br>java.sun.com/people/gong/   java.sun.com/people/gong<br>是</p>
<p>java.sun.com/people/gong/   java.sun.com/people/gong/<br>是</p>
<p>java.sun.com/people/gong/   java.sun.com/people/gong/*<br>是</p>
<p>java.sun.com/people/gong/   java.sun.com/people/gong/-<br>是</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/gong/<br>否</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/gong/-<br>是</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/gong/*<br>是</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/-<br>是</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/*<br>否</p>
<p>java.sun.com/people/gong/   java.sun.com/people/-<br>是</p>
<p>java.sun.com/people/gong/   java.sun.com/people/*<br>否</p>
<p>权限项</p>
<p>权限项必须以 permission 开头。上述模板中的字 permission_class_name 的实际值可以是特定的权限类型（例如 java.io.FilePermission 或 java.lang.RuntimePermission）。</p>
<p>“action” 对于许多权限类型而言都是必需的，例如 java.io.FilePermission（指定允许何种类型的文件访问权限）。 对于诸如 java.lang.RuntimePermission 等权限类型则为可选项：既可以在 permission_class_name 之后的 “target_name” 值中指定权限，也可以不指定权限。</p>
<p>权限项的 signedBy 名字/值对为可选项。如果有名字/值对，则表示为已签名权限。意即必须由给定的别名对权限类签名，方可授予权限。例如，假定有以下授权项：</p>
<p>  grant {<br>    permission Foo “foobar”, signedBy “FooSoft”;<br>  }<br>如果将 Foo.class 权限放到 JAR 文件中，且该 JAR 文件已由与 “FooSoft” 别名所指定的证书中的公钥相对应的私钥签名，或在 Foo.class 是系统类（因为系统类不受策略限制）的情况下，即可授予 Foo 权限类型。</p>
<p>权限项中出现的项目必须按指定顺序出现（permission，permission_class_name，”target_name”，”action” 和 signedBy “signer_names”）。分号表示项终止。</p>
<p>大小写对于标识符（permission、signedBy、codeBase 等）来说并不重要，但对于 permission_class_name 或作为值传递过来的字符串而言就很重要了。</p>
<p>有关 Windows 系统上文件路径规范的注意事项</p>
<p>请注意：在指定 java.io.FilePermission 时，”target_name” 是文件路径。在 Windows 系统上，无论何时在字符串中（而不是在 codeBase URL 中）直接指定文件路径，路径中都需要两个反斜杠来代表一个实际的反斜杠，如下例所示：</p>
<p>  grant {<br>      permission java.io.FilePermission “C:\users\cathy\foo.bat”, “read”;<br>  };<br>原因在于：字符串是由符号处理器 (java.io.StreamTokenizer) 来处理的。符号处理器允许将“\”用作转义字符串（例如，“\n”表示换行），因此需要用两个反斜杠来表示一个反斜杠。符号处理器处理完以上文件路径字符串后，将把双反斜杠转换成单个反斜杠，其最终结果为：</p>
<pre><code>&quot;C:\users\cathy\foo.bat&quot;
</code></pre><p>策略文件示例<br>策略配置文件中两项的示例如下所示：</p>
<p>  // 如果代码由 “Duke” 签字，则向 /tmp 中的所有文件<br>  // 授予读/写访问权限：</p>
<p>  grant signedBy “Duke” {<br>    permission java.io.FilePermission “/tmp/*”, “read,write”;<br>  };<br>// 授予所有用户以下权限：</p>
<p>grant { permission java.util.PropertyPermission “java.vendor”; };</p>
<p>另一个示例策略配置文件如下所示。</p>
<p>  grant signedBy “sysadmin”, codeBase “file:/home/sysadmin/<em>“ {<br>    permission java.security.SecurityPermission “Security.insertProvider.</em>“;<br>    permission java.security.SecurityPermission “Security.removeProvider.<em>“;<br>    permission java.security.SecurityPermission “Security.setProperty.</em>“;<br>  };<br>本示例规定：只有满足以下条件的代码才能调用 Security 类中的方法以添加或删除提供者或者设置 Security 属性：</p>
<p>代码将从位于本地文件系统上“/home/sysadmin/”目录下的签名 JAR 文件中加载。<br>可以用密钥仓库中别名“sysadmin”所引用的公钥来校验签名。<br>可以忽略代码源中两个组件的任何一个（或两者）。下面是忽略 codeBase 的示例：</p>
<p>  grant signedBy “sysadmin” {<br>    permission java.security.SecurityPermission “Security.insertProvider.<em>“;<br>    permission java.security.SecurityPermission “Security.removeProvider.</em>“;<br>  };<br>如果该策略生效，则来自 JAR 文件（由 “sysadmin” 签名）的代码可以添加/删除提供者，而不管 JAR 文件来源于何处。</p>
<p>下面是没有签名人的示例：</p>
<p>  grant codeBase “file:/home/sysadmin/-“ {<br>    permission java.security.SecurityPermission “Security.insertProvider.<em>“;<br>    permission java.security.SecurityPermission “Security.removeProvider.</em>“;<br>  };<br>这里，来自本地文件系统“/home/sysadmin/”目录下任意位置的代码都可以添加/删除提供者。 该代码不必签名。</p>
<p>下面是既不含 codeBase 也不含 signedBy 的示例：</p>
<p>  grant {<br>    permission java.security.SecurityPermission “Security.insertProvider.<em>“;<br>    permission java.security.SecurityPermission “Security.removeProvider.</em>“;<br>  };<br>此处，由于两个代码源组件均被忽略，因此任何代码（不管来自于何处，是否已签名或由何人签名）都可添加/删除提供者。</p>
<p>策略文件中的属性扩展<br>策略文件和安全属性文件中可以进行属性扩展。</p>
<p>属性扩展类似于扩展 shell 中的变量。也就是说，当类似</p>
<pre><code>${some.property}
</code></pre><p>的字符串出现在策略文件或安全属性文件中时，它将被扩展为系统属性的值。 例如，</p>
<pre><code>permission java.io.FilePermission &quot;${user.home}&quot;, &quot;read&quot;;
</code></pre><p>将把 “${user.home}” 扩展为使用 “user.home” 系统属性的值。如果该属性的值是 “/home/cathy”，则以上示例等价于：</p>
<pre><code>permission java.io.FilePermission &quot;/home/cathy&quot;, &quot;read&quot;;
</code></pre><p>为了能在与平台无关的策略文件中使用，也可采用特殊记号 “${/}”。该记号是 “${file.separator}” 的简化表示。这种方式允许使用下列字符串：</p>
<pre><code>permission java.io.FilePermission &quot;${user.home}${/}*&quot;, &quot;read&quot;;
</code></pre><p>如果 “user.home” 属性的值是 /home/cathy，而且是在 Solaris 系统上，则以上字符串将转换为：</p>
<pre><code>permission java.io.FilePermission &quot;/home/cathy/*&quot;, &quot;read&quot;;
</code></pre><p>如果 “user.home” 值是 C:\users\cathy，而且是在 Windows 系统上，则以上字符串将转换为：</p>
<pre><code>permission java.io.FilePermission &quot;C:\users\cathy\*&quot;, &quot;read&quot;;
</code></pre><p>同样，作为一种特例，如果扩展 codebase 中的属性，例如</p>
<pre><code>grant codeBase &quot;file:${java.home}/lib/ext/&quot;
</code></pre><p>则任何文件分隔符都将自动转换为“/”。这样，在 Windows 系统上，以上字符串将转换为：</p>
<pre><code>grant codeBase &quot;file:C:/jdk1.2/lib/ext/&quot;
</code></pre><p>即使 “java.home” 被设置为 C:\jdk1.2。因此，用户就不必也不应该在 codeBase 字符串中使用 ${/}。</p>
<p>策略文件中允许使用双引号字符串的地方都可进行属性扩展。其中包括 “signer_names”、”URL”、”target_name” 和 “action” 域。</p>
<p>是否允许属性扩展由安全属性文件中的“policy.expandProperties”属性控制。如果该属性为真（缺省值），则允许扩展。</p>
<p>请注意：不能使用嵌套属性；嵌套属性将无效。 例如，</p>
<pre><code>&quot;${user.${foo}}&quot;
</code></pre><p>是无效的，即使将“foo”属性设置为“home”。原因在于属性解析程序不能识别嵌套属性；解析程序只是简单地搜索第一个“${”，然后继续搜索直到找到第一个“}”为止，同时试图将搜索结果（这里是 “${user.$foo}”）解释为属性。如果没有这种属性，则解析程序就会发生解释失败。</p>
<p>也请注意：如果在 grant 项、permission 项或 keystore 项中无法扩展某个属性，则该项将被忽略。例如，如果在没有定义系统属性“foo”的情况下使用语句：</p>
<pre><code>grant codeBase &quot;${foo}&quot; {
  permission ...;
  permission ...;
};
</code></pre><p>则该 grant 项中的所有权限都将被忽略。如果使用语句：</p>
<pre><code>grant {
  permission Foo &quot;${foo}&quot;;
  permission Bar;
};
</code></pre><p>则将仅忽略“permission Foo…”项。最后，如果使用语句：</p>
<pre><code>keystore &quot;${foo}&quot;;
</code></pre><p>则将忽略 keystore 项。</p>
<p>Windows 系统、文件路径和属性的扩展</p>
<p>如上所述，在 Windows 系统上，当直接在字符串中（而不是在 codeBase URL 中）指定文件路径时，用户需要用两个反斜杠来代表文件路径中一个实际的反斜杠，如下例所示：</p>
<pre><code>grant {
    permission java.io.FilePermission &quot;C:\\users\\cathy\\foo.bat&quot;, &quot;read&quot;;
};
</code></pre><p>原因在于：字符串是由符号处理器 (java.io.StreamTokenizer) 来处理的。符号处理器允许将“\”用作转义字符串（例如，“\n”表示换行），因此需要用两个反斜杠来表示一个反斜杠。符号处理器处理完以上文件路径字符串后，将把双反斜杠转换成单个反斜杠，其最终结果为：</p>
<pre><code>&quot;C:\users\cathy\foo.bat&quot;
</code></pre><p>符号处理器处理完字符串后，即进行字符串中的属性扩展。因此，如果使用字符串：</p>
<pre><code>&quot;${user.home}\\foo.bat&quot;
</code></pre><p>则符号处理器首先处理字符串，即将双反斜杠转换成单个反斜杠，其结果为：</p>
<pre><code>&quot;${user.home}\foo.bat&quot;
</code></pre><p>随即扩展 ${user.home} 属性，其最终结果为：</p>
<pre><code>&quot;C:\users\cathy\foo.bat&quot;
</code></pre><p>以上假定 “user.home” 的值是 C:\users\cathy。当然，为实现与平台无关，最好在开始指定字符串时不要显式带上斜杠，即可以用 ${/} 属性来代替，如下例所示：</p>
<pre><code>&quot;${user.home}${/}foo.bat&quot;
</code></pre>]]></content>
    
    <summary type="html">
    
      如何配置Policy文件进行Java安全策略的设置
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java安全管理器SecurityManager</title>
    <link href="http://jishusuishouji.github.io/2017/05/09/java%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E5%99%A8SecurityManager.md/java%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E5%99%A8SecurityManager/"/>
    <id>http://jishusuishouji.github.io/2017/05/09/java安全管理器SecurityManager.md/java安全管理器SecurityManager/</id>
    <published>2017-05-08T16:33:39.000Z</published>
    <updated>2017-05-08T19:53:02.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><h3 id="阅读源码中关于SecurityManager的代码"><a href="#阅读源码中关于SecurityManager的代码" class="headerlink" title="阅读源码中关于SecurityManager的代码"></a>阅读源码中关于<code>SecurityManager</code>的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SecurityManager security = System.getSecurityManager();</div><div class="line">if (security != null) &#123;</div><div class="line">    security.checkWrite(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在本机运行正常，在服务器运行报错权限错误："><a href="#在本机运行正常，在服务器运行报错权限错误：" class="headerlink" title="在本机运行正常，在服务器运行报错权限错误："></a>在本机运行正常，在服务器运行报错权限错误：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.security.AccessControlException: access denied (java.lang.RuntimePermission createSecurityManager)</div><div class="line">    at java.security.AccessControlContext.checkPermission(AccessControlContext.java:374)</div><div class="line">    at java.security.AccessController.checkPermission(AccessController.java:549)</div><div class="line">    at java.lang.SecurityManager.checkPermission(SecurityManager.java:532)</div><div class="line">    at java.lang.SecurityManager.&lt;init&gt;(SecurityManager.java:282)</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>为了彻底明白这些情况，需要研究一下<code>SecurityManager</code>。</p>
<h2 id="SecurityManager应用场景"><a href="#SecurityManager应用场景" class="headerlink" title="SecurityManager应用场景"></a><code>SecurityManager</code>应用场景</h2><p>当运行未知的Java程序(可能有恶意代码（删除系统文件、重启系统等）)时，为了防止恶意代码对系统产生影响，需要对运行的代码的权限进行控制，这时就需要启用Java安全管理器。</p>
<h2 id="管理器配置文件"><a href="#管理器配置文件" class="headerlink" title="管理器配置文件"></a>管理器配置文件</h2><h3 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h3><p>默认的安全管理器配置文件位于<code>$JAVA_HOME/jre/lib/security/java.policy</code>，当未指定配置文件时，将会使用该默认配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// Standard extensions get all permissions by default</div><div class="line"></div><div class="line">grant codeBase &quot;file:$&#123;&#123;java.ext.dirs&#125;&#125;/*&quot; &#123;</div><div class="line">        permission java.security.AllPermission;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// default permissions granted to all domains</div><div class="line"></div><div class="line">grant &#123;</div><div class="line">        // Allows any thread to stop itself using the java.lang.Thread.stop()</div><div class="line">        // method that takes no argument.</div><div class="line">        // Note that this permission is granted by default only to remain</div><div class="line">        // backwards compatible.</div><div class="line">        // It is strongly recommended that you either remove this permission</div><div class="line">        // from this policy file or further restrict it to code sources</div><div class="line">        // that you specify, because Thread.stop() is potentially unsafe.</div><div class="line">        // See the API specification of java.lang.Thread.stop() for more</div><div class="line">        // information.</div><div class="line">        permission java.lang.RuntimePermission &quot;stopThread&quot;;</div><div class="line"></div><div class="line">        // allows anyone to listen on dynamic ports</div><div class="line">        permission java.net.SocketPermission &quot;localhost:0&quot;, &quot;listen&quot;;</div><div class="line"></div><div class="line">        // &quot;standard&quot; properies that can be read by anyone</div><div class="line"></div><div class="line">        permission java.util.PropertyPermission &quot;java.version&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vendor&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vendor.url&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.class.version&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;os.name&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;os.version&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;os.arch&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;file.separator&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;path.separator&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;line.separator&quot;, &quot;read&quot;;</div><div class="line"></div><div class="line">        permission java.util.PropertyPermission &quot;java.specification.version&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.specification.vendor&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.specification.name&quot;, &quot;read&quot;;</div><div class="line"></div><div class="line">        permission java.util.PropertyPermission &quot;java.vm.specification.version&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vm.specification.vendor&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vm.specification.name&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vm.version&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vm.vendor&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vm.name&quot;, &quot;read&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="启用安全管理器"><a href="#启用安全管理器" class="headerlink" title="启用安全管理器"></a>启用安全管理器</h2><p>　　<br>有两种方式，建议采用参数启用方式。</p>
<h3 id="参数启用方式"><a href="#参数启用方式" class="headerlink" title="参数启用方式"></a>参数启用方式</h3><p>运行程序的时候附加参数启用安全管理器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Djava.security.manager</div></pre></td></tr></table></figure></p>
<p>指定配置文件的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Djava.security.manager -Djava.security.policy=&quot;E:/java.policy&quot;</div></pre></td></tr></table></figure></p>
<h3 id="编码方式启用"><a href="#编码方式启用" class="headerlink" title="编码方式启用"></a>编码方式启用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.setSecurityManager(new SecurityManager());</div></pre></td></tr></table></figure>
<p>参数启用本质上也是通过编码启用，不过参数启用灵活（<code>sun.misc.Launcher</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">String str = System.getProperty(&quot;java.security.manager&quot;);</div><div class="line">if (str != null)</div><div class="line">&#123;</div><div class="line">  SecurityManager localSecurityManager = null;</div><div class="line">  if ((&quot;&quot;.equals(str)) || (&quot;default&quot;.equals(str))) &#123;</div><div class="line">    localSecurityManager = new SecurityManager();</div><div class="line">  &#125; else &#123;</div><div class="line">    try</div><div class="line">    &#123;</div><div class="line">      localSecurityManager = (SecurityManager)this.loader.loadClass(str).newInstance();</div><div class="line">    &#125;</div><div class="line">    catch (IllegalAccessException localIllegalAccessException) &#123;&#125;catch (InstantiationException localInstantiationException) &#123;&#125;catch (ClassNotFoundException localClassNotFoundException) &#123;&#125;catch (ClassCastException localClassCastException) &#123;&#125;</div><div class="line">  &#125;</div><div class="line">  if (localSecurityManager != null) &#123;</div><div class="line">    System.setSecurityManager(localSecurityManager);</div><div class="line">  &#125; else &#123;</div><div class="line">    throw new InternalError(&quot;Could not create SecurityManager: &quot; + str);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会创建一个默认的<code>SecurityManager</code></p>
<h2 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h2><h3 id="配置基本原则"><a href="#配置基本原则" class="headerlink" title="配置基本原则"></a>配置基本原则</h3><p>在启用安全管理器的时候，配置遵循以下基本原则：</p>
<ul>
<li>没有配置的权限表示没有</li>
<li>只能配置有什么权限，不能配置禁止做什么</li>
<li>同一种权限可多次配置，取并集。</li>
<li>统一资源的多种权限可用逗号分割。</li>
</ul>
<h3 id="默认配置文件解释"><a href="#默认配置文件解释" class="headerlink" title="默认配置文件解释"></a>默认配置文件解释</h3><h4 id="第一部分授权："><a href="#第一部分授权：" class="headerlink" title="第一部分授权："></a>第一部分授权：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grant codeBase &quot;file:$&#123;&#123;java.ext.dirs&#125;&#125;/*&quot; &#123;</div><div class="line">    permission java.security.AllPermission;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>授权位于”<code>file:$/</code>*”下的class和jar包所有权限。</p>
<h4 id="第二部分授权："><a href="#第二部分授权：" class="headerlink" title="第二部分授权："></a>第二部分授权：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">grant &#123; </div><div class="line">    permission java.lang.RuntimePermission &quot;stopThread&quot;;</div><div class="line">    ……   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是细粒度的授权，对某些资源进行授权。<code>RuntimePermission</code>的可授权操作(<code>stopThread</code>仅仅是其中的一个)如下(可查看javadoc)：</p>
<table>
<thead>
<tr>
<th>权限目标名称</th>
<th style="text-align:center">权限所允许的操作</th>
<th style="text-align:right">允许此权限所带来的风险</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>createClassLoader</code></td>
<td style="text-align:center">创建类加载器</td>
<td style="text-align:right">授予该权限极其危险。能够实例化自己的类加载器的恶意应用程序可能会在系统中装载自己的恶意类。这些新加载的类可能被类加载器置于任意保护域中，从而自动将该域的权限授予这些类。</td>
</tr>
<tr>
<td><code>getClassLoader</code></td>
<td style="text-align:center">类加载器的获取（即调用类的类加载器）</td>
<td style="text-align:right">这将授予攻击者得到具体类的加载器的权限。这很危险，由于攻击者能够访问类的类加载器，所以攻击者能够加载其他可用于该类加载器的类。通常攻击者不具备这些类的访问权限。</td>
</tr>
<tr>
<td><code>setContextClassLoader</code></td>
<td style="text-align:center">线程使用的上下文类加载器的设置</td>
<td style="text-align:right">在需要查找可能不存在于系统类加载器中的资源时，系统代码和扩展部分会使用上下文类加载器。授予 <code>setContextClassLoader</code> 权限将允许代码改变特定线程（包括系统线程）使用的上下文类加载器。</td>
</tr>
<tr>
<td><code>enableContextClassLoaderOverride</code></td>
<td style="text-align:center">线程上下文类加载器方法的子类实现</td>
<td style="text-align:right">在需要查找可能不存在于系统类加载器中的资源时，系统代码和扩展部分会使用上下文类加载器。授予<code>enableContextClassLoaderOverride</code>权限将允许线程的子类重写某些方法，这些方法用于得到或设置特定线程的上下文类加载器。</td>
</tr>
<tr>
<td><code>setSecurityManager</code></td>
<td style="text-align:center">设置安全管理器（可能会替换现有的）</td>
<td style="text-align:right">安全管理器是允许应用程序实现安全策略的类。授予<code>setSecurityManager</code>权限将通过安装一个不同的、可能限制更少的安全管理器，来允许代码改变所用的安全管理器，因此可跳过原有安全管理器所强制执行的某些检查。</td>
</tr>
<tr>
<td><code>createSecurityManager</code></td>
<td style="text-align:center">创建新的安全管理器</td>
<td style="text-align:right">授予代码对受保护的、敏感方法的访问权，可能会泄露有关其他类或执行堆栈的信息。</td>
</tr>
<tr>
<td><code>getenv.{variable name}</code></td>
<td style="text-align:center">读取指定环境变量的值</td>
<td style="text-align:right">此权限允许代码读取特定环境变量的值或确定它是否存在。如果该变量含有机密数据，则这项授权是很危险的。</td>
</tr>
<tr>
<td><code>exitVM.{exit status}</code></td>
<td style="text-align:center">暂停带有指定退出状态的Java虚拟机</td>
<td style="text-align:right">此权限允许攻击者通过自动强制暂停虚拟机来发起一次拒绝服务攻击。注意：自动为那些从应用程序类路径加载的全部代码授予 “<code>exitVM.*</code>“权限，从而使这些应用程序能够自行中止。此外，”<code>exitVM</code>“权限等于”exitVM.*”。</td>
</tr>
<tr>
<td><code>shutdownHooks</code></td>
<td style="text-align:center">虚拟机关闭钩子 (hook) 的注册与取消</td>
<td style="text-align:right">此权限允许攻击者注册一个妨碍虚拟机正常关闭的恶意关闭钩子 (hook)。</td>
</tr>
<tr>
<td><code>setFactory</code></td>
<td style="text-align:center">设置由<code>ServerSocket</code>或<code>Socket</code>使用的套接字工厂，或<code>URL</code>使用的流处理程序工厂</td>
<td style="text-align:right">此权限允许代码设置套接字、服务器套接字、流处理程序或 RMI套接字工厂的实际实现。攻击者可能设置错误的实现，从而破坏数据流。</td>
</tr>
<tr>
<td><code>setIO</code></td>
<td style="text-align:center"><code>System.out</code>、<code>System.in</code>和<code>System.err</code>的设置</td>
<td style="text-align:right">此权限允许改变标准系统流的值。攻击者可以改变<code>System.in</code>来监视和窃取用户输入，或将<code>System.err</code>设置为”<code>null</code>“ <code>OutputStream</code>，从而隐藏发送到<code>System.err</code>的所有错误信息。</td>
</tr>
<tr>
<td><code>modifyThread</code></td>
<td style="text-align:center">修改线程，例如通过调用线程的<code>interrupt</code>、<code>stop</code>、<code>suspend</code>、<code>resume</code>、<code>setDaemon</code>、<code>setPriority</code>、<code>setName</code>和<code>setUncaughtExceptionHandler</code>方法</td>
<td style="text-align:right">此权限允许攻击者修改系统中任意线程的行为。</td>
</tr>
<tr>
<td><code>stopThread</code></td>
<td style="text-align:center">通过调用线程的<code>stop</code>方法停止线程</td>
<td style="text-align:right">如果系统已授予代码访问该线程的权限，则此权限允许代码停止系统中的任何线程。此权限会造成一定的危险，因为该代码可能通过中止现有的线程来破坏系统。</td>
</tr>
<tr>
<td><code>modifyThreadGroup</code></td>
<td style="text-align:center">修改线程组，例如通过调用<code>ThreadGroup</code>的<code>destroy</code>、<code>getParent</code>、<code>resume</code>、<code>setDaemon</code>、<code>setMaxPriority</code>、<code>stop</code>和<code>suspend</code>方法</td>
<td style="text-align:right">此权限允许攻击者创建线程组并设置它们的运行优先级。</td>
</tr>
<tr>
<td><code>getProtectionDomain</code></td>
<td style="text-align:center">获取类的<code>ProtectionDomain</code></td>
<td style="text-align:right">此权限允许代码获得特定代码源的安全策略信息。虽然获得安全策略信息并不足以危及系统安全，但这确实会给攻击者提供了能够更好地定位攻击目标的其他信息，例如本地文件名称等。</td>
</tr>
<tr>
<td><code>getFileSystemAttributes</code></td>
<td style="text-align:center">获取文件系统属性</td>
<td style="text-align:right">此权限允许代码获得文件系统信息（如调用者可用的磁盘使用量或磁盘空间）。这存在潜在危险，因为它泄露了关于系统硬件配置的信息以及一些关于调用者写入文件特权的信息。</td>
</tr>
<tr>
<td><code>readFileDescriptor</code></td>
<td style="text-align:center">读取文件描述符</td>
<td style="text-align:right">此权限允许代码读取与文件描述符读取相关的特定文件。如果该文件包含机密数据，则此操作非常危险。</td>
</tr>
<tr>
<td><code>writeFileDescriptor</code></td>
<td style="text-align:center">写入文件描述符</td>
<td style="text-align:right">此权限允许代码写入与描述符相关的特定文件。此权限很危险，因为它可能允许恶意代码传播病毒，或者至少也会填满整个磁盘。</td>
</tr>
<tr>
<td><code>loadLibrary.{库名}</code></td>
<td style="text-align:center">动态链接指定的库</td>
<td style="text-align:right">允许applet具有加载本机代码库的权限是危险的，因为Java安全架构并未设计成可以防止恶意行为，并且也无法在本机代码的级别上防止恶意行为。</td>
</tr>
<tr>
<td><code>accessClassInPackage.{包名}</code></td>
<td style="text-align:center">当类加载器调用<code>SecurityManager</code>的<code>checkPackageAccess</code>方法时，通过类加载器的<code>loadClass</code>方法访问指定的包</td>
<td style="text-align:right">此权限允许代码访问它们通常无法访问的那些包中的类。恶意代码可能利用这些类帮助它们实现破坏系统安全的企图。</td>
</tr>
<tr>
<td><code>defineClassInPackage.{包名}</code></td>
<td style="text-align:center">当类加载器调用<code>SecurityManager</code>的<code>checkPackageDefinition</code>方法时，通过类加载器的<code>defineClass</code> 方法定义指定的包中的类。</td>
<td style="text-align:right">此权限允许代码在特定包中定义类。这样做很危险，因为具有此权限的恶意代码可能在受信任的包中定义恶意类，比如<code>java.security</code>或<code>java.lang</code>。</td>
</tr>
<tr>
<td><code>accessDeclaredMembers</code></td>
<td style="text-align:center">访问类的已声明成员</td>
<td style="text-align:right">此权限允许代码查询类的公共、受保护、默认（包）访问和私有的字段和或方法。尽管代码可以访问私有和受保护字段和方法名称，但它不能访问私有/受保护字段数据并且不能调用任何私有方法。此外，恶意代码可能使用该信息来更好地定位攻击目标。而且，它可以调用类中的任意公共方法和/或访问公共字段。如果代码不能用这些方法和字段将对象强制转换为类/接口，那么它通常无法调用这些方法和/或访问该字段，而这可能很危险。</td>
</tr>
<tr>
<td><code>queuePrintJob</code></td>
<td style="text-align:center">打印作业请求的开始</td>
<td style="text-align:right">这可能向打印机输出敏感信息，或者只是浪费纸张。</td>
</tr>
<tr>
<td><code>getStackTrace</code></td>
<td style="text-align:center">获取另一个线程的堆栈追踪信息。</td>
<td style="text-align:right">此权限允许获取另一个线程的堆栈追踪信息。此操作可能允许执行恶意代码监视线程并发现应用程序中的弱点。</td>
</tr>
<tr>
<td><code>setDefaultUncaughtExceptionHandler</code></td>
<td style="text-align:center">在线程由于未捕获的异常而突然终止时，设置将要使用的默认处理程序</td>
<td style="text-align:right">此权限允许攻击者注册恶意的未捕获异常处理程序，可能会妨碍线程的终止</td>
</tr>
<tr>
<td><code>Preferences</code></td>
<td style="text-align:center">表示得到<code>java.util.prefs.Preferences</code>的访问权所需的权限。<code>java.util.prefs.Preferences</code>实现了用户或系统的根，这反过来又允许获取或更新<code>Preferences</code> 持久内部存储中的操作。</td>
<td style="text-align:right">如果运行此代码的用户具有足够的读/写内部存储的OS特权，则此权限就允许用户读/写优先级内部存储。实际的内部存储可能位于传统的文件系统目录中或注册表中，这取决于平台 OS。</td>
</tr>
</tbody>
</table>
<h3 id="可配置项详解"><a href="#可配置项详解" class="headerlink" title="可配置项详解"></a>可配置项详解</h3><p>当批量配置的时候，有三种模式：</p>
<p><code>directory/</code> 表示<code>directory</code>目录下的所有<code>.class</code>文件，不包括<code>.jar</code>文件<br><code>directory/*</code> 表示<code>directory</code>目录下的所有的<code>.class</code>及<code>.jar</code>文件<br><code>directory/-`` 表示directory目录下的所有的</code>.class<code>及</code>.jar`文件，包括子目录</p>
<p>可以通过<code>${}</code>来引用系统属性，如：</p>
<p><code>&quot;file:$/*&quot;</code></p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>　　</p>
<h3 id="取消安全管理器"><a href="#取消安全管理器" class="headerlink" title="取消安全管理器"></a>取消安全管理器</h3><p>　　</p>
<h3 id="增加相应权限"><a href="#增加相应权限" class="headerlink" title="增加相应权限"></a>增加相应权限</h3><p>如果没有某项权限则报错信息会提示是请求什么权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.security.AccessControlException: access denied (java.io.FilePermission c:\test.txt write)</div></pre></td></tr></table></figure>
<p>对<code>c:\test.txt</code>没有写权限。</p>
<p>最简单的事开放所有权限（不推荐）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grant &#123; </div><div class="line">    permission java.security.AllPermission;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      java安全管理器SecurityManager
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编写java的安全管理器</title>
    <link href="http://jishusuishouji.github.io/2017/05/09/java%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6.md/java%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://jishusuishouji.github.io/2017/05/09/java的安全机制.md/java的安全机制/</id>
    <published>2017-05-08T16:04:27.000Z</published>
    <updated>2017-05-08T19:52:17.964Z</updated>
    
    <content type="html"><![CDATA[<p>安全管理器<code>SecurityManager</code>核心方法<code>checkPerssiom</code>,而该方法又调用<code>AccessController</code>的<code>checkPerssiom</code>方法，访问控制器<code>AccessController</code>的栈检查机制会遍历整个<code>PerssiomCollection</code>来判断具体拥有什么权限,一旦发现栈中一个权限不允许会抛出异常，否则简单的返回。</p>
<h2 id="编写java的安全管理器"><a href="#编写java的安全管理器" class="headerlink" title="编写java的安全管理器"></a>编写java的安全管理器</h2><h3 id="定义一个类继承自SecurityManger并重写checkRead方法"><a href="#定义一个类继承自SecurityManger并重写checkRead方法" class="headerlink" title="定义一个类继承自SecurityManger并重写checkRead方法"></a>定义一个类继承自<code>SecurityManger</code>并重写<code>checkRead</code>方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package com.test.security.manager;</div><div class="line"></div><div class="line">public class MySecurityManager extends SecurityManager &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void checkRead(String fileFullPath) &#123;</div><div class="line">        // super.checkRead(fileFullPath);</div><div class="line">        if (fileFullPath.endsWith(&quot;test&quot;)) &#123;</div><div class="line">            throw new SecurityException(&quot;你没有读取的本文件的权限&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.test.security.manager;</div><div class="line"></div><div class="line">import java.io.FileInputStream;</div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">public class MySecurityManagerTest &#123;</div><div class="line">    @Test</div><div class="line">    public void testCheckReadString() &#123;</div><div class="line">        System.setSecurityManager(new MySecurityManager());</div><div class="line">        try &#123;</div><div class="line">            FileInputStream fis = new FileInputStream(&quot;test&quot;);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">java.lang.SecurityException: 你没有读取的本文件的权限</div><div class="line">    at com.test.security.manager.MySecurityManager.checkRead(MySecurityManager.java:9)</div><div class="line">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:127)</div><div class="line">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93)</div><div class="line">    at com.test.security.manager.MySecurityManagerTest.testCheckReadString(MySecurityManagerTest.java:13)</div><div class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</div><div class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">    at java.lang.reflect.Method.invoke(Method.java:498)</div><div class="line">    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</div><div class="line">    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</div><div class="line">    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</div><div class="line">    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</div><div class="line">    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)</div><div class="line">    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)</div><div class="line">    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)</div><div class="line">    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)</div><div class="line">    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)</div><div class="line">    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)</div><div class="line">    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)</div><div class="line">    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)</div><div class="line">    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)</div><div class="line">    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)</div><div class="line">    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)</div><div class="line">    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)</div><div class="line">    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)</div><div class="line">    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)</div><div class="line">    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)</div></pre></td></tr></table></figure>
<p><code>System.setSecurityManager(new MySecurityManager());</code>这是安装安全管理器的一种方法，也可以用<code>-Djava.security.manager</code>安装默认的安全管理器。</p>
<h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><p>进入<code>FileInputStream</code>的构造函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public FileInputStream(File file) throws FileNotFoundException &#123;</div><div class="line">    String name = (file != null ? file.getPath() : null);</div><div class="line">    SecurityManager security = System.getSecurityManager();</div><div class="line">    if (security != null) &#123;</div><div class="line">        security.checkRead(name);</div><div class="line">    &#125;</div><div class="line">    if (name == null) &#123;</div><div class="line">        throw new NullPointerException();</div><div class="line">    &#125;</div><div class="line">    if (file.isInvalid()) &#123;</div><div class="line">        throw new FileNotFoundException(&quot;Invalid file path&quot;);</div><div class="line">    &#125;</div><div class="line">    fd = new FileDescriptor();</div><div class="line">    fd.attach(this);</div><div class="line">    path = name;</div><div class="line">    open(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先会执行<code>SecurityManager security = System.getSecurityManager();</code>，然后再调用<code>security</code>的<code>checkRead</code>方法。</p>
<p>联想一下，在使用java的<code>File</code>时会<code>new File(&quot;test&quot;).setWritable(Boolean.TRUE, Boolean.TRUE);</code>，这可以指定创建文件的权限，这里就是使用了安全管理器来设置权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public boolean setWritable(boolean writable, boolean ownerOnly) &#123;</div><div class="line">    SecurityManager security = System.getSecurityManager();</div><div class="line">    if (security != null) &#123;</div><div class="line">        security.checkWrite(path);</div><div class="line">    &#125;</div><div class="line">    if (isInvalid()) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return fs.setPermission(this, FileSystem.ACCESS_WRITE, writable, ownerOnly);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      编写java的安全管理器
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Reflections中的getDeclared**与get**的区别 </title>
    <link href="http://jishusuishouji.github.io/2017/05/02/Reflections%E4%B8%AD%E7%9A%84getDeclared-%E4%B8%8Eget-%E7%9A%84%E5%8C%BA%E5%88%AB.md/Reflections%E4%B8%AD%E7%9A%84getDeclared__%E4%B8%8Eget__%E7%9A%84%E5%8C%BA%E5%88%AB_/"/>
    <id>http://jishusuishouji.github.io/2017/05/02/Reflections中的getDeclared-与get-的区别.md/Reflections中的getDeclared__与get__的区别_/</id>
    <published>2017-05-02T11:16:18.000Z</published>
    <updated>2017-05-02T11:27:08.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="getDeclaredMethod-s"><a href="#getDeclaredMethod-s" class="headerlink" title="getDeclaredMethod(s)"></a><code>getDeclaredMethod(s)</code></h2><p>返回该类本身的所有方法(包括私有方法)，但不包括继承的方法。<br>返回数组中的元素没有排序，也没有任何特定的顺序。如果该类或接口不声明任何方法，或此<code>Class</code>对象表示一个基本类型、数组类型或<code>void</code>，则此方法返回一个长度为0的数组。</p>
<p>类初始化方法不包含在返回数组中。</p>
<p>该方法返回所有重载的方法。</p>
<h2 id="getMethod-s"><a href="#getMethod-s" class="headerlink" title="getMethod(s)"></a><code>getMethod(s)</code></h2><p>返回某个类的所有<code>public</code>(包括继承来<code>public</code>方法)。</p>
<p>如果此<code>Class</code>对象表示基本类型或<code>void</code>，则此方法返回长度为0的数组。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>getDeclaredMethods</code>：自身，所有方法，不继承<br><code>getMethods</code>:<code>public</code> 继承</p>
<h2 id="getDeclaredField（s）和getField（s）同上"><a href="#getDeclaredField（s）和getField（s）同上" class="headerlink" title="getDeclaredField（s）和getField（s）同上"></a><code>getDeclaredField（s）</code>和<code>getField（s）</code>同上</h2><h2 id="getDeclaredAnnotation（s）"><a href="#getDeclaredAnnotation（s）" class="headerlink" title="getDeclaredAnnotation（s）"></a><code>getDeclaredAnnotation（s）</code></h2><p>返回直接存在于此元素上的所有注释。该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。<br>getAnnotation（s）：返回此元素上存在的所有注释。（如果此元素没有注释，则返回长度为零的数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。<br>getDeclaredAnnotations得到的是当前成员所有的注释，不包括继承的。而getAnnotations得到的是包括继承的所有注释。</p>
<p>关键在于继承的问题上，getDeclaredAnnotations和getAnnotations是否相同，就在于父类的注解是否可继承，这可以用sun.reflect.annotation.AnnotationType antype3=AnnotationType.getInstance(Class.forName(annotationtype_class(example:”javax.ejb.Stateful”)).isInherited())来判定，如果为true，说明可以被继承则存在与getAnnotations之中而不在getDeclaredAnnotations之中，否则，也不存在与getannnotations中，因为不能被继承。</p>
]]></content>
    
    <summary type="html">
    
      Reflections中的getDeclared**与get**的区别 
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="反射" scheme="http://jishusuishouji.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Spring 资源访问剖析和策略模式应用</title>
    <link href="http://jishusuishouji.github.io/2017/04/24/spring/Spring_%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%89%96%E6%9E%90%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8/"/>
    <id>http://jishusuishouji.github.io/2017/04/24/spring/Spring_资源访问剖析和策略模式应用/</id>
    <published>2017-04-24T14:45:24.000Z</published>
    <updated>2017-04-24T14:45:40.704Z</updated>
    
    <summary type="html">
    
      Spring 资源访问剖析和策略模式应用
    
    </summary>
    
      <category term="spring" scheme="http://jishusuishouji.github.io/categories/spring/"/>
    
    
      <category term="spring" scheme="http://jishusuishouji.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>java 类型信息 instanceof 和 isInstance区别</title>
    <link href="http://jishusuishouji.github.io/2017/04/20/java/java_%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF_instanceof_%E5%92%8C_isInstance%E5%8C%BA%E5%88%AB/"/>
    <id>http://jishusuishouji.github.io/2017/04/20/java/java_类型信息_instanceof_和_isInstance区别/</id>
    <published>2017-04-19T21:26:32.000Z</published>
    <updated>2017-04-19T21:39:01.480Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class A&#123;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class B extends A &#123;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class C extends B &#123;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class T &#123;  </div><div class="line">  </div><div class="line">   </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        C c = new C();  </div><div class="line">        B b = new B();  </div><div class="line">        A a = new A();  </div><div class="line">          </div><div class="line">        B bc = new C();  </div><div class="line">        A ac = new C();  </div><div class="line">          </div><div class="line">        System.out.println(c instanceof C);  </div><div class="line">        System.out.println(c instanceof B);  </div><div class="line">        System.out.println(c instanceof A);  </div><div class="line">          </div><div class="line">        System.out.println();  </div><div class="line">          </div><div class="line">        System.out.println(c.getClass().isInstance(c));  </div><div class="line">        System.out.println(c.getClass().isInstance(b));  </div><div class="line">        System.out.println(c.getClass().isInstance(a));  </div><div class="line">          </div><div class="line">        System.out.println();  </div><div class="line">          </div><div class="line">        System.out.println(c.getClass().isInstance(bc));  </div><div class="line">        System.out.println(c.getClass().isInstance(ac));  </div><div class="line">          </div><div class="line">        System.out.println();  </div><div class="line">          </div><div class="line">        System.out.println(A.class.isInstance(a));  </div><div class="line">        System.out.println(A.class.isInstance(b));  </div><div class="line">        System.out.println(A.class.isInstance(c));  </div><div class="line">        System.out.println(A.class.isInstance(ac));  </div><div class="line">        System.out.println(A.class.isInstance(bc));  </div><div class="line">          </div><div class="line">        System.out.println();  </div><div class="line">          </div><div class="line">        System.out.println(B.class.isInstance(a));  </div><div class="line">        System.out.println(B.class.isInstance(b));  </div><div class="line">        System.out.println(B.class.isInstance(c));  </div><div class="line">        System.out.println(B.class.isInstance(ac));  </div><div class="line">        System.out.println(B.class.isInstance(bc));  </div><div class="line">          </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line"></div><div class="line"></div><div class="line">true</div><div class="line">false</div><div class="line">false</div><div class="line"></div><div class="line"></div><div class="line">true</div><div class="line">true</div><div class="line"></div><div class="line"></div><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line"></div><div class="line"></div><div class="line">false</div><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line">true</div></pre></td></tr></table></figure>
<h2 id="对象-instanceof-类"><a href="#对象-instanceof-类" class="headerlink" title="对象 instanceof 类"></a>对象 instanceof 类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj instanceof class</div></pre></td></tr></table></figure>
<p>如果<code>class obj1 = obj</code>成立的话，返回<code>true</code>，否则返回<code>false</code></p>
<h2 id="类-isInstance-对象"><a href="#类-isInstance-对象" class="headerlink" title="类.isInstance(对象)"></a><code>类.isInstance(对象)</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class.isInstance(obj)</div></pre></td></tr></table></figure>
<p>如果<code>class obj1 = obj</code>成立的话，返回<code>true</code>，否则返回<code>false</code></p>
<p><code>instanceof</code>运算符只被用于对象引用变量，检查左边的被测试对象是不是 右边类或接口的实例化。如果被测对象是<code>null</code>值，则测试结果总是<code>false</code>。<br>形象地：自身实例或子类实例 <code>instanceof</code> 自身类   返回<code>true</code><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String s=new String(&quot;javaisland&quot;);</div><div class="line">System.out.println(s instanceof String); //true</div></pre></td></tr></table></figure></p>
<p>Class类的isInstance(Object obj)方法，obj是被测试的对象，如果obj是调用这个方法的class或接口 的实例，则返回true。这个方法是instanceof运算符的动态等价。<br>形象地：自身类.class.isInstance(自身实例或子类实例)  返回true<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String s=new String(&quot;javaisland&quot;);</div><div class="line">System.out.println(String.class.isInstance(s)); //true</div></pre></td></tr></table></figure></p>
<p>Class类的isAssignableFrom(Class cls)方法，如果调用这个方法的class或接口与 参数cls表示的类或接口相同，或者是参数cls表示的类或接口的父类，则返回true。<br>形象地：自身类.class.isAssignableFrom(自身类或子类.class)  返回true<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(ArrayList.class.isAssignableFrom(Object.class));  //false</div><div class="line">System.out.println(Object.class.isAssignableFrom(ArrayList.class));  //true</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      java 类型信息 instanceof 和 isInstance区别
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>spring 后置处理器BeanFactoryPostProcessor和BeanPostProcessor的用法和区别</title>
    <link href="http://jishusuishouji.github.io/2017/04/18/spring/spring_%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8BeanFactoryPostProcessor%E5%92%8CBeanPostProcessor%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://jishusuishouji.github.io/2017/04/18/spring/spring_后置处理器BeanFactoryPostProcessor和BeanPostProcessor的用法和区别/</id>
    <published>2017-04-18T15:48:50.000Z</published>
    <updated>2017-04-18T15:57:25.586Z</updated>
    
    <content type="html"><![CDATA[<p>主要区别就是：<code>BeanFactoryPostProcessor</code>(BeanFactory的后置处理器)可以修改BEAN的配置信息而<code>BeanPostProcessor</code>(Bean的后置处理器)不能:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.springdemo.postProcessor;  </div><div class="line">  </div><div class="line">public class PostProcessorBean &#123;  </div><div class="line">    private String username;  </div><div class="line">      </div><div class="line">    private String password;  </div><div class="line">  </div><div class="line">    public String getPassword() &#123;  </div><div class="line">        return password;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    public void setPassword(String password) &#123;  </div><div class="line">        this.password = password;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    public String getUsername() &#123;  </div><div class="line">        return username;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    public void setUsername(String username) &#123;  </div><div class="line">        this.username = username;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MyBeanPostProcessor</code>类，实现了<code>BeanPostProcessor</code>接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">package com.springdemo.postProcessor;  </div><div class="line">  </div><div class="line">import org.springframework.beans.BeansException;  </div><div class="line">import org.springframework.beans.factory.config.BeanPostProcessor;  </div><div class="line">  </div><div class="line">import com.springdemo.form.LoginForm;  </div><div class="line">  </div><div class="line">public class MyBeanPostProcessor implements BeanPostProcessor &#123;  </div><div class="line">  </div><div class="line">      </div><div class="line">      </div><div class="line">    public Object postProcessAfterInitialization(Object bean, String beanName)  </div><div class="line">            throws BeansException &#123;  </div><div class="line">        //如果是PostProcessorBean则username信息  </div><div class="line">        if(bean instanceof PostProcessorBean)  </div><div class="line">        &#123;  </div><div class="line">            System.out.println(&quot;PostProcessorBean Bean initialized&quot;);  </div><div class="line">            PostProcessorBean pb = (PostProcessorBean)bean;  </div><div class="line">              </div><div class="line">            System.out.println(&quot;username:&quot;+pb.getUsername());  </div><div class="line">        &#125;  </div><div class="line">        return bean;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName)  </div><div class="line">            throws BeansException &#123;  </div><div class="line">         if(bean instanceof PostProcessorBean)  </div><div class="line">        &#123;  </div><div class="line">            System.out.println(&quot;PostProcessorBean Bean initializing&quot;);  </div><div class="line">            PostProcessorBean pb = (PostProcessorBean)bean;  </div><div class="line">              </div><div class="line">            System.out.println(&quot;username:&quot;+pb.getUsername());  </div><div class="line">        &#125;  </div><div class="line">        return bean;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MyBeanFactoryPostProcessor</code>实现了<code>BeanFactoryPostProcessor</code>接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package com.springdemo.postProcessor;  </div><div class="line">  </div><div class="line">import org.springframework.beans.BeansException;  </div><div class="line">import org.springframework.beans.MutablePropertyValues;  </div><div class="line">import org.springframework.beans.factory.config.BeanDefinition;  </div><div class="line">import org.springframework.beans.factory.config.BeanFactoryPostProcessor;  </div><div class="line">import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;  </div><div class="line">  </div><div class="line">public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;  </div><div class="line">  </div><div class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)  </div><div class="line">            throws BeansException &#123;  </div><div class="line">        </div><div class="line">        //BeanFactoryPostProcessor可以修改BEAN的配置信息而BeanPostProcessor不能  </div><div class="line">        //在这里修改postProcessorBean的username注入属性  </div><div class="line">        BeanDefinition bd = beanFactory.getBeanDefinition(&quot;postProcessorBean&quot;);  </div><div class="line">        MutablePropertyValues pv =  bd.getPropertyValues();  </div><div class="line">        if(pv.contains(&quot;username&quot;))  </div><div class="line">        &#123;  </div><div class="line">            pv.addPropertyValue(&quot;username&quot;, &quot;xiaojun&quot;);  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编写测试用例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">package com.springdemo.test;  </div><div class="line">  </div><div class="line">  </div><div class="line">import org.springframework.context.ApplicationContext;  </div><div class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;  </div><div class="line">  </div><div class="line">import com.springdemo.factory.ApplicationContextFactory;  </div><div class="line">  </div><div class="line">import com.springdemo.postProcessor.PostProcessorBean;  </div><div class="line">  </div><div class="line">import junit.framework.TestCase;  </div><div class="line">  </div><div class="line">public class BeanPostPorcessorTest extends TestCase &#123;  </div><div class="line">    private ApplicationContext context;  </div><div class="line">    protected void setUp() throws Exception &#123;  </div><div class="line">        super.setUp();  </div><div class="line">        String[] paths = &#123;&quot;classpath*:/spring/applicationContext-*.xml&quot;&#125;;  </div><div class="line">  </div><div class="line">        context = new ClassPathXmlApplicationContext(paths);  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    protected void tearDown() throws Exception &#123;  </div><div class="line">        super.tearDown();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public void testBeanPostProcessor()  </div><div class="line">    &#123;  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">    public void testBeanFactoryPostProcessor()  </div><div class="line">    &#123;  </div><div class="line">        PostProcessorBean bean =(PostProcessorBean)context.getBean(&quot;postProcessorBean&quot;);  </div><div class="line">        System.out.println(&quot;---------------testBeanFactoryPostProcessor----------------&quot;);  </div><div class="line">        System.out.println(&quot;username:&quot;+bean.getUsername());  </div><div class="line">        System.out.println(&quot;password:&quot;+bean.getPassword());    </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>spring配置文件如下（先不启用<code>MyBeanFactoryPostProcessor</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  </div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  </div><div class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd&quot;&gt;  </div><div class="line">      </div><div class="line">    &lt;bean class=&quot;com.springdemo.postProcessor.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt;  </div><div class="line">    &lt;!--我们先把BeanFactoryPostProcessor注释掉，不启用,然后查看测试输出结果    </div><div class="line">    &lt;bean class=&quot;com.springdemo.postProcessor.MyBeanFactoryPostProcessor&quot;&gt;&lt;/bean&gt;  </div><div class="line">    --&gt;  </div><div class="line">    &lt;bean id=&quot;postProcessorBean&quot; class=&quot;com.springdemo.postProcessor.PostProcessorBean&quot; &gt;  </div><div class="line">        &lt;property name=&quot;username&quot; value=&quot;test&quot;&gt;&lt;/property&gt;  </div><div class="line">        &lt;property name=&quot;password&quot; value=&quot;test&quot;&gt;&lt;/property&gt;  </div><div class="line">    &lt;/bean&gt;  </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>测试输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PostProcessorBean Bean initializing</div><div class="line">username:test</div><div class="line">PostProcessorBean Bean initialized</div><div class="line">username:test</div><div class="line">---------------testBeanFactoryPostProcessor----------------</div><div class="line">username:test</div><div class="line">password:test</div></pre></td></tr></table></figure></p>
<p>然后我们取消注释启用<code>MyBeanFactoryPostProcessor</code>，测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PostProcessorBean Bean initializing</div><div class="line">username:xiaojun</div><div class="line">PostProcessorBean Bean initialized</div><div class="line">username:xiaojun</div><div class="line">---------------testBeanFactoryPostProcessor----------------</div><div class="line">username:xiaojun</div><div class="line">password:test</div></pre></td></tr></table></figure></p>
<p>从结果可以看出：<code>BeanFactoryPostProcessor</code>的回调比<code>BeanPostProcessor</code>要早，因为<code>BeanPostProcess</code>中输出的<code>username</code>已经变成了<code>xiaojun</code>,而不是<code>test</code>.还有就是<code>BeanFactoryPostProcessor</code>确实有能力改变初始化BEAN的内容.</p>
<p><code>BeanPostProcessor</code>也能改变bean的值。但值得奇怪的是，如果在<code>BeanFactoryPostProcessor</code>里面调用<code>factory.getBean()</code>，则会对bean进行初始化，但是这个初始化过程不会回调<code>BeanPostProcessor</code>的两个回调方法。</p>
]]></content>
    
    <summary type="html">
    
      spring 后置处理器BeanFactoryPostProcessor和BeanPostProcessor的用法和区别
    
    </summary>
    
      <category term="spring" scheme="http://jishusuishouji.github.io/categories/spring/"/>
    
    
      <category term="spring" scheme="http://jishusuishouji.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring必学的Java基础知识----PropertyEditor</title>
    <link href="http://jishusuishouji.github.io/2017/04/18/spring/%E5%AD%A6%E4%B9%A0Spring%E5%BF%85%E5%AD%A6%E7%9A%84Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86----PropertyEditor/"/>
    <id>http://jishusuishouji.github.io/2017/04/18/spring/学习Spring必学的Java基础知识----PropertyEditor/</id>
    <published>2017-04-18T15:41:21.000Z</published>
    <updated>2017-04-18T15:47:58.746Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring配置文件里是通过字面值为Bean各种类型的属性提供设置值：不管是double类型还是int类型，在配置文件中都对应字符串类型的字面值。<br><code>BeanWrapper</code>填充Bean属性时如何将这个字面值转换为对应的<code>double</code>或<code>int</code>等内部类型呢？</p>
<p>任何实现<code>java.beans.PropertyEditor</code>接口的类都是属性编辑器。属性编辑器是将外部的设置值转换为JVM内部的对应类型，属性编辑器就是一个类型转换器。 </p>
<p><code>PropertyEditor</code>是JavaBean规范定义的接口。 </p>
<h2 id="JavaBean的编辑器"><a href="#JavaBean的编辑器" class="headerlink" title="JavaBean的编辑器"></a>JavaBean的编辑器</h2><p>Sun所制定的JavaBean规范，很大程度上是为IDE准备的——它让IDE能够以可视化的方式设置JavaBean的属性。如果在IDE中开发一个可视化应用程序，我们需要通过属性设置的方式对组成应用的各种组件进行定制，IDE通过属性编辑器让开发人员使用可视化的方式设置组件的属性。 </p>
<p>一般的IDE都支持JavaBean规范所定义的属性编辑器，当组件开发商发布一个组件时，它往往将组件对应的属性编辑器捆绑发行，这样开发者就可以在IDE环境下方便地利用属性编辑器对组件进行定制工作。 </p>
<p>JavaBean规范通过<code>java.beans.PropertyEditor</code>定义了设置JavaBean属性的方法，通过<code>BeanInfo</code>描述了JavaBean哪些属性是可定制的，此外还描述了可定制属性与<code>PropertyEditor</code>的对应关系。 </p>
<p>BeanInfo与JavaBean之间的对应关系，通过两者之间规范的命名确立：对应JavaBean的BeanInfo采用如下的命名规范：<bean>BeanInfo。如<code>ChartBean</code>对应的<code>BeanInfo</code>为<code>ChartBeanBeanInfo</code>；<code>Car</code>对应的<code>BeanInfo</code>为<code>CarBeanInfo</code>。当JavaBean连同其属性编辑器相同的组件注册到IDE中后，当在开发界面中对JavaBean进行定制时，IDE就会根据JavaBean规范找到对应的BeanInfo，再根据BeanInfo中的描述信息找到JavaBean属性描述（是否开放、使用哪个属性编辑器），进而为JavaBean生成特定开发编辑界面。 </bean></p>
<p>JavaBean规范提供了一个管理默认属性编辑器的管理器：<code>PropertyEditorManager</code>，该管理器内保存着一些常见类型的属性编辑器，如果某个JavaBean的常见类型属性没有通过BeanInfo显式指定属性编辑器，IDE将自动使用PropertyEditorManager中注册的对应默认属性编辑器。 </p>
<p>由于JavaBean对应的属性编辑器等IDE环境相关的资源和组件需要动态加载，所以在纯Java的IDE中开发基于组件的应用时，总会感觉IDE反应很迟钝，不像Delphi、C++Builder一样灵敏快捷。但在Eclipse开发环境中，设计包括可视化组件的应用时却很快捷，原因是Eclipse没有使用Java的标准用户界面组件库，当然也就没有按照JavaBean的规范开发设计GUI组件了。 </p>
<h2 id="PropertyEditor"><a href="#PropertyEditor" class="headerlink" title="PropertyEditor"></a><code>PropertyEditor</code></h2><p><code>PropertyEditor</code>是属性编辑器的接口，它规定了将外部设置值转换为内部JavaBean属性值的转换接口方法。<code>PropertyEditor</code>主要的接口方法说明如下：<br>  Object getValue()：返回属性的当前值。基本类型被封装成对应的封装类实例；<br>  void setValue(Object newValue)：设置属性的值，基本类型以封装类传入；<br>  String getAsText()：将属性对象用一个字符串表示，以便外部的属性编辑器能以可视化的方式显示。缺省返回null，表示该属性不能以字符串表示；<br>  void setAsText(String text)：用一个字符串去更新属性的内部值，这个字符串一般从外部属性编辑器传入；<br>  String[] getTags()：返回表示有效属性值的字符串数组（如boolean属性对应的有效Tag为true和false），以便属性编辑器能以下拉框的方式显示出来。缺省返回null，表示属性没有匹配的字符值有限集合；<br>  String getJavaInitializationString()：为属性提供一个表示初始值的字符串，属性编辑器以此值作为属性的默认值。</p>
<p>可以看出PropertyEditor接口方法是内部属性值和外部设置值的沟通桥梁。此外，我们可以很容易地发现该接口的很多方法是专为IDE中的可视化属性编辑器提供的：如getTags()、getJavaInitializationString()以及另外一些我们未此介绍的接口方法。 </p>
<p>Java为PropertyEditor提供了一个方便类：PropertyEditorSupport，该类实现了PropertyEditor接口并提供默认实现，一般情况下，用户可以通过扩展这个方便类设计自己的属性编辑器。 </p>
<p>BeanInfo </p>
<p>BeanInfo主要描述了JavaBean哪些属性可以编辑以及对应的属性编辑器，每一个属性对应一个属性描述器PropertyDescriptor。PropertyDescriptor的构造函数有两个入参：<br>PropertyDescriptor(String propertyName, Class beanClass) ，其中propertyName为属性名；而beanClass为JavaBean对应的Class。 </p>
<p>此外PropertyDescriptor还有一个setPropertyEditorClass(Class propertyEditorClass)方法，为JavaBean属性指定编辑器。BeanInfo接口最重要的方法就是：PropertyDescriptor[] getPropertyDescriptors() ，该方法返回JavaBean的属性描述器数组。 </p>
<p>BeanInfo接口有一个常用的实现类：SimpleBeanInfo，一般情况下，可以通过扩展SimpleBeanInfo实现自己的功能。 </p>
<p>一个实例 </p>
<p>在本节中，我们来看一个具体属性编辑器的实例，该实例根据《Core Java Ⅱ》上的一个例子改编而成。 </p>
<p>ChartBean是一个可定制图表组件，允许通过属性的设置定制图表的样式以得到满足各种不同使用场合要求的图表。我们忽略ChartBean的其他属性，仅关注其中的两个属性： </p>
<p>代码清单5-2  CharBean<br>Java代码  收藏代码<br>public class ChartBean extends JPanel{<br>   private int titlePosition = CENTER;<br>   private boolean inverse;<br>   //省略get/setter方法<br>}  </p>
<p>下面，我们为titlePosition属性提供一个属性编辑器。我们不去直接实现PropertyEditor，而是通过扩展PropertyEditorSupport这个方便类来定义我们的属性编辑器： </p>
<p>代码清单5-3  TitlePositionEditor<br>Java代码  收藏代码<br>import java.beans.*;<br> public class TitlePositionEditor extends PropertyEditorSupport{<br>    private String[] options = { “Left”, “Center”, “Right” };   </p>
<pre><code>//①代表可选属性值的字符串标识数组  
public String[] getTags() { return options; }      

//②代表属性初始值的字符串  
public String getJavaInitializationString() { return &quot;&quot; + getValue(); }   

//③将内部属性值转换为对应的字符串表示形式，供属性编辑器显示之用  
public String getAsText(){  
   int value = (Integer) getValue();  
   return options[value];  
}  

//④将外部设置的字符串转换为内部属性的值  
public void setAsText(String s){   
   for (int i = 0; i &lt; options.length; i++){  
      if (options[i].equals(s)){  
         setValue(i);  
         return;  
      }  
   }  
}  
</code></pre><p> }  </p>
<p>①处通过getTags()方法返回一个字符串数组，因此在IDE中该属性对应的编辑器将自动提供一个下拉框，下拉框中包含3个可选项：“Left”、“Center”、“Right”。而③和④处的两个方法分别完成属性值到字符串的双向转换功能。CharBean的inverse属性也有一个相似的编辑器InverseEditor，我们忽略不讲。 </p>
<p>下面编写ChartBean对应的BeanInfo，根据JavaBean的命名规范，这个BeanInfo应该命名为ChartBeanBeanInfo，它负责将属性编辑器和ChartBean的属性挂钩起来： </p>
<p>代码清单5-4  ChartBeanBeanInfo<br>Java代码  收藏代码<br>import java.beans.*;<br> public class ChartBeanBeanInfo extends SimpleBeanInfo{<br>    public PropertyDescriptor[] getPropertyDescriptors() {<br>       try{  </p>
<p>//①将TitlePositionEditor绑定到ChartBean的titlePosition属性中<br>PropertyDescriptor titlePositionDescriptor<br>             = new PropertyDescriptor(“titlePosition”, ChartBean.class);<br>          titlePositionDescriptor.setPropertyEditorClass(TitlePositionEditor.class);  </p>
<p>//②将InverseEditor绑定到ChartBean的inverse属性中<br>PropertyDescriptor inverseDescriptor<br>             = new PropertyDescriptor(“inverse”, ChartBean.class);<br>          inverseDescriptor.setPropertyEditorClass(InverseEditor.class);<br>          return new PropertyDescriptor[]{titlePositionDescriptor, inverseDescriptor};<br>       }<br>       catch (IntrospectionException e){<br>          e.printStackTrace();<br>          return null;<br>       }<br>    }<br> }  </p>
<p>在ChartBeanBeanInfo中，我们分别为ChartBean和titlePosition和inverse属性指定对应的属性编辑器。将ChartBean连同属性编辑器以及ChartBeanBeanInfo打成JAR包，使用IDE组件扩展管理功能注册到IDE中。这样，我们就可以像使用TextField、Checkbox等这些组对ChartBean进行可视化的开发设计工作了。下面是ChartBean在NetBeans IDE中的属性编辑器效果图，如图5-5所示。 </p>
<p>ChartBean可设置的属性都列在属性查看器中，当单击titlePosition属性时，下拉框中列出了我们提供的3个选项。 </p>
<p>Spring默认属性编辑器 </p>
<p>Spring的属性编辑器和传统的用于IDE开发时的属性编辑器不同，它们没有UI界面，仅负责将配置文件中的文本配置值转换为Bean属性的对应值，所以Spring的属性编辑器并非传统意义上的JavaBean属性编辑器。 </p>
<p>Spring为常见的属性类型提供了默认的属性编辑器。从图5-4中，我们可以看出BeanWrapperImpl类扩展了PropertyEditorRegistrySupport类，Spring在PropertyEditor RegistrySupport中为常见属性类型提供了默认的属性编辑器，这些“常见的类型”共32个，可分为3大类，总结如下： </p>
<p>表5-1  Spring提供的默认属性编辑器<br>类    别  说    明<br>基础数据类型  分为几个小类： 1）基本数据类型，如：boolean、byte、short、int等； 2）基本数据类型封装类，如：Long、Character、Integer等；  3）两个基本数据类型的数组，char[]和byte[]；    4）大数类，BigDecimal和BigInteger<br>集合类 为5种类型的集合类Collection、Set、SortedSet、List和SortedMap提供了编辑器<br>资源类 用于访问外部资源的8个常见类Class、Class[]、File、InputStream、Locale、Properties、Resource[]和URL   </p>
<p>PropertyEditorRegistrySupport中有两个用于保存属性编辑器的Map类型变量：<br>  defaultEditors：用于保存默认属性类型的编辑器，元素的键为属性类型，值为对应的属性编辑器实例；<br>  customEditors：用于保存用户自定义的属性编辑器，元素的键值和defaultEditors相同。</p>
<p>PropertyEditorRegistrySupport通过类似以下的代码定义默认属性编辑器：<br>Java代码  收藏代码<br>this.defaultEditors.put(char.class, new CharacterEditor(false));<br>this.defaultEditors.put(Character.class, new CharacterEditor(true));<br>this.defaultEditors.put(Locale.class, new LocaleEditor());<br>this.defaultEditors.put(Properties.class, new PropertiesEditor());  </p>
<p>这些默认的属性编辑器解决常见属性类型的注册问题，如果用户的应用包括一些特殊类型的属性，且希望在配置文件中以字面值提供配置值，那么就需要编写自定义属性编辑器并注册到Spring容器中。这样，Spring才能将配置文件中的属性配置值转换为对应的属性类型值。 </p>
<p>自定义属性编辑器 </p>
<p>Spring大部分默认属性编辑器都直接扩展于java.beans.PropertyEditorSupport类，用户也可以通过扩展PropertyEditorSupport实现自己的属性编辑器。比起用于IDE环境的属性编辑器来说，Spring环境下使用的属性编辑器的功能非常单一：仅需要将配置文件中字面值转换为属性类型的对象即可，并不需要提供UI界面，因此仅需要简单覆盖PropertyEditorSupport的setAsText()方法就可以了。 </p>
<p>一个实例 </p>
<p>我们继续使用第4章中Boss和Car的例子，假设我们现在希望在配置Boss时，不通过引用Bean的方式注入Boss的car属性，而希望直接通过字符串字面值提供配置。为了方便阅读，这里再次列出Boss和Car类的简要代码： </p>
<p>代码清单5-5  Car<br>Java代码  收藏代码<br>package com.baobaotao.editor;<br>public class Car {<br>    private int maxSpeed;<br>    public String brand;<br>    private double price;<br>    //省略get/setter<br>}  </p>
<p>代码清单5-6  Boss<br>Java代码  收藏代码<br>package com.baobaotao.editor;<br>public class Boss {<br>    private String name;<br>    private Car car = new Car();<br>    //省略get/setter<br>}  </p>
<p>Boss有两个属性：name和car，分别对应String类型和Car类型。Spring拥有String类型的默认属性编辑器，因此对于String类型的属性我们不用操心。但Car类型是我们自定义的类型，要配置Boss的car属性，有两种方案：<br>1）在配置文件中为car专门配置一个<bean>，然后在boss的<bean>中通过ref引用car Bean，这正是我们上一章中所用的方法；<br>2）为Car类型提供一个自定义的属性编辑器，这样，我们就通过字面值为Boss的car属性提供配置值。</bean></bean></p>
<p>第一种方案是常用的方法，但是在有些情况下，这种方式需要将属性对象一步步肢解为最终可以用基本类型表示的Bean，使配置文件变得不够清晰，直接为属性类提供一个对应的自定义属性编辑器可能会是更好的替代方案。 </p>
<p>现在，我们来为Car编写一个自定义的属性编辑器，其代码如下所示： </p>
<p>代码清单5-7  CustomCarEditor<br>Java代码  收藏代码<br>package com.baobaotao.editor;<br>import java.beans.PropertyEditorSupport;  </p>
<p>public class CustomCarEditor extends PropertyEditorSupport {  </p>
<pre><code>//①将字面值转换为属性类型对象  
public void setAsText(String text){   
    if(text == null || text.indexOf(&quot;,&quot;) == -1){  
        throw new IllegalArgumentException(&quot;设置的字符串格式不正确&quot;);  
    }  
    String[] infos = text.split(&quot;,&quot;);  
    Car car = new Car();  
    car.setBrand(infos[0]);  
    car.setMaxSpeed(Integer.parseInt(infos[1]));  
    car.setPrice(Double.parseDouble(infos[2]));  

     //②调用父类的setValue()方法设置转换后的属性对象  
    setValue(car);   
}  
</code></pre><p>}  </p>
<p>CustomCarEditor很简单，它仅覆盖PropertyEditorSupport便利类的setAsText(String text)方法，该方法负责将配置文件以字符串提供的字面值转换为Car对象。字面值采用逗号分隔的格式同时为brand、maxSpeed和price属性值提供设置值，setAsText()方法解析这个字面值并生成对应的Car对象。由于我们并不需要将Boss内部的car属性反显到属性编辑器中，因此不需要覆盖getAsText()方法。 </p>
<p>注册自定义的属性编辑器 </p>
<p>在IDE环境下，自定义属性编辑器在使用之前必须通过扩展组件功能进行注册，在Spring环境中也需要通过一定的方法注册自定义的属性编辑器。 </p>
<p>如果使用BeanFactory，用户需要手工调用registerCustomEditor(Class requiredType, PropertyEditor propertyEditor)方法注册自定义属性编辑器；如果使用ApplicationContext，则只需要在配置文件通过CustomEditorConfigurer注册就可以了。CustomEditorConfigurer实现BeanFactoryPostProcessor接口，因此是一个Bean工厂后处理器。我们知道Bean工厂后处理器在Spring容器加载配置文件并生成BeanDefinition半成品后就会被自动执行。因此CustomEditorConfigurer有容器启动时有机会注入自定义的属性编辑器。下面的配置片断定义了一个CustomEditorConfigurer： </p>
<p>Xml代码  收藏代码<br><!--①配置自动注册属性编辑器的CustomEditorConfigurer -->  </p>
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer"><br>        <property name="customEditors"><br>            <map><br>                   <!--②-1属性编辑器对应的属性类型--><br>                   <entry key="com.baobaotao.editor.Car"><br><br>                         <!--②-2对应的属性编辑器Bean --><br>                    <bean class="com.baobaotao.editor.CustomCarEditor"><br>                </bean></entry><br>            </map><br>        </property><br>    </bean><br> <bean id="boss" class="com.baobaotao.editor.Boss"><br>       <property name="name" value="John"><br>       <!--③该属性将使用②处的属性编辑器完成属性填充操作--><br>       <property name="car" value="红旗CA72,200,20000.00"><br></property></property></bean>  


<p>在①处，我们定义了用于注册自定义属性编辑器的CustomEditorConfigurer，Spring容器将通过反射机制自动调用这个Bean。CustomEditorConfigurer通过一个Map属性定义需要自动注册的自定义属性编辑器。在②处，我们为Car类型指定了对应属性编辑器CustomCarEditor，注意键是属性类型，而值是对应的属性编辑器Bean，而不是属性编辑器的类名。 </p>
<p>最精彩的部分当然是③处的配置，我们原来通过一个<bean>元素标签配置好car Bean，然后在boss的<bean>中通过ref引用car Bean，但是现在我们直接通过value为car属性提供配置。BeanWrapper在设置boss的car属性时，它将检索自定义属性编辑器的注册表，当发现Car属性类型拥有对应的属性编辑器CustomCarEditor时，它就会利用CustomCarEditor将“红旗CA72,200,20000.00”转换为Car对象。 </bean></bean></p>
<p>引用<br>按照JavaBeans的规范，JavaBeans的基础设施会在JavaBean相同类包下查找是否存在<javabean>Editor的类，如果存在，自动使用<javabean>Editor作为该JavaBean的PropertyEditor。<br>如com.baobaotao.domain.UserEditor会自动成为com.baobaotao.domain.User对应的PropertyEditor。Spring也支持这个规范，也即如果采用这种规约命令PropertyEditor，就无须显式在CustomEditorConfigurer中注册了，Spring将自动查找并注册这个PropertyEditor。</javabean></javabean></p>
<p>另：Spring 3.0除支持PropertyEditor外，还在核心包中引入了自建的ConversionService,它提供了更为强大的类型转换的能力，可以完成任意类型之间的转换，还可以在转换过程中参考目标对象所在宿主类的上下文信息。Spring的类型转换同时支持PropertyEdito和ConversionService。 </p>
]]></content>
    
    <summary type="html">
    
      学习Spring必学的Java基础知识----PropertyEditor
    
    </summary>
    
      <category term="spring" scheme="http://jishusuishouji.github.io/categories/spring/"/>
    
    
      <category term="spring" scheme="http://jishusuishouji.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>探秘Spring的PropertyEditor</title>
    <link href="http://jishusuishouji.github.io/2017/04/18/spring/%E6%8E%A2%E7%A7%98Spring%E7%9A%84PropertyEditor/"/>
    <id>http://jishusuishouji.github.io/2017/04/18/spring/探秘Spring的PropertyEditor/</id>
    <published>2017-04-18T14:03:18.000Z</published>
    <updated>2017-04-18T15:27:13.808Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.beans.PropertyEditor</code>是JDK自带的类，是提供给AWT。</p>
<p>Spring利用该接口来实现Bean的属性转换器。</p>
<p>Spring xml配置的bean属性都是字符串类型的值，但是对应到的每个具体的属性是各种类型的，Spring通过各种<code>PropertyEditor</code>来对各个属性进行类型转换。</p>
<p>Spring并不是直接实现<code>PropertyEditor</code>接口，而是继承<code>PropertyEditorSupport</code>类。</p>
<h2 id="PropertyEditorRegistry"><a href="#PropertyEditorRegistry" class="headerlink" title="PropertyEditorRegistry"></a><code>PropertyEditorRegistry</code></h2><p><code>BeanWrapperImpl</code>是<code>PropertyEditorRegistrySupport</code>的子类。<br><code>PropertyEditorRegistry</code>是一个接口，<code>PropertyEditorRegistrySupport</code>是它的实现类。<br><code>PropertyEditorRegistrySupport</code>中的方法<code>createDefaultEditors</code>，该方法初始化Spring中默认<code>PropertyEditor</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Actually register the default editors for this registry instance.</div><div class="line"> */</div><div class="line">private void createDefaultEditors() &#123;</div><div class="line">    this.defaultEditors = new HashMap&lt;&gt;(64);</div><div class="line"></div><div class="line">    // Simple editors, without parameterization capabilities.</div><div class="line">    // The JDK does not contain a default editor for any of these target types.</div><div class="line">    this.defaultEditors.put(Charset.class, new CharsetEditor());</div><div class="line">    this.defaultEditors.put(Class.class, new ClassEditor());</div><div class="line">    this.defaultEditors.put(Class[].class, new ClassArrayEditor());</div><div class="line">    this.defaultEditors.put(Currency.class, new CurrencyEditor());</div><div class="line">    this.defaultEditors.put(File.class, new FileEditor());</div><div class="line">    this.defaultEditors.put(InputStream.class, new InputStreamEditor());</div><div class="line">    this.defaultEditors.put(InputSource.class, new InputSourceEditor());</div><div class="line">    this.defaultEditors.put(Locale.class, new LocaleEditor());</div><div class="line">    this.defaultEditors.put(Path.class, new PathEditor());</div><div class="line">    this.defaultEditors.put(Pattern.class, new PatternEditor());</div><div class="line">    this.defaultEditors.put(Properties.class, new PropertiesEditor());</div><div class="line">    this.defaultEditors.put(Reader.class, new ReaderEditor());</div><div class="line">    this.defaultEditors.put(Resource[].class, new ResourceArrayPropertyEditor());</div><div class="line">    this.defaultEditors.put(TimeZone.class, new TimeZoneEditor());</div><div class="line">    this.defaultEditors.put(URI.class, new URIEditor());</div><div class="line">    this.defaultEditors.put(URL.class, new URLEditor());</div><div class="line">    this.defaultEditors.put(UUID.class, new UUIDEditor());</div><div class="line">    this.defaultEditors.put(ZoneId.class, new ZoneIdEditor());</div><div class="line"></div><div class="line">    // Default instances of collection editors.</div><div class="line">    // Can be overridden by registering custom instances of those as custom editors.</div><div class="line">    this.defaultEditors.put(Collection.class, new CustomCollectionEditor(Collection.class));</div><div class="line">    this.defaultEditors.put(Set.class, new CustomCollectionEditor(Set.class));</div><div class="line">    this.defaultEditors.put(SortedSet.class, new CustomCollectionEditor(SortedSet.class));</div><div class="line">    this.defaultEditors.put(List.class, new CustomCollectionEditor(List.class));</div><div class="line">    this.defaultEditors.put(SortedMap.class, new CustomMapEditor(SortedMap.class));</div><div class="line"></div><div class="line">    // Default editors for primitive arrays.</div><div class="line">    this.defaultEditors.put(byte[].class, new ByteArrayPropertyEditor());</div><div class="line">    this.defaultEditors.put(char[].class, new CharArrayPropertyEditor());</div><div class="line"></div><div class="line">    // The JDK does not contain a default editor for char!</div><div class="line">    this.defaultEditors.put(char.class, new CharacterEditor(false));</div><div class="line">    this.defaultEditors.put(Character.class, new CharacterEditor(true));</div><div class="line"></div><div class="line">    // Spring&apos;s CustomBooleanEditor accepts more flag values than the JDK&apos;s default editor.</div><div class="line">    this.defaultEditors.put(boolean.class, new CustomBooleanEditor(false));</div><div class="line">    this.defaultEditors.put(Boolean.class, new CustomBooleanEditor(true));</div><div class="line"></div><div class="line">    // The JDK does not contain default editors for number wrapper types!</div><div class="line">    // Override JDK primitive number editors with our own CustomNumberEditor.</div><div class="line">    this.defaultEditors.put(byte.class, new CustomNumberEditor(Byte.class, false));</div><div class="line">    this.defaultEditors.put(Byte.class, new CustomNumberEditor(Byte.class, true));</div><div class="line">    this.defaultEditors.put(short.class, new CustomNumberEditor(Short.class, false));</div><div class="line">    this.defaultEditors.put(Short.class, new CustomNumberEditor(Short.class, true));</div><div class="line">    this.defaultEditors.put(int.class, new CustomNumberEditor(Integer.class, false));</div><div class="line">    this.defaultEditors.put(Integer.class, new CustomNumberEditor(Integer.class, true));</div><div class="line">    this.defaultEditors.put(long.class, new CustomNumberEditor(Long.class, false));</div><div class="line">    this.defaultEditors.put(Long.class, new CustomNumberEditor(Long.class, true));</div><div class="line">    this.defaultEditors.put(float.class, new CustomNumberEditor(Float.class, false));</div><div class="line">    this.defaultEditors.put(Float.class, new CustomNumberEditor(Float.class, true));</div><div class="line">    this.defaultEditors.put(double.class, new CustomNumberEditor(Double.class, false));</div><div class="line">    this.defaultEditors.put(Double.class, new CustomNumberEditor(Double.class, true));</div><div class="line">    this.defaultEditors.put(BigDecimal.class, new CustomNumberEditor(BigDecimal.class, true));</div><div class="line">    this.defaultEditors.put(BigInteger.class, new CustomNumberEditor(BigInteger.class, true));</div><div class="line"></div><div class="line">    // Only register config value editors if explicitly requested.</div><div class="line">    if (this.configValueEditorsActive) &#123;</div><div class="line">        StringArrayPropertyEditor sae = new StringArrayPropertyEditor();</div><div class="line">        this.defaultEditors.put(String[].class, sae);</div><div class="line">        this.defaultEditors.put(short[].class, sae);</div><div class="line">        this.defaultEditors.put(int[].class, sae);</div><div class="line">        this.defaultEditors.put(long[].class, sae);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能上面能够转换的类型还不能满足需求，那么可以通过另一种方式将<code>PropertyEditor</code>注入到Spring中。</p>
<h2 id="PropertyEditorRegistrar"><a href="#PropertyEditorRegistrar" class="headerlink" title="PropertyEditorRegistrar"></a><code>PropertyEditorRegistrar</code></h2><p>该接口只有一个方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void registerCustomEditors(PropertyEditorRegistry registry)</div></pre></td></tr></table></figure></p>
<p>实现该方法就可以往传入的registry添加自定义的<code>PropertyEditor</code>，一般情况下传入的registry是<code>BeanWrapperImpl</code>的实例，即将自定义的<code>PropertyEditor</code>注入到<code>BeanWrapperImpl</code>。</p>
<h2 id="CustomEditorConfigurer"><a href="#CustomEditorConfigurer" class="headerlink" title="CustomEditorConfigurer"></a><code>CustomEditorConfigurer</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</div><div class="line">    if (this.propertyEditorRegistrars != null) &#123;</div><div class="line">        for (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) &#123;</div><div class="line">            beanFactory.addPropertyEditorRegistrar(propertyEditorRegistrar);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把<code>PropertyEditorRegistrar</code>添加到<code>BeanFactory</code>。</p>
<p>它是实现了<code>BeanFactoryPostProcessor</code>接口，即在构造完<code>BeanDefinition</code>之后会调用方法<code>postProcessBeanFactory</code>。</p>
<p>注入一个<code>CustomEditorConfigurerBean</code>(设置<code>propertyEditorRegistrars</code>和<code>customEditors属性</code>)就可以将自定义的<code>PropertyEditor</code>注入到Spring中了。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="自定义PropertyEditor"><a href="#自定义PropertyEditor" class="headerlink" title="自定义PropertyEditor"></a>自定义<code>PropertyEditor</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class CustomPropertyEditor extends PropertyEditorSupport &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setAsText(String text) throws IllegalArgumentException &#123;</div><div class="line">        super.setAsText(text);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object getValue() &#123;</div><div class="line">        return super.getValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="将这个PropertyEditor注入到Spring里面中"><a href="#将这个PropertyEditor注入到Spring里面中" class="headerlink" title="将这个PropertyEditor注入到Spring里面中"></a>将这个<code>PropertyEditor</code>注入到Spring里面中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt;</div><div class="line">    &lt;property name=&quot;customEditors&quot;&gt;</div><div class="line">        &lt;map&gt;</div><div class="line">            &lt;entry key=&quot;com.xx.foo.FooPojo&quot; value=&quot;com.xx.foo.CustomPropertyEditor&quot;/&gt;</div><div class="line">        &lt;/map&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h2 id="ClassEditor的实现"><a href="#ClassEditor的实现" class="headerlink" title="ClassEditor的实现"></a><code>ClassEditor</code>的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class ClassEditor extends PropertyEditorSupport &#123;</div><div class="line"></div><div class="line">    private final ClassLoader classLoader;</div><div class="line">    public ClassEditor() &#123;</div><div class="line">        this(null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ClassEditor(ClassLoader classLoader) &#123;</div><div class="line">        this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAsText(String text) throws IllegalArgumentException &#123;</div><div class="line">        if (StringUtils.hasText(text)) &#123;</div><div class="line">            setValue(ClassUtils.resolveClassName(text.trim(), this.classLoader));</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            setValue(null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String getAsText() &#123;</div><div class="line">        Class clazz = (Class) getValue();</div><div class="line">        if (clazz != null) &#123;</div><div class="line">            return ClassUtils.getQualifiedName(clazz);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            return &quot;&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      探秘Spring的PropertyEditor
    
    </summary>
    
      <category term="Spring" scheme="http://jishusuishouji.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://jishusuishouji.github.io/tags/Spring/"/>
    
      <category term="PropertyEditor" scheme="http://jishusuishouji.github.io/tags/PropertyEditor/"/>
    
  </entry>
  
  <entry>
    <title>ServletContext总结</title>
    <link href="http://jishusuishouji.github.io/2017/04/17/ServletContext%E6%80%BB%E7%BB%93.md/ServletContext%E6%80%BB%E7%BB%93/"/>
    <id>http://jishusuishouji.github.io/2017/04/17/ServletContext总结.md/ServletContext总结/</id>
    <published>2017-04-17T14:23:11.000Z</published>
    <updated>2017-04-17T14:23:11.349Z</updated>
    
    <summary type="html">
    
      ServletContext总结
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于Keepalived+Haproxy搭建四层负载均衡器</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/jiqun/%E5%9F%BA%E4%BA%8EKeepalived_Haproxy%E6%90%AD%E5%BB%BA%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/jiqun/基于Keepalived_Haproxy搭建四层负载均衡器/</id>
    <published>2017-04-07T05:07:53.000Z</published>
    <updated>2017-04-07T05:13:34.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Haproxy是稳定、高性能、高可用性的负载均衡解决方案，支持HTTP及TCP代理后端服务器池，因支持强大灵活的7层acl规则，广泛作为HTTP反向代理。本文则详细介绍如何利用它的四层交换与Keepalived实现一个负载均衡器，适用于Socket、ICE、mail、mysql、私有通讯等任意TCP服务。系统架构图如下：</p>
<p>点击在新窗口中浏览此图片</p>
<p>二、平台环境</p>
<p>OS:Centos5.4(64X)<br>MASTER:192.168.0.20<br>BACKUP:192.168.0.21<br>VIP:192.168.0.100<br>Serivce Port:11231<br>三、平台安装配置</p>
<p>1、添加非本机ip邦定支持</p>
<p>#vi /etc/sysctl.conf<br>net.ipv4.ip_nonlocal_bind=1</p>
<p>#sysctl –p<br>2、配置平台日志支持</p>
<p>#vi /etc/syslog.conf<br>添加：<br>local3.<em>        /var/log/haproxy.log<br>local0.</em>        /var/log/haproxy.log</p>
<p>#vi /etc/sysconfig/syslog<br>修改：<br>SYSLOGD_OPTIONS=”-r -m 0”</p>
<p>#/etc/init.d/syslog restart<br>3、关闭SELINUX</p>
<p>vi /etc/sysconfig/selinux<br>修改：<br>SELINUX=disabled</p>
<p>#setenforce 0<br>4、配置iptables，添加VRRP通讯支持</p>
<p>iptables -A INPUT -d 224.0.0.18 -j accept<br>5、Keepalived的安装、配置</p>
<p>#mkdir -p /home/install/keepalivedha</p>
<p>#cd /home/install/keepalivedha</p>
<p>#wget <a href="http://www.keepalived.org/software/keepalived-1.2.2.tar.gz" target="_blank" rel="external">http://www.keepalived.org/software/keepalived-1.2.2.tar.gz</a></p>
<p>#tar zxvf keepalived-1.2.2.tar.gz</p>
<p>#cd keepalived-1.2.2</p>
<p>#./configure</p>
<p>#make &amp;&amp; make install</p>
<p>#cp /usr/local/etc/rc.d/init.d/keepalived /etc/rc.d/init.d/</p>
<p>#cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/</p>
<p>#mkdir /etc/keepalived</p>
<p>#cp /usr/local/etc/keepalived/keepalived.conf /etc/keepalived/</p>
<p>#cp /usr/local/sbin/keepalived /usr/sbin/</p>
<p>#vi /etc/keepalived/keepalived.conf</p>
<p>! Configuration file for keepalived  </p>
<p>global_defs {<br>   notification_email {<br>         liutiansi@gmail.com<br>   }<br>   notification_email_from liutiansi@gmail.com<br>   smtp_connect_timeout 3<br>   smtp_server 127.0.0.1<br>   router_id LVS_DEVEL<br>}<br>vrrp_script chk_haproxy {<br>    script “killall -0 haproxy”<br>    interval 2<br>    weight 2<br>}<br>vrrp_instance VI_1 {<br>    interface eth1<br>    state MASTER # 从为BACKUP<br>    priority 101 # 从为100<br>    virtual_router_id 50 #路由ID，可通过#tcpdump vrrp查看。<br>    garp_master_delay 1 #主从切换时间，单位为秒。  </p>
<pre><code>authentication {  
    auth_type PASS  
    auth_pass KJj23576hYgu23IP  
}  
track_interface {  
   eth0  
   eth1  
}  
virtual_ipaddress {  
    192.168.0.100  
}  
track_script {  
    chk_haproxy  
}  

#状态通知  
notify_master &quot;/etc/keepalived/Mailnotify.py master&quot;  
notify_backup &quot;/etc/keepalived/Mailnotify.py backup&quot;  
notify_fault &quot;/etc/keepalived/Mailnotify.py fault&quot;  
</code></pre><p>}<br>6、Haproxy的安装与配置</p>
<p>#cd /home/install/keepalivedha</p>
<p>#wget <a href="http://haproxy.1wt.eu/download/1.4/src/haproxy-1.4.11.tar.gz" target="_blank" rel="external">http://haproxy.1wt.eu/download/1.4/src/haproxy-1.4.11.tar.gz</a></p>
<p>#tar -zxvf haproxy-1.4.11.tar.gz</p>
<p>#cd haproxy-1.4.11</p>
<p>#make install</p>
<p>#mkdir -p /usr/local/haproxy/etc</p>
<p>#mkdir -p /usr/local/haproxy/sbin</p>
<p>#cp examples/haproxy.cfg /usr/local/haproxy/etc</p>
<p>#ln -s /usr/local/sbin/haproxy /usr/local/haproxy/sbin/haproxy </p>
<p>#vi /usr/local/haproxy/etc/haproxy.cfg</p>
<h1 id="this-config-needs-haproxy-1-1-28-or-haproxy-1-2-1"><a href="#this-config-needs-haproxy-1-1-28-or-haproxy-1-2-1" class="headerlink" title="this config needs haproxy-1.1.28 or haproxy-1.2.1"></a>this config needs haproxy-1.1.28 or haproxy-1.2.1</h1><p>global  </p>
<h1 id="log-127-0-0-1-local0"><a href="#log-127-0-0-1-local0" class="headerlink" title="log 127.0.0.1   local0"></a>log 127.0.0.1   local0</h1><pre><code>log 127.0.0.1   local1 notice  
maxconn 5000  
uid 99  
gid 99  

daemon  
pidfile /usr/local/haproxy/haproxy.pid  
</code></pre><p>defaults<br>        log     global<br>        mode    http  </p>
<pre><code>#option httplog  
 option  dontlognull  
 retries 3  
 option redispatch  
 maxconn 2000  
 contimeout      5000  
 clitimeout      50000  
 srvtimeout      50000  
</code></pre><p>listen  ICE01   192.168.0.100:11231<br>        mode tcp #配置TCP模式<br>        maxconn 2000<br>        balance roundrobin<br>        server  ice-192.168.0.128 192.168.0.128:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.129 192.168.0.129:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.130 192.168.0.130:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.131 192.168.0.131:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.132 192.168.0.132:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.34 192.168.0.34:11231 check inter 5000 fall 1 rise 2<br>        srvtimeout      20000  </p>
<p>listen stats_auth 192.168.0.20:80  </p>
<h1 id="listen-stats-auth-192-168-0-21-80-backup-config"><a href="#listen-stats-auth-192-168-0-21-80-backup-config" class="headerlink" title="listen stats_auth 192.168.0.21:80 # backup config"></a>listen stats_auth 192.168.0.21:80 # backup config</h1><pre><code>stats enable  
stats uri  /admin-status #管理地址  
stats auth  admin:123456 #管理帐号:管理密码  
stats admin if TRUE  
</code></pre><p>7、邮件通知程序(python实现)</p>
<p>#vi /etc/keepalived/Mailnotify.py</p>
<p>#!/usr/local/bin/python  </p>
<p>#coding: utf-8<br>from email.MIMEMultipart import MIMEMultipart<br>from email.MIMEText import MIMEText<br>from email.MIMEImage import MIMEImage<br>from email.header import Header<br>import sys<br>import smtplib  </p>
<p>#—————————————————————  </p>
<h1 id="Name-Mailnotify-py"><a href="#Name-Mailnotify-py" class="headerlink" title="Name:        Mailnotify.py"></a>Name:        Mailnotify.py</h1><h1 id="Purpose-Mail-notify-to-SA"><a href="#Purpose-Mail-notify-to-SA" class="headerlink" title="Purpose:     Mail notify to SA"></a>Purpose:     Mail notify to SA</h1><h1 id="Author-Liutiansi"><a href="#Author-Liutiansi" class="headerlink" title="Author:      Liutiansi"></a>Author:      Liutiansi</h1><h1 id="Email-liutiansi-gamil-com"><a href="#Email-liutiansi-gamil-com" class="headerlink" title="Email:       liutiansi@gamil.com"></a>Email:       liutiansi@gamil.com</h1><h1 id="Created-2011-03-09"><a href="#Created-2011-03-09" class="headerlink" title="Created:     2011/03/09"></a>Created:     2011/03/09</h1><h1 id="Copyright-c-2011"><a href="#Copyright-c-2011" class="headerlink" title="Copyright:   (c) 2011"></a>Copyright:   (c) 2011</h1><p>#————————————————————–<br>strFrom = ‘admin@domain.com’<br>strTo = ‘liutiansi@gmail.com’<br>smtp_server=’smtp.domain.com’<br>smtp_pass=’123456’  </p>
<p>if sys.argv[1]!=”master” and sys.argv[1]!=”backup”  and sys.argv[1]!=”fault”:<br>    sys.exit()<br>else:<br>    notify_type=sys.argv[1]  </p>
<p>mail_title=’[紧急]负载均衡器邮件通知’<br>mail_body_plain=notify_type+’被激活，请做好应急处理。’<br>mail_body_html=’<b><font color="red">‘+notify_type+’被激活，请做好应急处理。</font></b>‘  </p>
<p>msgRoot = MIMEMultipart(‘related’)<br>msgRoot[‘Subject’] =Header(mail_title,’utf-8’)<br>msgRoot[‘From’] = strFrom<br>msgRoot[‘To’] = strTo  </p>
<p>msgAlternative = MIMEMultipart(‘alternative’)<br>msgRoot.attach(msgAlternative)  </p>
<p>msgText = MIMEText(mail_body_plain, ‘plain’, ‘utf-8’)<br>msgAlternative.attach(msgText)  </p>
<p>msgText = MIMEText(mail_body_html, ‘html’,’utf-8’)<br>msgAlternative.attach(msgText)  </p>
<p>smtp = smtplib.SMTP()<br>smtp.connect(smtp_server)<br>smtp.login(smtp_user,smtp_pass)<br>smtp.sendmail(strFrom, strTo, msgRoot.as_string())<br>smtp.quit()<br>注：修改成系统python实际路径“#!/usr/local/bin/python”(第一行)</p>
<p>#chmod +x /etc/keepalived/Mailnotify.py</p>
<p>#/usr/local/haproxy/sbin/haproxy -f /usr/local/haproxy/etc/haproxy.cfg</p>
<p>#service keepalived start<br>8、查看VRRP通讯记录</p>
<p>#tcpdump vrrp<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes<br>15:49:05.270017 IP 192.168.0.20 &gt; VRRP.MCAST.NET: VRRPv2, Advertisement, vrid 50, prio 100, authtype simple, intvl 1s, length 20<br>四、Haproxy界面</p>
<p>访问<a href="http://192.168.0.20/admin-status，输入帐号admin密码123456进入管理监控平台。" target="_blank" rel="external">http://192.168.0.20/admin-status，输入帐号admin密码123456进入管理监控平台。</a></p>
<p>点击在新窗口中浏览此图片</p>
<p>haproxy-1.4.9以后版本最大的亮点是添加了手工启用/禁用功能，对升级变更应用时非常有用。</p>
<p>五、邮件通知</p>
<p>点击在新窗口中浏览此图片</p>
]]></content>
    
    <summary type="html">
    
      基于Keepalived+Haproxy搭建四层负载均衡器
    
    </summary>
    
      <category term="集群" scheme="http://jishusuishouji.github.io/categories/%E9%9B%86%E7%BE%A4/"/>
    
    
      <category term="集群" scheme="http://jishusuishouji.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>nginx+keepalive主从双机热备+自动切换解决方案</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/jiqun/nginx_keepalive%E4%B8%BB%E4%BB%8E%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87_%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/jiqun/nginx_keepalive主从双机热备_自动切换解决方案/</id>
    <published>2017-04-07T04:42:10.000Z</published>
    <updated>2017-04-07T04:50:23.322Z</updated>
    
    <content type="html"><![CDATA[<p>cenots 6.3 64位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y make wget</div></pre></td></tr></table></figure>
<h2 id="1-安装keepalive"><a href="#1-安装keepalive" class="headerlink" title="1.安装keepalive"></a>1.安装keepalive</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar zxvf keepalived-1.2.7.tar.gz</div><div class="line">cd keepalived-1.2.7</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">yum install -y gcc openssl-devel popt-devel</div><div class="line">./configure</div><div class="line">make &amp;&amp; make install </div><div class="line"></div><div class="line">cp /usr/local/etc/rc.d/init.d/keepalived /etc/init.d/</div><div class="line">cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/</div><div class="line">chmod +x /etc/init.d/keepalived</div><div class="line">chkconfig --add keepalived</div><div class="line">chkconfig keepalived on</div><div class="line">mkdir /etc/keepalived</div><div class="line">ln -s /usr/local/sbin/keepalived /usr/sbin/</div></pre></td></tr></table></figure>
<h2 id="2-安装Nginx"><a href="#2-安装Nginx" class="headerlink" title="2.安装Nginx"></a>2.安装Nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar zxvf  nginx-1.2.5.tar.gz</div><div class="line">cd nginx-1.2.5</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum install -y pcre-devel</div><div class="line">./configure --prefix=/usr/local/nginx --user=www --group=www  --with-http_stub_status_module --with-http_ssl_module</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h2 id="3-配置keepalive"><a href="#3-配置keepalive" class="headerlink" title="3.配置keepalive"></a>3.配置keepalive</h2><p>两台服务器端<code>keepalived.conf</code>内容如下，都设置为<code>backup</code>，不抢占，注意修改优先级不同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">! Configuration file for keepalived</div><div class="line">global_defs &#123;</div><div class="line">   notification_email &#123;</div><div class="line">    admin@lvtao.net</div><div class="line">   &#125;</div><div class="line">   notification_email_from admin@lvtao.net</div><div class="line">   smtp_server 127.0.0.1</div><div class="line">   smtp_connect_timeout 30</div><div class="line">   router_id LVS_DEVEL</div><div class="line">&#125;</div><div class="line">#监控服务.NGINX mysql等</div><div class="line">vrrp_script chk_nginx &#123;</div><div class="line">    script &quot;/home/check_nginx.sh&quot;</div><div class="line">    interval 2</div><div class="line">    weight 2</div><div class="line">&#125;</div><div class="line"></div><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    state BACKUP  #主从设置 MASTER</div><div class="line">    interface eth2  #网卡名</div><div class="line">    virtual_router_id 51</div><div class="line">    mcast_src_ip 10.0.1.133 #本机ip</div><div class="line">    priority 50  #从机小于主机</div><div class="line">    advert_int 1</div><div class="line">    authentication &#123;</div><div class="line">        auth_type PASS</div><div class="line">        auth_pass chtopnet</div><div class="line">    &#125;</div><div class="line">    virtual_ipaddress &#123;</div><div class="line">        10.0.1.2  #VIP 的IP</div><div class="line">    &#125;</div><div class="line">    track_script &#123;</div><div class="line">        chk_nginx  #检测脚本</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">virtual_server 10.0.1.2 80 &#123;</div><div class="line">    delay_loop 6</div><div class="line">    lb_algo rr</div><div class="line">    lb_kind DR</div><div class="line">    persistence_timeout 50</div><div class="line">    protocol TCP</div><div class="line"></div><div class="line">    real_server 10.0.1.132 80 &#123;</div><div class="line">        weight 3</div><div class="line">        TCP_CHECK &#123;</div><div class="line">            connect_timeout 10</div><div class="line">            nb_get_retry 3</div><div class="line">            delay_before_retry 3</div><div class="line">            connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    real_server 10.0.1.133 80 &#123;</div><div class="line">        weight 3</div><div class="line">        TCP_CHECK &#123;</div><div class="line">            connect_timeout 10</div><div class="line">            nb_get_retry 3</div><div class="line">            delay_before_retry 3</div><div class="line">            connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动相关服务。我在这儿使用的是nginx ，每个上面开了一个站点，通过IP可以直接访问的。启动keepalive后，就可以通过VIP的虚拟IP 10.0.1.2来访问站点了，测试方法就是 停止任何其中一个站点，看它是否能自动切换到从服务器上。</p>
<p>上面代码中nginx的检测脚本如下 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">if [ &quot;$(ps -ef | grep &quot;nginx: master process&quot;| grep -v grep )&quot; == &quot;&quot; ]</div><div class="line">then</div><div class="line"> /usr/local/nginx/sbin/nginx</div><div class="line"> sleep 5</div><div class="line"> if [ &quot;$(ps -ef | grep &quot;nginx: master process&quot;| grep -v grep )&quot; == &quot;&quot; ]</div><div class="line"> then</div><div class="line">     killall keepalived</div><div class="line"> fi</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<p>在两台Web Server上执行<code>realserver.sh</code>脚本，为lo:0绑定VIP地址10.0.1.2、抑制arp广播。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">#description: Config realserver</div><div class="line"></div><div class="line">VIP=10.0.1.2</div><div class="line"> </div><div class="line">/etc/rc.d/init.d/functions</div><div class="line"> </div><div class="line">case &quot;$1&quot; in</div><div class="line">start)</div><div class="line">       /sbin/ifconfig lo:0 $VIP netmask 255.255.255.255 broadcast $VIP</div><div class="line">       /sbin/route add -host $VIP dev lo:0</div><div class="line">       echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</div><div class="line">       echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</div><div class="line">       echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</div><div class="line">       echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce</div><div class="line">       sysctl -p &gt;/dev/null 2&gt;&amp;1</div><div class="line">       echo &quot;RealServer Start OK&quot;</div><div class="line">       ;;</div><div class="line">stop)</div><div class="line">       /sbin/ifconfig lo:0 down</div><div class="line">       /sbin/route del $VIP &gt;/dev/null 2&gt;&amp;1</div><div class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</div><div class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</div><div class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</div><div class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce</div><div class="line">       echo &quot;RealServer Stoped&quot;</div><div class="line">       ;;</div><div class="line">*)</div><div class="line">       echo &quot;Usage: $0 &#123;start|stop&#125;&quot;</div><div class="line">       exit 1</div><div class="line">esac</div><div class="line"> </div><div class="line">exit 0</div></pre></td></tr></table></figure></p>
<p>分别在主从机上执行<code>sh realserver.sh start</code>就可实现负载均衡及高可用集群了；</p>
<p>keepalive相关参数说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"> ! Configuration File for keepalived</div><div class="line"></div><div class="line">global_defs &#123;</div><div class="line">   notification_email &#123;</div><div class="line">     admin@lvtao.net             #设置报警邮件地址，可以设置多个，每行一个。 需开启本机的sendmail服务</div><div class="line">   &#125;</div><div class="line">   notification_email_from  admin@lvtao.net        #设置邮件的发送地址</div><div class="line">   smtp_server 127.0.0.1                                #设置smtp server地址</div><div class="line">   smtp_connect_timeout 30                              #设置连接smtp server的超时时间</div><div class="line">   router_id LVS_DEVEL                                  #表示运行keepalived服务器的一个标识。发邮件时显示在邮件主题的信息</div><div class="line">&#125;</div><div class="line"></div><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    state MASTER              #指定keepalived的角色，MASTER表示此主机是主服务器，BACKUP表示此主机是备用服务器</div><div class="line">    interface eth0            #指定HA监测网络的接口</div><div class="line">    virtual_router_id 51      #虚拟路由标识，这个标识是一个数字，同一个vrrp实例使用唯一的标识。即同一vrrp_instance下，MASTER和BACKUP必须是一致的</div><div class="line">    priority 100              #定义优先级，数字越大，优先级越高，在同一个vrrp_instance下，MASTER的优先级必须大于BACKUP的优先级</div><div class="line">    advert_int 1              #设定MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒</div><div class="line">    authentication &#123;          #设置验证类型和密码</div><div class="line">        auth_type PASS        #设置验证类型，主要有PASS和AH两种</div><div class="line">        auth_pass 1111        #设置验证密码，在同一个vrrp_instance下，MASTER与BACKUP必须使用相同的密码才能正常通信</div><div class="line">    &#125;</div><div class="line">    virtual_ipaddress &#123;       #设置虚拟IP地址，可以设置多个虚拟IP地址，每行一个</div><div class="line">        10.0.0.148</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">virtual_server 10.0.0.148 80 &#123;      #设置虚拟服务器，需要指定虚拟IP地址和服务端口，IP与端口之间用空格隔开</div><div class="line">    delay_loop 6                    #设置运行情况检查时间，单位是秒</div><div class="line">    lb_algo rr                      #设置负载调度算法，这里设置为rr，即轮询算法</div><div class="line">    lb_kind DR                      #设置LVS实现负载均衡的机制，有NAT、TUN、DR三个模式可选</div><div class="line">    persistence_timeout 50          #会话保持时间，单位是秒。这个选项对动态网页是非常有用的，为集群系统中的session共享提供了一个很好的解决方案。</div><div class="line">                                    #有了这个会话保持功能，用户的请求会被一直分发到某个服务节点，直到超过这个会话的保持时间。</div><div class="line">                                    #需要注意的是，这个会话保持时间是最大无响应超时时间，也就是说，用户在操作动态页面时，如果50秒内没有执行任何操作，</div><div class="line">                                    #那么接下来的操作会被分发到另外的节点，但是如果用户一直在操作动态页面，则不受50秒的时间限制</div><div class="line">    protocol TCP                    #指定转发协议类型，有TCP和UDP两种</div><div class="line"></div><div class="line">    real_server 10.0.0.137 80 &#123;     #配置服务节点1，需要指定real server的真实IP地址和端口，IP与端口之间用空格隔开</div><div class="line">        weight 3                    #配置服务节点的权值，权值大小用数字表示，数字越大，权值越高，设置权值大小可以为不同性能的服务器</div><div class="line">                                    #分配不同的负载，可以为性能高的服务器设置较高的权值，而为性能较低的服务器设置相对较低的权值，这样才能合理地利用和分配系统资源</div><div class="line">        TCP_CHECK &#123;                 #realserver的状态检测设置部分，单位是秒</div><div class="line">            connect_timeout 10      #表示3秒无响应超时</div><div class="line">            nb_get_retry 3          #表示重试次数</div><div class="line">            delay_before_retry 3    #表示重试间隔</div><div class="line">            connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    real_server 10.0.0.139 80 &#123;</div><div class="line">        weight 3</div><div class="line">        TCP_CHECK &#123;</div><div class="line">            connect_timeout 10</div><div class="line">            nb_get_retry 3</div><div class="line">            delay_before_retry 3</div><div class="line">            connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      nginx+keepalive主从双机热备+自动切换解决方案
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>反向代理为何叫反向代理？</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/fangxiangdaili/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%BA%E4%BD%95%E5%8F%AB%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9F/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/fangxiangdaili/反向代理为何叫反向代理？/</id>
    <published>2017-04-07T04:19:19.000Z</published>
    <updated>2017-04-07T04:29:06.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>A同学准备找马云借钱，但是马云不同意；于是他通过马云的亲戚向马云借钱，事情成了。这里马云并不知道钱是谁借的，马云借给了自己的亲戚，亲戚最后转交给A同学。亲戚在这个过程中扮演了代理的角色(正向代理)。如果马云是服务器，大家访问它(跟他借钱)，而马云又不可能随随便便借钱给别人，那么那些马云的亲戚就是正向代理，代理客户端(A同学们)向马云借钱。  </p>
<p>常说的代理也就是指正向代理，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端的都被代理服务器代替来请求。</p>
<p>科学上网工具扮演的就是正向代理角色。</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>拨打10086客服电话，一个地区的10086客服有几个或者几十个，你拨通了10086的总机号码，电话那头总会有人会回答你。这里的10086总机号码就是起了反向代理的作用。客户并不知道真正提供服务人的是谁。</p>
<p>反向代理隐藏了真实的服务端。</p>
<h2 id="正向代理和反向代理的区别"><a href="#正向代理和反向代理的区别" class="headerlink" title="正向代理和反向代理的区别"></a>正向代理和反向代理的区别</h2><p>正向代理代理的对象是客户端，反向代理代理的对象是服务端</p>
]]></content>
    
    <summary type="html">
    
      反向代理为何叫反向代理？
    
    </summary>
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/categories/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>反向代理</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/jiqun/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/jiqun/反向代理/</id>
    <published>2017-04-07T03:55:17.000Z</published>
    <updated>2017-04-07T04:18:22.553Z</updated>
    
    <content type="html"><![CDATA[<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><h3 id="通常的代理服务器-内部网络对Internet的连接请求"><a href="#通常的代理服务器-内部网络对Internet的连接请求" class="headerlink" title="通常的代理服务器(内部网络对Internet的连接请求)"></a>通常的代理服务器(内部网络对Internet的连接请求)</h3><p>通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>外部网络上的主机并不会配置并使用这个代理服务器，普通代理服务器也被设计为在Internet上搜寻多个不确定的服务器,而不是针对客户机的请求访问某一个固定的服务器，因此普通的Web代理服务器不支持外部对内部网络的访问请求。</p>
<h3 id="方向代理服务器"><a href="#方向代理服务器" class="headerlink" title="方向代理服务器"></a>方向代理服务器</h3><p>当一个代理服务器代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。此时代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个标准的Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者CGI程序，都保存在内部的Web服务器上。因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了Web服务器的安全性。</p>
<p>反向代理方式和包过滤方式或普通代理方式并无冲突，因此可以在防火墙设备中同时使用这两种方式，其中反向代理用于外部网络访问内部网络时使用，正向代理或包过滤方式用于拒绝其他外部访问方式并提供内部网络对外部网络的访问能力。因此可以结合这些方式提供最佳的安全访问方式。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输得更快、更稳定。通过在网络各处放置反向代理服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>如果您的内容服务器具有必须保持安全的敏感信息，如信用卡号数据库，可在防火墙外部设置一个代理服务器作为内容服务器的替身。当外部客户机尝试访问内容服务器时，会将其送到代理服务器。实际内容位于内容服务器上，在内部受到防火墙安全保护。代理服务器位于防火墙外部，在外部客户机看来就像是内容服务器。<br>当客户机向站点提出请求时，请求将转到代理服务器。然后，代理服务器通过防火墙中的特定通路，将客户机的请求发送到内容服务器。内容服务器再通过该通道将结果回传给代理服务器。代理服务器将检索到的信息发送给客户机，好像代理服务器就是实际的内容服务器。如果内容服务器返回错误消息，代理服务器会先行截取该消息并更改标头中列出的任何URL，然后再将消息发送给客户机。如此可防止外部客户机获取内部内容服务器的重定向URL。<br>这样，代理服务器就在安全数据库和可能的恶意攻击之间提供了又一道屏障。与有权访问整个数据库的情况相对比，就算是侥幸攻击成功，作恶者充其量也仅限于访问单个事务中所涉及的信息。未经授权的用户无法访问到真正的内容服务器，因为防火墙通路只允许代理服务器有权进行访问。<br><img src="/img/反向代理服务器就像是真正的内容服务器.jpg" alt="图1 反向代理服务器就像是真正的内容服务器"></p>
<p>可以配置防火墙路由器，使其只允许特定端口上的特定服务器有权通过防火墙进行访问，而不允许其他任何机器进出。</p>
<h2 id="安全反向代理"><a href="#安全反向代理" class="headerlink" title="安全反向代理"></a>安全反向代理</h2><p>当代理服务器与其他机器之间有一个或多个连接使用安全套接字层(SSL) 协议加密数据时，即会进行安全反向代理。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>可以提供从防火墙外部代理服务器到防火墙内部安全内容服务器的加密连接。<br>可以允许客户机安全地连接到代理服务器，从而有利于安全地传输信息（如信用卡号）。<br>安全反向代理会造成各安全连接因加密数据所涉及的系统开销而变慢。但是，由于 SSL 提供了高速缓存机制，所以连接双方可以重复使用先前协商的安全参数，从而大大降低后续连接的系统开销。</p>
<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>配置安全反向代理服务器的方法有三种：</p>
<h3 id="Secure-client-to-proxy"><a href="#Secure-client-to-proxy" class="headerlink" title="Secure client to proxy"></a>Secure client to proxy</h3><p>如果未经授权的用户很少或根本没有机会访问代理服务器与内容服务器之间交换的信息，则此方案很有效。<br><img src="/img/图 2 客户机安全连接到代理服务器.jpg" alt="图 2 客户机安全连接到代理服务器"></p>
<h3 id="Secure-proxy-to-content-server"><a href="#Secure-proxy-to-content-server" class="headerlink" title="Secure proxy to content server"></a>Secure proxy to content server</h3><p>如果客户机在防火墙外部而内容服务器在防火墙内部，则此方案很有效。在此方案中，代理服务器可以充当站点之间的安全通道<br><img src="/img/图 3 代理服务器安全连接到内容服务器.jpg" alt="图 3 代理服务器安全连接到内容服务器"></p>
<h3 id="Secure-client-to-proxy-and-secure-proxy-to-content-server"><a href="#Secure-client-to-proxy-and-secure-proxy-to-content-server" class="headerlink" title="Secure client to proxy and secure proxy to content server"></a>Secure client to proxy and secure proxy to content server</h3><p>如果需要保护服务器、代理服务器和客户机三者间所交换信息的安全，则此方案很有效。在此方案中，代理服务器既可起到站点间安全通道的作用，又可增加客户机验证的安全性。<br><img src="/img/Secure client to proxy and secure proxy to content server.jpg" alt="图 4 客户机安全连接到代理服务器并且代理服务器安全连接到内容服务器"></p>
<p>除了SSL之外，代理服务器还可以使用客户机验证，这种方法要求向代理服务器提出请求的计算机提供证书（或标识表单）以核实其身份。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="标准的代理缓冲服务器"><a href="#标准的代理缓冲服务器" class="headerlink" title="标准的代理缓冲服务器"></a>标准的代理缓冲服务器</h3><p>一个标准的代理缓冲服务被用于缓存静态的网页（例如：html文件和图片文件等）到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指明代理服务器的IP地址和端口号。客户端上网时，每次都把请求送给代理服务器处理，代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发给客户端浏览器。</p>
<h3 id="透明代理缓冲服务器"><a href="#透明代理缓冲服务器" class="headerlink" title="透明代理缓冲服务器"></a>透明代理缓冲服务器</h3><p>透明代理缓冲服务和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于Linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因为不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。</p>
<h3 id="反向代理缓冲服务器"><a href="#反向代理缓冲服务器" class="headerlink" title="反向代理缓冲服务器"></a>反向代理缓冲服务器</h3><p>反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于本地WEB服务器和Internet之间，处理所有对WEB服务器的请求，阻止了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发送给用户。这种方式通过降低了向WEB服务器的请求数从而降低了WEB服务器的负载。</p>
]]></content>
    
    <summary type="html">
    
      反向代理
    
    </summary>
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/categories/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
</feed>
