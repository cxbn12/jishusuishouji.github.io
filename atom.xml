<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术随手记</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jishusuishouji.github.io/"/>
  <updated>2017-04-06T13:52:11.631Z</updated>
  <id>http://jishusuishouji.github.io/</id>
  
  <author>
    <name>技术随手记</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js如何把相对路基的url转换为绝对路径</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/js/js%E5%A6%82%E4%BD%95%E6%8A%8A%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%9F%BA%E7%9A%84url%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/js/js如何把相对路基的url转换为绝对路径/</id>
    <published>2017-04-06T13:50:53.000Z</published>
    <updated>2017-04-06T13:52:11.631Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var absolutePath = function(href) &#123;</div><div class="line">    var link = document.createElement(&quot;a&quot;);</div><div class="line">    link.href = href;</div><div class="line">    return (link.protocol+&quot;//&quot;+link.host+link.pathname+link.search+link.hash);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      js如何把相对路基的url转换为绝对路径
    
    </summary>
    
      <category term="javascript" scheme="http://jishusuishouji.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://jishusuishouji.github.io/tags/javascript/"/>
    
      <category term="js" scheme="http://jishusuishouji.github.io/tags/js/"/>
    
      <category term="相对路径" scheme="http://jishusuishouji.github.io/tags/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    
      <category term="绝对路径" scheme="http://jishusuishouji.github.io/tags/%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/shejiyuanze/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/shejiyuanze/设计模式六大原则/</id>
    <published>2017-04-05T23:43:16.000Z</published>
    <updated>2017-04-06T15:23:52.516Z</updated>
    
    <content type="html"><![CDATA[<p>开闭原则<br>单一职责原则<br>迪米特原则<br>面向对象的： 接口隔离原则<br>             依赖倒转原则<br>             里氏替换原则</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>定义：<strong>不要存在多于一个导致类变更的原因</strong>。</p>
<p>问题由来：类<code>T</code>负责两个不同的职责：职责<code>P1</code>，职责<code>P2</code>。当由于职责<code>P1</code>需求发生改变而需要修改类<code>T</code>时，有可能会导致原本运行正常的职责<code>P2</code>功能发生故障。</p>
<p>解决方案：遵循单一职责原则。分别建立两个类<code>T1</code>、<code>T2</code>，使<code>T1</code>完成职责<code>P1</code>功能，<code>T2</code>完成职责<code>P2</code>功能。这样，当修改类<code>T1</code>时，不会使职责P2发生故障风险；同理，当修改<code>T2</code>时，也不会使职责P1发生故障风险。</p>
<p>遵循单一职责原则可以避免因为修改了一个功能导致其他功能发生异常。</p>
<h3 id="职责扩散"><a href="#职责扩散" class="headerlink" title="职责扩散"></a>职责扩散</h3><p>职责扩散：因为某种原因，职责P被分化为粒度更细的职责P1和P2。<br>比如：类<code>T</code>只负责一个职责P，这样设计是符合单一职责原则的。后来由于需求变更了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类<code>T</code>分解为两个类<code>T1</code>和<code>T2</code>，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类<code>T</code>，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）</p>
<h3 id="职责扩散例子说明，用一个类描述动物呼吸这个场景："><a href="#职责扩散例子说明，用一个类描述动物呼吸这个场景：" class="headerlink" title="职责扩散例子说明，用一个类描述动物呼吸这个场景："></a>职责扩散例子说明，用一个类描述动物呼吸这个场景：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Animal&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸空气&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal animal = new Animal();</div><div class="line">        animal.breathe(&quot;牛&quot;);</div><div class="line">        animal.breathe(&quot;羊&quot;);</div><div class="line">        animal.breathe(&quot;猪&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">牛呼吸空气</div><div class="line">羊呼吸空气</div><div class="line">猪呼吸空气</div></pre></td></tr></table></figure>
<p>程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将<code>Animal</code>类细分为陆生动物类<code>Terrestrial</code>，水生动物<code>Aquatic</code>，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Terrestrial&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸空气&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Aquatic&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸水&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Terrestrial terrestrial = new Terrestrial();</div><div class="line">        terrestrial.breathe(&quot;牛&quot;);</div><div class="line">        terrestrial.breathe(&quot;羊&quot;);</div><div class="line">        terrestrial.breathe(&quot;猪&quot;);</div><div class="line">        </div><div class="line">        Aquatic aquatic = new Aquatic();</div><div class="line">        aquatic.breathe(&quot;鱼&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">牛呼吸空气</div><div class="line">羊呼吸空气</div><div class="line">猪呼吸空气</div><div class="line">鱼呼吸水</div></pre></td></tr></table></figure></p>
<p>我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类<code>Animal</code>来达成目的虽然违背了单一职责原则，但花销却小得多，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Animal&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        if(&quot;鱼&quot;.equals(animal))&#123;</div><div class="line">            System.out.println(animal+&quot;呼吸水&quot;);</div><div class="line">        &#125;else&#123;</div><div class="line">            System.out.println(animal+&quot;呼吸空气&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal animal = new Animal();</div><div class="line">        animal.breathe(&quot;牛&quot;);</div><div class="line">        animal.breathe(&quot;羊&quot;);</div><div class="line">        animal.breathe(&quot;猪&quot;);</div><div class="line">        animal.breathe(&quot;鱼&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这种修改方式要简单得多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改<code>Animal</code>类的<code>breathe</code>方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。(不要认为这是不可能的，这是绝对可能的，修改代码本来就应该认为是极其危险的，你可以扩展但是最好不要修改，修改了就一定要好好测试！)这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Animal&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸空气&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void breathe2(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸水&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal animal = new Animal();</div><div class="line">        animal.breathe(&quot;牛&quot;);</div><div class="line">        animal.breathe(&quot;羊&quot;);</div><div class="line">        animal.breathe(&quot;猪&quot;);</div><div class="line">        animal.breathe2(&quot;鱼&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一种呢？这需要根据实际情况来确定。原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；</p>
<p>例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类要复杂得多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。</p>
<h3 id="遵循单一职责原的优点有："><a href="#遵循单一职责原的优点有：" class="headerlink" title="遵循单一职责原的优点有："></a>遵循单一职责原的优点有：</h3><ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>降低变更引起的风险，变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<p>需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>在1988年麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。</p>
<p>定义1：如果对每一个类型为<code>T1</code>的对象<code>o1</code>，都有类型为<code>T2</code>的对象<code>o2</code>,使得在程序中所有的对象<code>o1</code>都代换成<code>o2</code>时，程序P的行为没有发生变化，那么类型<code>T2</code>是类型<code>T1</code>的子类型。</p>
<p>定义2：所有引用基类的地方必须能透明地使用其子类的对象。</p>
<p>问题由来：有一功能P1，由类<code>A</code>完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类<code>A</code>的子类<code>B</code>来完成，则子类<code>B</code>在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p>
<p>解决方案：当使用继承时，遵循里氏替换原则。类<code>B</code>继承类<code>A</code>时，除添加新的方法完成新增功能P2外，尽量不要重写父类<code>A</code>的方法，也尽量不要重载父类<code>A</code>的方法。</p>
<p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p>
<p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>一个两数相减的功能由类A来负责。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">    public int func1(int a, int b)&#123;</div><div class="line">        return a-b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        A a = new A();</div><div class="line">        System.out.println(&quot;100-50=&quot;+a.func1(100, 50));</div><div class="line">        System.out.println(&quot;100-80=&quot;+a.func1(100, 80));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">100-50=50</div><div class="line"></div><div class="line">100-80=20</div></pre></td></tr></table></figure></p>
<p>后来，需要增加一个新的功能：完成两数相加，然后再与100求和，由类<code>B</code>来负责。即类<code>B</code>需要完成两个功能：</p>
<ul>
<li>两数相减。</li>
<li>两数相加，然后再加100。</li>
</ul>
<p>由于类<code>A</code>已经实现了第一个功能，所以类<code>B</code>继承类<code>A</code>后，只需要再完成第二个功能就可以了，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class B extends A&#123;</div><div class="line">    public int func1(int a, int b)&#123;</div><div class="line">        return a+b;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int func2(int a, int b)&#123;</div><div class="line">        return func1(a,b)+100;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        B b = new B();</div><div class="line">        System.out.println(&quot;100-50=&quot;+b.func1(100, 50));</div><div class="line">        System.out.println(&quot;100-80=&quot;+b.func1(100, 80));</div><div class="line">        System.out.println(&quot;100+20+100=&quot;+b.func2(100, 20));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类<code>B</code>完成后，运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">100-50=150</div><div class="line">100-80=180</div><div class="line">100+20+100=220</div></pre></td></tr></table></figure></p>
<p>我们发现原本运行正常的相减功能发生了错误。原因就是类<code>B</code>在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类<code>B</code>重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类<code>A</code>完成的功能，换成子类<code>B</code>之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p>
<p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
<li>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？</li>
</ul>
<p>后果就是：你写的代码出问题的几率将会大大增加。</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>定义：<br>高层模块不应该依赖低层模块，二者都应该依赖其抽象；<br>抽象不应该依赖细节；细节应该依赖抽象。</p>
<p>问题由来：类<code>A</code>直接依赖类<code>B</code>，假如要将类<code>A</code>改为依赖类<code>C</code>，则必须通过修改类<code>A</code>的代码来达成。这种场景下，类<code>A</code>一般是高层模块，负责复杂的业务逻辑；类<code>B</code>和类<code>C</code>是低层模块，负责基本的原子操作；假如修改类<code>A</code>，会给程序带来不必要的风险。</p>
<p>解决方案：将类<code>A</code>修改为依赖接口<code>I</code>，类<code>B</code>和类<code>C</code>各自实现接口<code>I</code>，类<code>A</code>通过接口<code>I</code>间接与类<code>B</code>或者类<code>C</code>发生联系，则会大大降低修改类<code>A</code>的几率。</p>
<p>依赖倒置原则基于这样一个事实：<strong>相对于细节的多变性，抽象的东西要稳定得多。</strong>以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定得多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把细节的任务交给他们的实现类去完成。</p>
<p>依赖倒置原则的核心思想是面向接口编程。<br>Spring Ioc的好处在小项目是体会不到的，当你的项目大了，你就能体会到了。比如有一个项目有30多个maven子模块，在某个子模块中你根本就不知道服务层注入的到底是那个对象，你只知道那些接口，这样接口的实现可以随意变动，另一个人不会影响到你。</p>
<p>场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Book&#123;</div><div class="line">    public String getContent()&#123;</div><div class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Mother&#123;</div><div class="line">    public void narrate(Book book)&#123;</div><div class="line">        System.out.println(&quot;妈妈开始讲故事&quot;);</div><div class="line">        System.out.println(book.getContent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Mother mother = new Mother();</div><div class="line">        mother.narrate(new Book());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">妈妈开始讲故事</div><div class="line">很久很久以前有一个阿拉伯的故事……</div></pre></td></tr></table></figure></p>
<p>运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Newspaper&#123;</div><div class="line">    public String getContent()&#123;</div><div class="line">        return &quot;林书豪38+7领导尼克斯击败湖人……&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改<code>Mother</code>才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改<code>Mother</code>，这显然不是好的设计。原因就是<code>Mother</code>与<code>Book</code>之间的耦合性太高了，必须降低他们之间的耦合度才行。</p>
<p>我们引入一个抽象的接口<code>IReader</code>。读物，只要是带字的都属于读物：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface IReader&#123;</div><div class="line">    public String getContent();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Mother</code>类与接口<code>IReader</code>发生依赖关系，而<code>Book</code>和<code>Newspaper</code>都属于读物的范畴，他们各自都去实现<code>IReader</code>接口，这样就符合依赖倒置原则了，代码修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Newspaper implements IReader &#123;</div><div class="line">    public String getContent()&#123;</div><div class="line">        return &quot;林书豪17+9助尼克斯击败老鹰……&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Book implements IReader&#123;</div><div class="line">    public String getContent()&#123;</div><div class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Mother&#123;</div><div class="line">    public void narrate(IReader reader)&#123;</div><div class="line">        System.out.println(&quot;妈妈开始讲故事&quot;);</div><div class="line">        System.out.println(reader.getContent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Mother mother = new Mother();</div><div class="line">        mother.narrate(new Book());</div><div class="line">        mother.narrate(new Newspaper());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">妈妈开始讲故事</div><div class="line">很久很久以前有一个阿拉伯的故事……</div><div class="line">妈妈开始讲故事</div><div class="line">林书豪17+9助尼克斯击败老鹰……</div></pre></td></tr></table></figure></p>
<p>这样修改后，无论以后怎样扩展<code>Client</code>类，都不需要再修改<code>Mother</code>类了。这只是一个简单的例子，实际情况中，代表高层模块的<code>Mother</code>类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p>
<p>采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本<code>Mother</code>类与<code>Book</code>类直接耦合时，<code>Mother</code>类必须等<code>Book</code>类编码完成后才可以进行编码，因为<code>Mother</code>类依赖于<code>Book</code>类。修改后的程序则可以同时开工，互不影响，因为<code>Mother</code>与<code>Book</code>类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。</p>
<p>传递依赖关系有三种方式，以上的例子中使用的方法是<strong>接口传递</strong>，另外还有两种传递方式：<strong>构造方法传递</strong>和<strong>setter方法传递</strong>，相信用过Spring框架的，对依赖的传递方式一定不会陌生。</p>
<p>在实际编程中，我们一般需要做到如下3点：</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。</li>
<li>变量的声明类型尽量是抽象类或接口。</li>
<li>使用继承时遵循里氏替换原则。</li>
</ul>
<p>依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>定义：<br>客户端不应该依赖它不需要的接口；<br>一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>问题由来：类<code>A</code>通过接口<code>I</code>依赖类<code>B</code>，类<code>C</code>通过接口<code>I</code>依赖类<code>D</code>，如果接口<code>I</code>对于类<code>A</code>和类<code>C</code>来说不是最小接口，则类<code>B</code>和类<code>D</code>必须去实现他们不需要的方法。</p>
<p>解决方案：将臃肿的接口<code>I</code>拆分为独立的几个接口，类<code>A</code>和类<code>C</code>分别与它们需要的接口建立依赖关系。也就是采用接口隔离原则。</p>
<p>举例来说明接口隔离原则：<br><img src="/img/未遵循接口隔离原则的设计.jpg" alt="未遵循接口隔离原则的设计"></p>
<p>这个图的意思是：类<code>A</code>依赖接口<code>I</code>中的方法1、方法2、方法3，类<code>B</code>是对类<code>A</code>依赖的实现。类<code>C</code>依赖接口<code>I</code>中的方法1、方法4、方法5，类<code>D</code>是对类<code>C</code>依赖的实现。对于类<code>B</code>和类<code>D</code>来说，虽然它们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口<code>I</code>，所以也必须要实现这些用不到的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">interface I &#123;</div><div class="line">    public void method1();</div><div class="line">    public void method2();</div><div class="line">    public void method3();</div><div class="line">    public void method4();</div><div class="line">    public void method5();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">    public void depend1(I i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I i)&#123;</div><div class="line">        i.method2();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I i)&#123;</div><div class="line">        i.method3();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class B implements I&#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method2() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I的方法2&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method3() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I的方法3&quot;);</div><div class="line">    &#125;</div><div class="line">    //对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，</div><div class="line">    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</div><div class="line">    public void method4() &#123;&#125;</div><div class="line">    public void method5() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class C&#123;</div><div class="line">    public void depend1(I i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I i)&#123;</div><div class="line">        i.method4();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I i)&#123;</div><div class="line">        i.method5();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class D implements I&#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    //对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，</div><div class="line">    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</div><div class="line">    public void method2() &#123;&#125;</div><div class="line">    public void method3() &#123;&#125;</div><div class="line"></div><div class="line">    public void method4() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I的方法4&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method5() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I的方法5&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        A a = new A();</div><div class="line">        a.depend1(new B());</div><div class="line">        a.depend2(new B());</div><div class="line">        a.depend3(new B());</div><div class="line">        </div><div class="line">        C c = new C();</div><div class="line">        c.depend1(new D());</div><div class="line">        c.depend2(new D());</div><div class="line">        c.depend3(new D());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口<code>I</code>进行拆分。在这里我们将原有的接口<code>I</code>拆分为三个接口，拆分后的设计如图2所示：</p>
<p><img src="/img/图2 遵循接口隔离原则的设计.jpg" alt="图2 遵循接口隔离原则的设计"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> interface I1 &#123;</div><div class="line">    public void method1();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface I2 &#123;</div><div class="line">    public void method2();</div><div class="line">    public void method3();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface I3 &#123;</div><div class="line">    public void method4();</div><div class="line">    public void method5();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">    public void depend1(I1 i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I2 i)&#123;</div><div class="line">        i.method2();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I2 i)&#123;</div><div class="line">        i.method3();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class B implements I1, I2&#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I1的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method2() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I2的方法2&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method3() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I2的方法3&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class C&#123;</div><div class="line">    public void depend1(I1 i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I3 i)&#123;</div><div class="line">        i.method4();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I3 i)&#123;</div><div class="line">        i.method5();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class D implements I1, I3&#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I1的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method4() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I3的方法4&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method5() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I3的方法5&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<p>说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p>
<p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<ul>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
<li>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</li>
</ul>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><p>定义：一个对象应该对其他对象保持最少的了解。</p>
<p>问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p>解决方案：尽量降低类与类之间的耦合。</p>
<p>自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</p>
<p>迪米特法则又叫最少知道原则，最早是在1987年由美国Northeastern University的Ian Holland提出。通俗的来讲，就是一个类对自己依赖的类知道的越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地的将逻辑封装在类的内部，对外除了提供的public方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，陌生的类最好不要作为局部变量的形式出现在类的内部。</p>
<p>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。</p>
<p> //总公司员工<br>class Employee{<br>    private String id;<br>    public void setId(String id){<br>        this.id = id;<br>    }<br>    public String getId(){<br>        return id;<br>    }<br>}</p>
<p>//分公司员工<br>class SubEmployee{<br>    private String id;<br>    public void setId(String id){<br>        this.id = id;<br>    }<br>    public String getId(){<br>        return id;<br>    }<br>}</p>
<p>class SubCompanyManager{<br>    public List<subemployee> getAllEmployee(){<br>        List<subemployee> list = new ArrayList<subemployee>();<br>        for(int i=0; i&lt;100; i++){<br>            SubEmployee emp = new SubEmployee();<br>            //为分公司人员按顺序分配一个ID<br>            emp.setId(“分公司”+i);<br>            list.add(emp);<br>        }<br>        return list;<br>    }<br>}</subemployee></subemployee></subemployee></p>
<p>class CompanyManager{</p>
<pre><code>public List&lt;Employee&gt; getAllEmployee(){
    List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();
    for(int i=0; i&lt;30; i++){
        Employee emp = new Employee();
        //为总公司人员按顺序分配一个ID
        emp.setId(&quot;总公司&quot;+i);
        list.add(emp);
    }
    return list;
}

public void printAllEmployee(SubCompanyManager sub){
    List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();
    for(SubEmployee e:list1){
        System.out.println(e.getId());
    }

    List&lt;Employee&gt; list2 = this.getAllEmployee();
    for(Employee e:list2){
        System.out.println(e.getId());
    }
}
</code></pre><p>}</p>
<p>public class Client{<br>    public static void main(String[] args){<br>        CompanyManager e = new CompanyManager();<br>        e.printAllEmployee(new SubCompanyManager());<br>    }<br>}<br>现在这个设计的主要问题出在CompanyManager中，根据迪米特法则，只与直接的朋友发生通信，而SubEmployee类并不是CompanyManager类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:</p>
<p>class SubCompanyManager{<br>    public List<subemployee> getAllEmployee(){<br>        List<subemployee> list = new ArrayList<subemployee>();<br>        for(int i=0; i<100; i++){="" subemployee="" emp="new" subemployee();="" 为分公司人员按顺序分配一个id="" emp.setid("分公司"+i);="" list.add(emp);="" }="" return="" list;="" public="" void="" printemployee(){="" list<subemployee=""> list = this.getAllEmployee();<br>        for(SubEmployee e:list){<br>            System.out.println(e.getId());<br>        }<br>    }<br>}</100;></subemployee></subemployee></subemployee></p>
<p>class CompanyManager{<br>    public List<employee> getAllEmployee(){<br>        List<employee> list = new ArrayList<employee>();<br>        for(int i=0; i&lt;30; i++){<br>            Employee emp = new Employee();<br>            //为总公司人员按顺序分配一个ID<br>            emp.setId(“总公司”+i);<br>            list.add(emp);<br>        }<br>        return list;<br>    }</employee></employee></employee></p>
<pre><code>public void printAllEmployee(SubCompanyManager sub){
    sub.printEmployee();
    List&lt;Employee&gt; list2 = this.getAllEmployee();
    for(Employee e:list2){
        System.out.println(e.getId());
    }
}
</code></pre><p>}<br>修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。</p>
<p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分的使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p>
<p>设计模式六大原则（6）：开闭原则<br>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
<p>问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p>
<p>解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。</p>
<p>在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。</p>
<p>其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p>
<p>说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。</p>
<p>最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板的遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。我们用一幅图来说明一下。</p>
<p>图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守的合理的话，这个点应该落在红色的同心圆内部；如果遵守的差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。</p>
<p>在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。</p>
<p>到这里，设计模式的六大原则就写完了。主要参考书籍有《设计模式》《设计模式之禅》《大话设计模式》以及网上一些零散的文章，但主要内容主要还是我本人对这六个原则的感悟。写出来的目的一方面是对这六项原则系统地整理一下，一方面也与广大的网友分享，因为设计模式对编程人员来说，的确非常重要。正如有句话叫做一千个读者眼中有一千个哈姆雷特，如果大家对这六项原则的理解跟我有所不同，欢迎留言，大家共同探讨。</p>
<p>分享到</p>
]]></content>
    
    <summary type="html">
    
      设计模式六大原则
    
    </summary>
    
      <category term="设计原则" scheme="http://jishusuishouji.github.io/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="设计原则" scheme="http://jishusuishouji.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java 类的加载机制</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/java/Java_%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/java/Java_类的加载机制/</id>
    <published>2017-04-05T23:05:01.000Z</published>
    <updated>2017-04-05T23:38:16.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>类的加载:将类的<code>.class</code>文件的二进制数据读入到内存中，将其放在方法区内，然后在堆区创建一个<code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的<code>Class</code>对象，<code>Class</code>对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了<code>.class</code>文件缺失或存在错误，类加载器在程序首次主动使用该类时才报告错误（<code>LinkageError</code>错误）,否则如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p>
<h2 id="加载-class文件的方式"><a href="#加载-class文件的方式" class="headerlink" title="加载.class文件的方式"></a>加载.class文件的方式</h2><p>– 从本地系统中直接加载<br>– 通过网络下载<code>.class</code>文件<br>– 从zip，jar等归档文件中加载<code>.class</code>文件<br>– 从专有数据库中提取<code>.class</code>文件<br>– 将Java源文件动态编译为<code>.class</code>文件</p>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<h3 id="加载：查找并加载类的二进制数据"><a href="#加载：查找并加载类的二进制数据" class="headerlink" title="加载：查找并加载类的二进制数据"></a>加载：查找并加载类的二进制数据</h3><p>加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：<br>1、通过一个类的全限定名来获取其定义的二进制字节流。<br>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>3、在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口。</p>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证：确保被加载的类的正确性"><a href="#验证：确保被加载的类的正确性" class="headerlink" title="验证：确保被加载的类的正确性"></a>验证：确保被加载的类的正确性</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<ol>
<li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证：对字节码描述的信息进行语义分析（注意：对比<code>javac</code>编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有除了<code>java.lang.Object</code>之外的父类。</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：确保解析动作能正确执行。</li>
</ol>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h4 id="准备：为类的静态变量分配内存，并将其初始化为默认值"><a href="#准备：为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="准备：为类的静态变量分配内存，并将其初始化为默认值"></a>准备：为类的静态变量分配内存，并将其初始化为默认值</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：<br>1、这时候进行内存分配的仅包括类变量（<code>static</code>），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。<br>2、这里所设置的初始值通常情况下是数据类型默认的零值（如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等），而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为：<code>public static int value = 3</code>；<br>那么变量<code>value</code>在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何Java方法，而把<code>value</code>赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把<code>value</code>赋值为3的动作将在初始化阶段才会执行。</p>
<p>这里还需要注意如下几点：</p>
<p>· 对基本数据类型来说，对于类变量（<code>static</code>）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。<br>· 对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被<code>final</code>修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。<br>· 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。<br>· 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。<br>3、如果类字段的字段属性表中存在<code>ConstantValue</code>属性，即同时被<code>final</code>和<code>static</code>修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p>
<p>假设上面的类变量value被定义为： <code>public static final int value = 3</code>；</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</p>
<h4 id="解析：把类中的符号引用转换为直接引用"><a href="#解析：把类中的符号引用转换为直接引用" class="headerlink" title="解析：把类中的符号引用转换为直接引用"></a>解析：把类中的符号引用转换为直接引用</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<p>①声明类变量是指定初始值</p>
<p>②使用静态代码块为类变量指定初始值</p>
<h4 id="JVM初始化步骤"><a href="#JVM初始化步骤" class="headerlink" title="JVM初始化步骤"></a>JVM初始化步骤</h4><p>1、假如这个类还没有被加载和连接，则程序先加载并连接该类<br>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类<br>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p>
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：<br>– 创建类的实例，也就是new的方式<br>– 访问某个类或接口的静态变量，或者对该静态变量赋值<br>– 调用类的静态方法<br>– 反射（如Class.forName(“com.shengsiyuan.Test”)）<br>– 初始化某个类的子类，则其父类也会被初始化<br>– Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</p>
<h3 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h3><p>•在如下几种情况下，Java虚拟机将结束生命周期</p>
<p>– 执行了System.exit()方法<br>– 程序正常执行结束<br>– 程序在执行过程中遇到了异常或错误而异常终止<br>– 由于操作系统出现错误而导致Java虚拟机进程终止</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ClassLoaderTest &#123;</div><div class="line">     public static void main(String[] args) &#123;</div><div class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</div><div class="line">        System.out.println(loader);</div><div class="line">        System.out.println(loader.getParent());</div><div class="line">        System.out.println(loader.getParent().getParent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后，输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sun.misc.Launcher$AppClassLoader@64fef26a</div><div class="line">sun.misc.Launcher$ExtClassLoader@1ddd40f3</div><div class="line">null</div></pre></td></tr></table></figure></p>
<p>从上面的结果可以看出，并没有获取到<code>ExtClassLoader</code>的父<code>Loader</code>，原因是Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</p>
<p>这几种类加载器的层次关系如下图所示：<br><img src="/img/类加载器的层次关系.jpg" alt="类加载器的层次关系"><br>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。<br>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<ul>
<li><p>启动类加载器：Bootstrap ClassLoader，负责加载存放在<code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被<code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p>
</li>
<li><p>扩展类加载器：Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>DK\jre\lib\ext</code>目录中，或者由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器：Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<p>1）在执行非置信代码之前，自动验证数字签名。<br>2）动态地创建符合用户特定需要的定制化构建类。<br>3）从特定的场所取得java class，例如数据库中和网络中。</p>
<h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><p>•全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入<br>•父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类<br>•缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
<h2 id="4、类的加载"><a href="#4、类的加载" class="headerlink" title="4、类的加载"></a>4、类的加载</h2><p>类加载有三种方式：</p>
<p>1、命令行启动应用时候由JVM初始化加载<br>2、通过<code>Class.forName()</code>方法动态加载<br>3、通过<code>ClassLoader.loadClass()</code>方法动态加载</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class loaderTest &#123; </div><div class="line">        public static void main(String[] args) throws ClassNotFoundException &#123; </div><div class="line">                ClassLoader loader = HelloWorld.class.getClassLoader(); </div><div class="line">                System.out.println(loader); </div><div class="line">                //使用ClassLoader.loadClass()来加载类，不会执行初始化块 </div><div class="line">                loader.loadClass(&quot;Test2&quot;); </div><div class="line">                //使用Class.forName()来加载类，默认会执行初始化块 </div><div class="line">                Class.forName(&quot;Test2&quot;); </div><div class="line">                //使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </div><div class="line">                Class.forName(&quot;Test2&quot;, false, loader); </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>demo类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Test2 &#123; </div><div class="line">        static &#123; </div><div class="line">                System.out.println(&quot;静态初始化块执行了！&quot;); </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分别切换加载方式，会有不同的输出结果。</p>
<h3 id="Class-forName-和ClassLoader-loadClass-区别"><a href="#Class-forName-和ClassLoader-loadClass-区别" class="headerlink" title="Class.forName()和ClassLoader.loadClass()区别"></a>Class.forName()和ClassLoader.loadClass()区别</h3><p><code>Class.forName()</code>：将类的<code>.class</code>文件加载到jvm中之外，还会对类进行解释，执行类中的static块；<br><code>ClassLoader.loadClass()</code>：只干一件事情，就是将<code>.class</code>文件加载到jvm中，不会执行static中的内容,只有在new Instance才会去执行static块。</p>
<p>注：<br><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了new Instance()方法采用调用构造函数，创建类的对象 。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p>双亲委派机制:<br>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。<br>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。<br>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；<br>4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p>
<p>ClassLoader源码分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException &#123;</div><div class="line">            return loadClass(name, false);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException &#123;</div><div class="line">            // 首先判断该类型是否已经被加载</div><div class="line">            Class c = findLoadedClass(name);</div><div class="line">            if (c == null) &#123;</div><div class="line">                //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</div><div class="line">                try &#123;</div><div class="line">                    if (parent != null) &#123;</div><div class="line">                         //如果存在父类加载器，就委派给父类加载器加载</div><div class="line">                        c = parent.loadClass(name, false);</div><div class="line">                    &#125; else &#123;</div><div class="line">                    //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</div><div class="line">                        c = findBootstrapClass0(name);</div><div class="line">                    &#125;</div><div class="line">                &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                 // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</div><div class="line">                    c = findClass(name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (resolve) &#123;</div><div class="line">                resolveClass(c);</div><div class="line">            &#125;</div><div class="line">            return c;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>双亲委派模型意义：</p>
<p>-系统类防止内存中出现多份同样的字节码<br>-保证Java程序安全稳定运行</p>
<h2 id="6、自定义类加载器"><a href="#6、自定义类加载器" class="headerlink" title="6、自定义类加载器"></a>6、自定义类加载器</h2><p>应用是通过网络来传输Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自<code>ClassLoader</code>类，从上面对loadClass方法来分析来看，我们只需要重写<code>findClass</code> 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">import java.io.*;</div><div class="line"> </div><div class="line">public class MyClassLoader extends ClassLoader &#123;</div><div class="line"> </div><div class="line">    private String root;</div><div class="line"> </div><div class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</div><div class="line">        byte[] classData = loadClassData(name);</div><div class="line">        if (classData == null) &#123;</div><div class="line">            throw new ClassNotFoundException();</div><div class="line">        &#125; else &#123;</div><div class="line">            return defineClass(name, classData, 0, classData.length);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    private byte[] loadClassData(String className) &#123;</div><div class="line">        String fileName = root + File.separatorChar</div><div class="line">                + className.replace(&apos;.&apos;, File.separatorChar) + &quot;.class&quot;;</div><div class="line">        try &#123;</div><div class="line">            InputStream ins = new FileInputStream(fileName);</div><div class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</div><div class="line">            int bufferSize = 1024;</div><div class="line">            byte[] buffer = new byte[bufferSize];</div><div class="line">            int length = 0;</div><div class="line">            while ((length = ins.read(buffer)) != -1) &#123;</div><div class="line">                baos.write(buffer, 0, length);</div><div class="line">            &#125;</div><div class="line">            return baos.toByteArray();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public String getRoot() &#123;</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void setRoot(String root) &#123;</div><div class="line">        this.root = root;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static void main(String[] args)  &#123;</div><div class="line"> </div><div class="line">        MyClassLoader classLoader = new MyClassLoader();</div><div class="line">        classLoader.setRoot(&quot;E:\\temp&quot;);</div><div class="line"> </div><div class="line">        Class&lt;?&gt; testClass = null;</div><div class="line">        try &#123;</div><div class="line">            testClass = classLoader.loadClass(&quot;com.neo.classloader.Test2&quot;);</div><div class="line">            Object object = testClass.newInstance();</div><div class="line">            System.out.println(object.getClass().getClassLoader());</div><div class="line">        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p>
<p>1、这里传递的文件名需要是类的全限定性名称，即com.paddx.test.classloading.Test格式的，因为 defineClass 方法是按这种格式进行处理的。</p>
<p>2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</p>
<p>3、这类Test 类本身可以被 AppClassLoader 类加载，因此我们不能把 com/paddx/test/classloading/Test.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由AppClassLoader 加载，而不会通过我们自定义类加载器来加载。</p>
]]></content>
    
    <summary type="html">
    
      Java 类的加载机制
    
    </summary>
    
      <category term="jav" scheme="http://jishusuishouji.github.io/categories/jav/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>启动ActiveMQ的Broker</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/activemq/%E5%90%AF%E5%8A%A8ActiveMQ%E7%9A%84Broker/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/activemq/启动ActiveMQ的Broker/</id>
    <published>2017-04-05T22:57:20.000Z</published>
    <updated>2017-04-05T23:56:22.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、直接运行安装目录的bin-activemq-bat"><a href="#1、直接运行安装目录的bin-activemq-bat" class="headerlink" title="1、直接运行安装目录的bin\activemq.bat"></a>1、直接运行安装目录的<code>bin\activemq.bat</code></h2><h2 id="2、可以通过在应用程序中以编码的方式启动broker，例如："><a href="#2、可以通过在应用程序中以编码的方式启动broker，例如：" class="headerlink" title="2、可以通过在应用程序中以编码的方式启动broker，例如："></a>2、可以通过在应用程序中以编码的方式启动broker，例如：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BrokerService broker =new BrokerService();  </div><div class="line">broker.setBrokerName(&quot;testName&quot;);//如果启动多个Broker时，必须为Broker设置一个名称  </div><div class="line">broker.addConnector(&quot;tcp://localhost:61616&quot;);  </div><div class="line">broker.start();</div></pre></td></tr></table></figure>
<h2 id="3、可以通过BrokerFactory来创建broker，例如："><a href="#3、可以通过BrokerFactory来创建broker，例如：" class="headerlink" title="3、可以通过BrokerFactory来创建broker，例如："></a>3、可以通过<code>BrokerFactory</code>来创建<code>broker</code>，例如：</h2><pre><code>BrokerService broker =BrokerFactory.createBroker(new URI(&quot;broker:tcp://localhost:61616&quot;));  
broker.start();  
</code></pre><h2 id="4、测代码"><a href="#4、测代码" class="headerlink" title="4、测代码"></a>4、测代码</h2><pre><code>import java.net.URI;  
import org.apache.activemq.broker.BrokerFactory;  
import org.apache.activemq.broker.BrokerService;  

/** 
 * 启动ActiveMQ的代理Broker 
 */  
public class RunningBroker {  
    public static void main(String[] args){  
        try {  
            codeByRunning() ;  //启动Broker  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  

    /** 
     * 应用程序中以编码的方式启动 
     */  
    public static void codeByRunning() throws Exception{  
        BrokerService broker =new BrokerService();  
        broker.setBrokerName(&quot;testName&quot;);//如果启动多个Broker时，必须为Broker设置一个名称  
        broker.addConnector(&quot;tcp://localhost:61616&quot;);  
        broker.start();  
    }  

    /** 
     * 以BrokerFactory的方式启动 
     */  
    public static void factoryByRunning()throws Exception{  
        BrokerService broker =BrokerFactory.createBroker(new URI(&quot;broker:tcp://localhost:61616&quot;));  
        broker.start();  
    }  
}
</code></pre>]]></content>
    
    <summary type="html">
    
      启动ActiveMQ的Broker
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActiveMQ/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ实现负载均衡+高可用部署方案</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/activemq/ActiveMQ%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1_%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/activemq/ActiveMQ实现负载均衡_高可用部署方案/</id>
    <published>2017-04-05T22:29:04.000Z</published>
    <updated>2017-04-05T22:55:23.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、架构和技术介绍"><a href="#一、架构和技术介绍" class="headerlink" title="一、架构和技术介绍"></a>一、架构和技术介绍</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>ActiveMQ完全支持JMS1.1和J2EE 1.4规范的JMS Provider实现。</p>
<h3 id="2、activemq的特性"><a href="#2、activemq的特性" class="headerlink" title="2、activemq的特性"></a>2、activemq的特性</h3><ol>
<li>多种语言和协议编写客户端。语言: Java, C, C++, C#, Ruby, Perl, Python,PHP。应用协议: OpenWire,Stomp REST,WS Notification,XMPP,AMQP</li>
<li>完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务)</li>
<li>对Spring的支持,ActiveMQ可以很容易内嵌到使用Spring的系统里面去,而且也支持Spring2.0的特性</li>
<li>通过了常见J2EE服务器(如 Geronimo,JBoss 4, GlassFish,WebLogic)的测试,其中通过JCA 1.5 resourceadaptors的配置,可以让ActiveMQ可以自动地部署到任何兼容J2EE1.4商业服务器上</li>
<li>支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li>
<li>支持通过JDBC和journal提供高速的消息持久化</li>
<li>从设计上保证了高性能的集群,客户端-服务器,点对点</li>
<li>支持Ajax</li>
<li>支持与Axis的整合</li>
<li>可以很容易得调用内嵌JMS provider,进行测试</li>
</ol>
<h3 id="3、下载和安装ActiveMQ"><a href="#3、下载和安装ActiveMQ" class="headerlink" title="3、下载和安装ActiveMQ"></a>3、下载和安装ActiveMQ</h3><h4 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h4><h4 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h4><p>如果是在windows系统中运行，可以直接解压apache-activemq-5.9.0-bin.zip，并运行bin目录下的activemq.bat文件，此时使用的是默认的服务端口：61616和默认的console端口：8161。</p>
<p>如果是在linux或unix下运行，在bin目录下执行命令：<code>./activemq setup</code></p>
<h4 id="3、修改ActiveMQ的服务端口和console端口"><a href="#3、修改ActiveMQ的服务端口和console端口" class="headerlink" title="3、修改ActiveMQ的服务端口和console端口"></a>3、修改ActiveMQ的服务端口和console端口</h4><p>A、修改服务端口：打开<code>conf/activemq.xml</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> &lt;transportConnectors&gt;</div><div class="line">    &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://10.42.220.72:61618&quot;discoveryUri=&quot;multicast://default&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure></p>
<p>B、修改console的地址和端口:打开<code>conf/jetty.xml</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   &lt;bean id=&quot;jettyPort&quot;class=&quot;org.apache.activemq.web.WebConsolePort&quot;init-method=&quot;start&quot;&gt;</div><div class="line">      &lt;property name=&quot;port&quot; value=&quot;8162&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h4 id="4、通过客户端代码试用ActiveMQ"><a href="#4、通过客户端代码试用ActiveMQ" class="headerlink" title="4、通过客户端代码试用ActiveMQ"></a>4、通过客户端代码试用ActiveMQ</h4><p>需要提前将activemq解压包中的lib目录下的相关包引入到工程中，再进行如下编码：</p>
<h5 id="1、发送端的代码："><a href="#1、发送端的代码：" class="headerlink" title="1、发送端的代码："></a>1、发送端的代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">importjavax.jms.Connection;</div><div class="line">importjavax.jms.ConnectionFactory;</div><div class="line">importjavax.jms.DeliveryMode;</div><div class="line">importjavax.jms.Destination;</div><div class="line">importjavax.jms.MessageProducer;</div><div class="line">importjavax.jms.Session;</div><div class="line">importjavax.jms.TextMessage;</div><div class="line">importorg.apache.activemq.ActiveMQConnection;</div><div class="line">importorg.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"></div><div class="line">publicclass Sender &#123;</div><div class="line">    private static finalint SEND_NUMBER = 5;</div><div class="line"></div><div class="line">    publicstaticvoid main(String[] args) &#123;</div><div class="line">        // ConnectionFactory：连接工厂，JMS用它创建连接</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        // Connection：JMS客户端到JMS Provider的连接</div><div class="line">        Connection connection = null;</div><div class="line">        // Session：一个发送或接收消息的线程</div><div class="line">        Session session;</div><div class="line">        // Destination：消息的目的地;消息发送给谁.</div><div class="line">        Destination destination;</div><div class="line">        // MessageProducer：消息发送者</div><div class="line">        MessageProducer producer;</div><div class="line">        TextMessage message;</div><div class="line">    </div><div class="line">        //构造ConnectionFactory实例对象，此处采用ActiveMq的实现jar</div><div class="line">        connectionFactory = new ActiveMQConnectionFactory(</div><div class="line">                ActiveMQConnection.DEFAULT_USER,</div><div class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</div><div class="line">                &quot;failover:(tcp://10.42.220.72:61617,tcp://10.42.220.72:61618)&quot;);</div><div class="line">        try &#123;</div><div class="line">            //构造从工厂得到连接对象</div><div class="line">            connection =connectionFactory.createConnection();</div><div class="line">            //启动</div><div class="line">            connection.start();</div><div class="line">            //获取操作连接</div><div class="line">            session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);</div><div class="line">            //获取session</div><div class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</div><div class="line">            //得到消息生成者【发送者】</div><div class="line">            producer =session.createProducer(destination);</div><div class="line">            //设置不持久化，此处学习，实际根据项目决定</div><div class="line">            producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</div><div class="line">            //构造消息，此处写死，项目就是参数，或者方法获取</div><div class="line">            sendMessage(session, producer);</div><div class="line">            session.commit();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (null != connection)</div><div class="line">                    connection.close();</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    publicstaticvoid sendMessage(Session session,MessageProducer producer)</div><div class="line">            throws Exception &#123;</div><div class="line">        for (int i = 1; i &lt;=SEND_NUMBER; i++) &#123;</div><div class="line">            TextMessage message = session</div><div class="line">                    .createTextMessage(&quot;ActiveMq发送的消息&quot; + i);</div><div class="line">            //发送消息到目的地方</div><div class="line">            System.out.println(&quot;发送消息：&quot; + &quot;ActiveMq 发送的消息&quot; + i);</div><div class="line">            producer.send(message);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2、接收端代码："><a href="#2、接收端代码：" class="headerlink" title="2、接收端代码："></a>2、接收端代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">importjavax.jms.Connection;</div><div class="line">importjavax.jms.ConnectionFactory;</div><div class="line">importjavax.jms.Destination;</div><div class="line">importjavax.jms.MessageConsumer;</div><div class="line">importjavax.jms.Session;</div><div class="line">importjavax.jms.TextMessage;</div><div class="line">importorg.apache.activemq.ActiveMQConnection;</div><div class="line">importorg.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"> </div><div class="line"></div><div class="line">publicclass Receive &#123;</div><div class="line">    publicstaticvoid main(String[] args) &#123;</div><div class="line">        // ConnectionFactory：连接工厂，JMS用它创建连接</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        // Connection：JMS客户端到JMS Provider的连接</div><div class="line">        Connection connection = null;</div><div class="line">        // Session：一个发送或接收消息的线程</div><div class="line">        Session session;</div><div class="line">        // Destination：消息的目的地;消息发送给谁.</div><div class="line">        Destination destination;</div><div class="line">        //消费者，消息接收者</div><div class="line">        MessageConsumer consumer;</div><div class="line">        connectionFactory = new ActiveMQConnectionFactory(</div><div class="line">                ActiveMQConnection.DEFAULT_USER,</div><div class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</div><div class="line">                &quot;failover:(tcp://10.42.220.72:61617,tcp://10.42.220.72:61618)&quot;);</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            //构造从工厂得到连接对象</div><div class="line">            connection =connectionFactory.createConnection();</div><div class="line">            //启动</div><div class="line">            connection.start();</div><div class="line">            //获取操作连接</div><div class="line">            session = connection.createSession(false,</div><div class="line">                    Session.AUTO_ACKNOWLEDGE);</div><div class="line">            //获取session</div><div class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</div><div class="line">            consumer =session.createConsumer(destination);</div><div class="line">            while (true) &#123;</div><div class="line">                //设置接收者接收消息的时间，为了便于测试，这里谁定为100s</div><div class="line">                TextMessage message =(TextMessage) consumer.receive(100000);</div><div class="line">                if (null != message) &#123;</div><div class="line">                    System.out.println(&quot;收到消息&quot; + message.getText());</div><div class="line">                &#125; else &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (null != connection)</div><div class="line">                    connection.close();</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3、通过监控查看消息堆栈的记录："><a href="#3、通过监控查看消息堆栈的记录：" class="headerlink" title="3、通过监控查看消息堆栈的记录："></a>3、通过监控查看消息堆栈的记录：</h5><p>登陆<code>http://localhost:8162/admin/queues.jsp</code>，默认的用户名和密码：<code>admin/admin</code></p>
<h2 id="二、ActiveMQ的多种部署方式"><a href="#二、ActiveMQ的多种部署方式" class="headerlink" title="二、ActiveMQ的多种部署方式"></a>二、ActiveMQ的多种部署方式</h2><p>单点的ActiveMQ作为企业应用无法满足高可用和集群的需求，所以ActiveMQ提供了master-slave、broker cluster等多种部署方式，但通过分析多种部署方式之后我认为需要将两种部署方式相结合才能满足我们公司分布式和高可用的需求，所以后面就重点将解如何将两种部署方式相结合。</p>
<h3 id="1、Master-Slave部署方式"><a href="#1、Master-Slave部署方式" class="headerlink" title="1、Master-Slave部署方式"></a>1、Master-Slave部署方式</h3><h4 id="1）shared-filesystem-Master-Slave部署方式"><a href="#1）shared-filesystem-Master-Slave部署方式" class="headerlink" title="1）shared filesystem Master-Slave部署方式"></a>1）shared filesystem Master-Slave部署方式</h4><p>主要是通过共享存储目录来实现master和slave的热备，所有的ActiveMQ应用都在不断地获取共享目录的控制权，哪个应用抢到了控制权，它就成为master。</p>
<p>多个共享存储目录的应用，谁先启动，谁就可以最早取得共享目录的控制权成为master，其他的应用就只能作为slave。<br><img src="/img/ActiveMQ Master-Slave部署方式.png" alt="ActiveMQ Master-Slave部署方式"></p>
<h4 id="2）shared-database-Master-Slave方式"><a href="#2）shared-database-Master-Slave方式" class="headerlink" title="2）shared database Master-Slave方式"></a>2）shared database Master-Slave方式</h4><p>与shared filesystem方式类似，只是共享的存储介质由文件系统改成了数据库而已。</p>
<h4 id="3）Replicated-LevelDB-Store方式"><a href="#3）Replicated-LevelDB-Store方式" class="headerlink" title="3）Replicated LevelDB Store方式"></a>3）Replicated LevelDB Store方式</h4><p>这种主备方式是ActiveMQ5.9以后才新增的特性，使用ZooKeeper协调选择一个node作为master。被选择的master broker node开启并接受客户端连接。<br>其他node转入slave模式，连接master并同步他们的存储状态。slave不接受客户端连接。所有的存储操作都将被复制到连接至Master的slaves。</p>
<p>如果master死了，得到了最新更新的slave被允许成为master。fialed node能够重新加入到网络中并连接master进入slave mode。所有需要同步的disk的消息操作都将等待存储状态被复制到其他法定节点的操作完成才能完成。所以，如果你配置了replicas=3，那么法定大小是(3/2)+1=2. Master将会存储并更新然后等待 (2-1)=1个slave存储和更新完成，才汇报success。至于为什么是2-1，熟悉Zookeeper的应该知道，有一个node要作为观擦者存在。</p>
<p>当一个新的master被选中，你需要至少保障一个法定node在线以能够找到拥有最新状态的node。这个node将会成为新的master。因此，推荐运行至少3个replica nodes，以防止一个node失败了，服务中断。</p>
<p><img src="/img/Replicated LevelDB Store方式.png" alt="Replicated LevelDB Store方式"></p>
<h3 id="2、Broker-Cluster部署方式"><a href="#2、Broker-Cluster部署方式" class="headerlink" title="2、Broker-Cluster部署方式"></a>2、Broker-Cluster部署方式</h3><p>前面的Master-Slave的方式虽然能解决多服务热备的高可用问题，但无法解决负载均衡和分布式的问题。Broker-Cluster的部署方式就可以解决负载均衡的问题。</p>
<p>Broker-Cluster部署方式中，各个broker通过网络互相连接，并共享queue。当broker-A上面指定的queue-A中接收到一个message处于pending状态，而此时没有consumer连接broker-A时。如果cluster中的broker-B上面有一个consumer在消费queue-A的消息，那么broker-B会先通过内部网络获取到broker-A上面的message，并通知自己的consumer来消费。</p>
<h4 id="1）static-Broker-Cluster部署"><a href="#1）static-Broker-Cluster部署" class="headerlink" title="1）static Broker-Cluster部署"></a>1）static Broker-Cluster部署</h4><p>在<code>activemq.xml</code>文件中静态指定Broker需要建立桥连接的其他Broker：</p>
<h5 id="1、首先在Broker-A节点中添加networkConnector节点："><a href="#1、首先在Broker-A节点中添加networkConnector节点：" class="headerlink" title="1、首先在Broker-A节点中添加networkConnector节点："></a>1、首先在Broker-A节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61617)&quot;duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="2、修改Broker-A节点中的服务提供端口为61616："><a href="#2、修改Broker-A节点中的服务提供端口为61616：" class="headerlink" title="2、修改Broker-A节点中的服务提供端口为61616："></a>2、修改Broker-A节点中的服务提供端口为61616：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<p>#####3、  在Broker-B节点中添加networkConnector节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61616)&quot;duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure></p>
<h5 id="4、修改Broker-A节点中的服务提供端口为61617："><a href="#4、修改Broker-A节点中的服务提供端口为61617：" class="headerlink" title="4、修改Broker-A节点中的服务提供端口为61617："></a>4、修改Broker-A节点中的服务提供端口为61617：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61617?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="5、分别启动Broker-A和Broker-B。"><a href="#5、分别启动Broker-A和Broker-B。" class="headerlink" title="5、分别启动Broker-A和Broker-B。"></a>5、分别启动Broker-A和Broker-B。</h5><h4 id="2）Dynamic-Broker-Cluster部署"><a href="#2）Dynamic-Broker-Cluster部署" class="headerlink" title="2）Dynamic Broker-Cluster部署"></a>2）Dynamic Broker-Cluster部署</h4><p>在<code>activemq.xml</code>文件中不直接指定Broker需要建立桥连接的其他Broker，由activemq在启动后动态查找：</p>
<h5 id="1、首先在Broker-A节点中添加networkConnector节点：-1"><a href="#1、首先在Broker-A节点中添加networkConnector节点：-1" class="headerlink" title="1、首先在Broker-A节点中添加networkConnector节点："></a>1、首先在Broker-A节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnectoruri=&quot;multicast://default&quot;</div><div class="line">           dynamicOnly=&quot;true&quot;</div><div class="line">           networkTTL=&quot;3&quot;</div><div class="line">           prefetchSize=&quot;1&quot;</div><div class="line">           decreaseNetworkConsumerPriority=&quot;true&quot; /&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="2、修改Broker-A节点中的服务提供端口为61616：-1"><a href="#2、修改Broker-A节点中的服务提供端口为61616：-1" class="headerlink" title="2、修改Broker-A节点中的服务提供端口为61616："></a>2、修改Broker-A节点中的服务提供端口为61616：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61616? &quot; discoveryUri=&quot;multicast://default&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="3、在Broker-B节点中添加networkConnector节点："><a href="#3、在Broker-B节点中添加networkConnector节点：" class="headerlink" title="3、在Broker-B节点中添加networkConnector节点："></a>3、在Broker-B节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">                &lt;networkConnectoruri=&quot;multicast://default&quot;</div><div class="line">           dynamicOnly=&quot;true&quot;</div><div class="line">           networkTTL=&quot;3&quot;</div><div class="line">           prefetchSize=&quot;1&quot;</div><div class="line">           decreaseNetworkConsumerPriority=&quot;true&quot; /&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="4、修改Broker-B节点中的服务提供端口为61617："><a href="#4、修改Broker-B节点中的服务提供端口为61617：" class="headerlink" title="4、修改Broker-B节点中的服务提供端口为61617："></a>4、修改Broker-B节点中的服务提供端口为61617：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61617&quot; discoveryUri=&quot;multicast://default&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="5、启动Broker-A和Broker-B"><a href="#5、启动Broker-A和Broker-B" class="headerlink" title="5、启动Broker-A和Broker-B"></a>5、启动Broker-A和Broker-B</h5><h3 id="2、Master-Slave与Broker-Cluster相结合的部署方式"><a href="#2、Master-Slave与Broker-Cluster相结合的部署方式" class="headerlink" title="2、Master-Slave与Broker-Cluster相结合的部署方式"></a>2、Master-Slave与Broker-Cluster相结合的部署方式</h3><p>可以看到Master-Slave的部署方式虽然解决了高可用的问题，但不支持负载均衡，Broker-Cluster解决了负载均衡，但当其中一个Broker突然宕掉的话，那么存在于该Broker上处于Pending状态的message将会丢失，无法达到高可用的目的。</p>
<p><img src="/img/activemqMaster-Slave与Broker-Cluster相结合的部署方式.png" alt="activemqMaster-Slave与Broker-Cluster相结合的部署方式"></p>
<h4 id="1、部署的配置修改"><a href="#1、部署的配置修改" class="headerlink" title="1、部署的配置修改"></a>1、部署的配置修改</h4><p>这里以Broker-A + Broker-B建立cluster，Broker-C作为Broker-B的slave为例：</p>
<h5 id="1）首先在Broker-A节点中添加networkConnector节点："><a href="#1）首先在Broker-A节点中添加networkConnector节点：" class="headerlink" title="1）首先在Broker-A节点中添加networkConnector节点："></a>1）首先在Broker-A节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;masterslave:(tcp://0.0.0.0:61617,tcp:// 0.0.0.0:61618)&quot; duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="2）修改Broker-A节点中的服务提供端口为61616："><a href="#2）修改Broker-A节点中的服务提供端口为61616：" class="headerlink" title="2）修改Broker-A节点中的服务提供端口为61616："></a>2）修改Broker-A节点中的服务提供端口为61616：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="3）在Broker-B节点中添加networkConnector节点："><a href="#3）在Broker-B节点中添加networkConnector节点：" class="headerlink" title="3）在Broker-B节点中添加networkConnector节点："></a>3）在Broker-B节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61616)&quot;duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h4 id="4）修改Broker-B节点中的服务提供端口为61617："><a href="#4）修改Broker-B节点中的服务提供端口为61617：" class="headerlink" title="4）修改Broker-B节点中的服务提供端口为61617："></a>4）修改Broker-B节点中的服务提供端口为61617：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line"></div><div class="line">         &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61617?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<p>5）修改Broker-B节点中的持久化方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">     &lt;kahaDB directory=&quot;/localhost/kahadb&quot;/&gt;</div><div class="line">  &lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure></p>
<p>6）在Broker-C节点中添加networkConnector节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61616)&quot;duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure></p>
<p>7）修改Broker-C节点中的服务提供端口为61618：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">    &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61618?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure></p>
<p>8）修改Broker-C节点中的持久化方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">     &lt;kahaDB directory=&quot;/localhost/kahadb&quot;/&gt;</div><div class="line"> &lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure></p>
<p>9）分别启动broker-A、broker-B、broker-C，因为是broker-B先启动，所以“/localhost/kahadb”目录被lock住，broker-C将一直处于挂起状态，当人为停掉broker-B之后，broker-C将获取目录“/localhost/kahadb”的控制权，重新与broker-A组成cluster提供服务。</p>
]]></content>
    
    <summary type="html">
    
      ActiveMQ实现负载均衡+高可用部署方案
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActiveMQ/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ理解</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/activemq/ActiveMQ%E7%90%86%E8%A7%A3/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/activemq/ActiveMQ理解/</id>
    <published>2017-04-05T20:25:34.000Z</published>
    <updated>2017-04-05T22:12:57.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Running-Broker"><a href="#Running-Broker" class="headerlink" title="Running Broker"></a>Running Broker</h2><p>直接运行bin/activemq脚本可以启动一个broker。</p>
<p>此外也可以通过Broker Configuration URI或Broker XBean URI对broker进行配置，以下是一些命令行参数的例子：</p>
<ul>
<li><code>activemq</code> Runs a broker using the default ‘<code>xbean:activemq.xml</code>‘ as the broker configuration file. </li>
<li><code>activemq xbean:myconfig.xml</code> Runs a broker using the file <code>myconfig.xml</code> as the broker configuration file that is located in the classpath. </li>
<li><code>activemq xbean:file:./conf/broker1.xml</code> Runs a broker using the file <code>broker1.xml</code> as the broker configuration file that is located in the relative file path <code>./conf/broker1.xml</code> </li>
<li><code>activemq xbean:file:C:/ActiveMQ/conf/broker2.xml</code> Runs a broker using the file <code>broker2.xml</code> as the broker configuration file that is located in the absolute file path <code>C:/ActiveMQ/conf/broker2.xml</code> </li>
<li><code>activemq broker:(tcp://localhost:61616, tcp://localhost:5000)?useJmx=true</code> Runs a broker with two transport connectors and JMX enabled. </li>
<li><code>activemq broker:(tcp://localhost:61616, network:tcp://localhost:5000)?persistent=false</code> Runs a broker with 1 transport connector and 1 network connector with persistence disabled. </li>
</ul>
<h2 id="Embedded-Broker"><a href="#Embedded-Broker" class="headerlink" title="Embedded Broker"></a>Embedded Broker</h2><p>可以通过在应用程序中以编码的方式启动broker，例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = new BrokerService(); </div><div class="line">broker.addConnector(&quot;tcp://localhost:61616&quot;); </div><div class="line">broker.start();</div></pre></td></tr></table></figure>
<p>如果需要启动多个broker，那么需要为broker设置一个名字。例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = new BrokerService(); </div><div class="line">broker.setName(&quot;fred&quot;); </div><div class="line">broker.addConnector(&quot;tcp://localhost:61616&quot;); </div><div class="line">broker.start();</div></pre></td></tr></table></figure>
<p>如果希望在同一个JVM内访问这个broker，那么可以使用VM Transport，URI是：<code>vm://brokerName</code>。 </p>
<h2 id="可以通过BrokerFactory来创建broker，例如："><a href="#可以通过BrokerFactory来创建broker，例如：" class="headerlink" title="可以通过BrokerFactory来创建broker，例如："></a>可以通过<code>BrokerFactory</code>来创建broker，例如：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = BrokerFactory.createBroker(new URI(someURI));</div></pre></td></tr></table></figure>
<p><code>someURI</code>的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>xbean:</code></td>
<td style="text-align:center"><code>xbean:activemq.xml</code></td>
<td style="text-align:center">Searches the classpath for an XML document with the given URI (<code>activemq.xml</code> in this case) which will then be used as the Xml Configuration</td>
</tr>
<tr>
<td style="text-align:center"><code>file:</code></td>
<td style="text-align:center"><code>file:foo/bar/activemq.xml</code></td>
<td style="text-align:center">Loads the given file (in this example <code>foo/bar/activemq.xml</code>) as the Xml Configuration</td>
</tr>
<tr>
<td style="text-align:center"><code>broker:</code></td>
<td style="text-align:center"><code>broker:tcp://localhost:61616</code></td>
<td style="text-align:center">Uses the Broker Configuration URI to configure the broker</td>
</tr>
</tbody>
</table>
<p>当使用<code>XBean</code>的配置方式的时候，需要指定一个xml配置文件，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = BrokerFactory.createBroker(new URI(&quot;xbean:com/test/activemq.xml&quot;));</div></pre></td></tr></table></figure></p>
<p>使用Spring的配置方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;broker&quot; class=&quot;org.apache.activemq.xbean.BrokerFactoryBean&quot;&gt; </div><div class="line">   &lt;property name=&quot;config&quot; value=&quot;classpath:org/apache/activemq/xbean/activemq.xml&quot; /&gt; </div><div class="line">   &lt;property name=&quot;start&quot; value=&quot;true&quot; /&gt; </div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Monitoring-Broker"><a href="#Monitoring-Broker" class="headerlink" title="Monitoring Broker"></a>Monitoring Broker</h2><h3 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h3><p>在使用JMX监控broker之前，首先要启用broker的JMX监控功能，例如在配置文件中设置<code>useJmx=&quot;true&quot;</code>，如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;broker useJmx=&quot;true&quot; brokerName=&quot;broker1&gt; </div><div class="line">    &lt;managementContext&gt; </div><div class="line">         &lt;managementContext createConnector=&quot;true&quot;/&gt; </div><div class="line">    &lt;/managementContext&gt; </div><div class="line"> ... </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure>
<p>接下来运行JDK自带的jconsole。在运行了jconsole后，它会弹出对话框来选择需要连接到的<code>agent</code>。如果是在启动broker的主机上运行jconsole，那么ActiveMQ broker会出现在jconsole的Local标签中。如果要连接到远程的broker，那么可以在Advanced标签中指定JMX URL，以下是一个连接到本机的JMX URL：<br><code>service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi</code><br>在jconsole的MBeans标签中，可以查看详细信息，也可以执行相应的operation。需要注意的是，在jconsole连接到broker的时候，并不需要输入用户名和密码，如果这存在潜在的安全问题，那么就需要为JMX Connector配置密码保护（需要使用1.5以上版本的JDK）。 </p>
<p>首先要禁止ActiveMQ创建自己的connector，例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.org/config/1.0&quot; brokerName=&quot;localhost&quot;useJmx=&quot;true&quot;&gt; </div><div class="line">    &lt;managementContext&gt; </div><div class="line">        &lt;managementContext createConnector=&quot;false&quot;/&gt; </div><div class="line">    &lt;/managementContext&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure>
<p>然后在ActiveMQ的<code>conf</code>目录下创建一个访问控制文件和密码文件，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">conf/jmx.access： </div><div class="line"># The &quot;monitorRole&quot; role has readonly access. </div><div class="line"># The &quot;controlRole&quot; role has readwrite access. </div><div class="line">monitorRole readonly </div><div class="line">controlRole readwrite</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">conf/jmx.password： </div><div class="line"># The &quot;monitorRole&quot; role has password &quot;abc123&quot;. </div><div class="line"># The &quot;controlRole&quot; role has password &quot;abcd1234&quot;. </div><div class="line">monitorRole abc123 </div><div class="line">controlRole abcd1234</div></pre></td></tr></table></figure>
<p>然后修改ActiveMQ的bin目录下activemq的启动脚本，查找包含”<code>SUNJMX=</code>“的一行如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">REM set SUNJMX=-Dcom.sun.management.jmxremote.port=1616 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false</div></pre></td></tr></table></figure>
<p>把它替换成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set SUNJMX=-Dcom.sun.management.jmxremote.port=1616 -Dcom.sun.management.jmxremote.authenticate=true -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.password.file=%ACTIVEMQ_BASE%/conf/jmx.password -Dcom.sun.management.jmxremote.access.file=%ACTIVEMQ_BASE%/conf/jmx.access</div></pre></td></tr></table></figure>
<p>最后重启ActiveMQ和jconsole，这时候需要强制login。如果在启动activemq的过程中出现以下错误，那么需要为这个文件增加访问控制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error: Password file read access must be restricted: D:\apache-activemq-5.0.0\bin\../conf/jmx.password</div></pre></td></tr></table></figure></p>
<h3 id="Web-Console"><a href="#Web-Console" class="headerlink" title="Web Console"></a>Web Console</h3><p>Web Console被集成到了ActiveMQ的二进制发布包中，因此缺省访问<code>http://localhost:8161/admin</code>即可访问Web Console。<br>在配置文件中，可以通过修改<code>nioConnector</code>的<code>port</code>属性来修改Web console的缺省端口： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;jetty xmlns=&quot;http://mortbay.com/schemas/jetty/1.0&quot;&gt; </div><div class="line">        &lt;connectors&gt; </div><div class="line">                &lt;nioConnector port=&quot;8161&quot; /&gt; </div><div class="line">        &lt;/connectors&gt; </div><div class="line">        ... </div><div class="line">&lt;/jetty&gt;</div></pre></td></tr></table></figure>
<p>出于安全性或者可靠性的考虑，Web Console可以被部署到不同于ActiveMQ的进程中。例如把<code>activemq-web-console.war</code>部署到一个单独的web容器中（Tomcat，Jetty等）。在ActiveMQ5.0的二进制发布包中不包含<code>activemq-web-console.war</code>，因此需要下载 ActiveMQ的源码，然后进入到<code>${activemq.base}/src/activemq-web-console</code>目录中执行<code>mvn instanll</code>。如果一切正常，那么缺省会在<code>${activemq.base}/src/activemq-web-console/target</code>目录中生成<code>activemq-web-console-5.0.0.war</code>。然后将<code>activemq-web-console-5.0.0.war</code>拷贝到Tomcat的<code>webapps</code>目录中，并重命名成<code>activemq-web-console.war</code>。<br>需要注意的是，要将<code>activemq-all-5.0.0.jar</code>拷贝到<code>WEB-INF\lib</code>目录中（可能还需要拷贝<code>jms.jar</code>）。还要为Tomcat设置以下五个系统属性（修改<code>catalina.bat</code>文件）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.type=&quot;properties&quot; </div><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.jms.url=&quot;tcp://localhost:61616&quot; </div><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.jmx.url=&quot;service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi&quot; </div><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.jmx.role=&quot;&quot; </div><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.jmx.password=&quot;&quot;</div></pre></td></tr></table></figure></p>
<p>如果JMX没有配置密码保护，那么<code>webconsole.jmx.role</code>和<code>webconsole.jmx.password</code>设置成<code>&quot;&quot;</code>即可。如果broker被配置成了Master/Slave模式，那么可以配置成使用failover transport，例如： </p>
<pre><code>-Dwebconsole.jms.url=failover:(tcp://serverA:61616,tcp://serverB:61616)
</code></pre><p>顺便说一下，由于<code>webconsole.type</code>属性是<code>properties</code>，因此实际上起作用的Web Console的配置文件是<code>WEB-INF/webconsole-properties.xml</code>。最后启动被监控的ActiveMQ，访问<code>http://localhost:8080 /activemq-web-console/</code>，查看显示是否正常。 </p>
<h3 id="Advisory-Message"><a href="#Advisory-Message" class="headerlink" title="Advisory Message"></a>Advisory Message</h3><p>ActiveMQ支持Advisory Messages，它允许你通过标准的JMS消息来监控系统。目前的Advisory Messages支持：<br>• consumers, producers and connections starting and stopping<br>• temporary destinations being created and destroyed<br>• messages expiring on topics and queues<br>• brokers sending messages to destinations with no consumers.<br>• connections starting and stopping </p>
<p>Advisory Messages可以被想象成某种的管理通道，通过它你可以得到关于JMS provider、producers、consumers和destinations的信息。Advisory topics都使用<code>ActiveMQ.Advisory.</code>这个前缀，以下是目前支持的topics： </p>
<p>Client based advisories<br>Advisory Topics Description<br>ActiveMQ.Advisory.Connection Connection start &amp; stop messages<br>ActiveMQ.Advisory.Producer.Queue Producer start &amp; stop messages on a Queue<br>ActiveMQ.Advisory.Producer.Topic Producer start &amp; stop messages on a Topic<br>ActiveMQ.Advisory.Consumer.Queue Consumer start &amp; stop messages on a Queue<br>ActiveMQ.Advisory.Consumer.Topic Consumer start &amp; stop messages on a Topic </p>
<p>在消费者启动/停止的Advisory Messages的消息头中有个<code>consumerCount</code>属性，它用来指明目前desination上活跃的consumer的数量。<br>Destination and Message based advisories<br>Advisory Topics Description<br>ActiveMQ.Advisory.Queue Queue create &amp; destroy<br>ActiveMQ.Advisory.Topic Topic create &amp; destroy<br>ActiveMQ.Advisory.TempQueue Temporary Queue create &amp; destroy<br>ActiveMQ.Advisory.TempTopic Temporary Topic create &amp; destroy<br>ActiveMQ.Advisory.Expired.Queue Expired messages on a Queue<br>ActiveMQ.Advisory.Expired.Topic Expired messages on a Topic<br>ActiveMQ.Advisory.NoConsumer.Queue No consumer is available to process messages being sent on a Queue<br>ActiveMQ.Advisory.NoConsumer.Topic No consumer is available to process messages being sent on a Topic </p>
<p>以上的这些destnations都可以用来作为前缀，在其后面追加其它的重要信息，例如topic、queue、clientID、 producderID和consumerID等。这令你可以利用Wildcards和Selectors来过滤Advisory Messages。<br>例如，如果你希望订阅<code>FOO.BAR</code>这个queue上Consumer的start/stop的消息，那么可以订阅<code>ActiveMQ.Advisory.Consumer.Queue.FOO.BAR</code>；如果希望订阅所有queue上的start/stop消息，那么可以订阅<code>ActiveMQ.Advisory.Consumer.Queue.</code>；如果希望订阅所有queue或者topic上的start/stop消息，那么可以订阅<code>ActiveMQ.Advisory.Consumer.</code>。<br><code>org.apache.activemq.advisory.AdvisorySupport</code>类上有如下的helper methods，用来在程序中得到advisory destination objects。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">AdvisorySupport.getConsumerAdvisoryTopic() </div><div class="line">AdvisorySupport.getProducerAdvisoryTopic() </div><div class="line">AdvisorySupport.getDestinationAdvisoryTopic() </div><div class="line">AdvisorySupport.getExpiredTopicMessageAdvisoryTopic() </div><div class="line">AdvisorySupport.getExpiredQueueMessageAdvisoryTopic() </div><div class="line">AdvisorySupport.getNoTopicConsumersAdvisoryTopic() </div><div class="line">AdvisorySupport.getNoQueueConsumersAdvisoryTopic()</div></pre></td></tr></table></figure></p>
<p>以下是段使用Advisory Messages的程序代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Destination advisoryDestination = AdvisorySupport.getProducerAdvisoryTopic(destination) </div><div class="line">MessageConsumer consumer = session.createConsumer(advisoryDestination); </div><div class="line">consumer.setMessageListener(this); </div><div class="line">... </div><div class="line">public void onMessage(Message msg)&#123; </div><div class="line">        if (msg instanceof ActiveMQMessage)&#123; </div><div class="line">                try &#123; </div><div class="line">                        ActiveMQMessage aMsg = (ActiveMQMessage)msg; </div><div class="line">                        ProducerInfo prod = (ProducerInfo) aMsg.getDataStructure(); </div><div class="line">                &#125; catch (JMSException e) &#123; </div><div class="line">                        log.error(&quot;Failed to process message: &quot; + msg); </div><div class="line">                &#125; </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Command-Agent"><a href="#Command-Agent" class="headerlink" title="Command Agent"></a>Command Agent</h3><p>在介绍Command Agent前首先简要介绍一下XMPP(Jabber)协议，XMPP是一种基于XML的即时通信协议，它由Jabber软件基金会开发。在配置文件中通过增加<code>transportConnector</code>来支持XMPP协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.org/config/1.0&quot;&gt; </div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">        ... </div><div class="line">                &lt;transportConnector name=&quot;xmpp&quot; uri=&quot;xmpp://localhost:61222&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>ActiveMQ提供了ActiveMQ messages和XMPP之间的双向桥接：<br>• 如果客户加入了一个聊天室，那么这个聊天室的名字会被映射到一个JMS topic。<br>• 尝试在聊天室内发送消息会导致一个JMS消息被发送到这个topic。<br>• 呆在一个聊天室中意味着这将保持一个对相应JMS topic的订阅。因此发送到这个topic的JMS消息也会被发送到聊天室。</p>
<p>从4.2版本起，ActiveMQ支持<code>Command Agent</code>。在配置文件中，通过设置<code>commandAgent</code>来启用Command Agent： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt; </div><div class="line">        &lt;broker useJmx=&quot;true&quot; xmlns=&quot;http://activemq.org/config/1.0&quot;&gt; </div><div class="line">        ... </div><div class="line">        &lt;/broker&gt; </div><div class="line">        &lt;commandAgent xmlns=&quot;http://activemq.org/config/1.0&quot;/&gt; </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>启用了Command Agent的broker上会有一个来自Command Agent的连接，它同时订阅topic：<code>ActiveMQ.Agent</code>。在你启动XMPP客户端，加入到<code>ActiveMQ.Agent</code>聊天室后，就可以同broker进行交谈了。通过在XMPP客户端中键入help，可以得到帮助信息。<br>需要注意的是，ActiveMQ5.0版本有个小bug，如果broker没有采用缺省的用户名和密码，那么Command Agent便无法正常启动。Apache官方文档说，此bug已经被修正，预定在5.2.0版本上体现。修改方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;commandAgent xmlns=&quot;http://activemq.org/config/1.0&quot; brokerUser=&quot;user&quot; brokerPassword=&quot;passward&quot;/&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Visualization-plugin"><a href="#Visualization-plugin" class="headerlink" title="Visualization plugin"></a>Visualization plugin</h3><p>ActiveMQ支持以broker插件的形式生成DOT文件(可以用agrviewer来查看)，以图表的方式描述connections、sessions、producers、consumers、destinations等信息。配置方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.org/config/1.0&quot; brokerName=&quot;localhost&quot; useJmx=&quot;true&quot;&gt; </div><div class="line">        ... </div><div class="line">    &lt;plugins&gt; </div><div class="line">        &lt;connectionDotFilePlugin file=&quot;connection.dot&quot;/&gt; </div><div class="line">        &lt;destinationDotFilePlugin file=&quot;destination.dot&quot;/&gt; </div><div class="line">        &lt;/plugins&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，笔者认为ActiveMQ5.0版本的Visualization Plugin尚不稳定，存在诸多问题。例如：如果使用<code>connectionDotFilePlugin</code>，那么<code>brokerName</code>必须是<code>localhost</code>；如果使用<code>destinationDotFilePlugin</code>可能会导致<code>ArrayStoreException</code>。 </p>
<h2 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h2><p>ActiveMQ目前支持的transport有：VM Transport、TCP Transport、SSL Transport、Peer Transport、UDP Transport、Multicast Transport、HTTP and HTTPS Transport、Failover Transport、Fanout Transport、Discovery Transport、ZeroConf Transport等。</p>
<h3 id="VM-Transport"><a href="#VM-Transport" class="headerlink" title="VM Transport"></a>VM Transport</h3><p>VM transport允许在VM内部通信，从而避免了网络传输的开销。这时候采用的连接不是socket连接，而是直接地方法调用。 第一个创建VM连接的客户会启动一个embed VM broker，接下来所有使用相同的broker name的VM连接都会使用这个broker。当这个broker上所有的连接都关闭的时候，这个broker也会自动关闭。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vm://brokerName?transportOptions</div></pre></td></tr></table></figure>
<p>例如：<code>vm://broker1?marshal=false&amp;broker.persistent=false</code><br>Transport Options的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Option Name</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Marshal</td>
<td style="text-align:center">false</td>
<td style="text-align:center">If true, forces each command sent over the transport to be marshlled and unmarshlled using a WireFormat</td>
</tr>
<tr>
<td style="text-align:center">wireFormat</td>
<td style="text-align:center">default</td>
<td style="text-align:center">The name of the WireFormat to use </td>
</tr>
</tbody>
</table>
<p>wireFormat.<em> All the properties with this prefix are used to configure the wireFormat |<br>| create |  true |  If the broker should be created on demand if it does not allready exist. Only supported in ActiveMQ 4.1 |<br>| broker.</em>  | All  | the properties with this prefix are used to configure the broker. See Configuring Wire Formats for more information  | </p>
<p>以下是高级配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vm:(broker:(tcp://localhost)?brokerOptions)?transportOptions </div><div class="line">vm:broker:(tcp://localhost)?brokerOptions</div></pre></td></tr></table></figure></p>
<p>例如：<code>vm:(broker:(tcp://localhost:6000)?persistent=false)?marshal=false</code> </p>
<p>使用配置文件的配置语法：<br><code>vm://localhost?brokerConfig=xbean:activemq.xml</code><br>例如：<code>vm:// localhost?brokerConfig=xbean:com/test/activemq.xml</code></p>
<p>使用Spring的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;broker&quot; class=&quot;org.apache.activemq.xbean.BrokerFactoryBean&quot;&gt; </div><div class="line">        &lt;property name=&quot;config&quot; value=&quot;classpath:org/apache/activemq/xbean/activemq.xml&quot; /&gt; </div><div class="line">        &lt;property name=&quot;start&quot; value=&quot;true&quot; /&gt; </div><div class="line">        &lt;/bean&gt; </div><div class="line"></div><div class="line">&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot; depends-on=&quot;broker&quot;&gt; </div><div class="line">&lt;property name=&quot;brokerURL&quot; value=&quot;vm://localhost&quot;/&gt; </div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>如果<code>persistent</code>是<code>true</code>，那么ActiveMQ会在当前目录下创建一个缺省值是<code>activemq-data</code>的目录用于持久化保存数据。需要注意的是，如果程序中启动了多个不同名字的VM broker，那么可能会有如下警告：<code>Failed to start jmx connector: Cannot bind to URL [rmi://localhost:1099/jmxrmi]:javax.naming.NameAlreadyBoundException…</code>可以通过在<code>transportOptions</code>中追加<code>broker.useJmx=false</code>来禁用JMX来避免这个警告。 </p>
<h3 id="TCP-Transport"><a href="#TCP-Transport" class="headerlink" title="TCP Transport"></a>TCP Transport</h3><p>TCP transport 允许客户端通过TCP socket连接到远程的broker。以下是配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcp://hostname:port?transportOptions</div></pre></td></tr></table></figure></p>
<p>Transport Options的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Option Name</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">minmumWireFormatVersion</td>
<td style="text-align:center">0</td>
<td style="text-align:center">The minimum version wireformat that is allowed</td>
</tr>
<tr>
<td style="text-align:center">trace</td>
<td style="text-align:center">false</td>
<td style="text-align:center">Causes all commands that are sent over the transport to be logged</td>
</tr>
<tr>
<td style="text-align:center">useLocalHost</td>
<td style="text-align:center">true</td>
<td style="text-align:center">When true, it causes the local machines name to resolve to “localhost”.</td>
</tr>
<tr>
<td style="text-align:center">socketBufferSize</td>
<td style="text-align:center">64 * 1024</td>
<td style="text-align:center">Sets the socket buffer size in bytes </td>
</tr>
</tbody>
</table>
<p>soTimeout 0 sets the socket timeout in milliseconds |<br>| connectionTimeout | 30000 | A non-zero value specifies the connection timeout in milliseconds. A zero value means wait forever for the connection to be established. Negative values are ignored. |<br>| wireFormat | default | The name of the WireFormat to use wireFormat.* All the properties with this prefix are used to configure the wireFormat. See Configuring Wire Formats for more information  | </p>
<p>例如：<code>tcp://localhost:61616?trace=false</code> </p>
<h3 id="Failover-Transport"><a href="#Failover-Transport" class="headerlink" title="Failover Transport"></a>Failover Transport</h3><p>Failover Transport是一种重新连接的机制，它工作于其它transport的上层，用于建立可靠的传输。它的配置语法允许制定任意多个复合的URI。Failover transport会自动选择其中的一个URI来尝试建立连接。如果没有成功，那么会选择一个其它的URI来建立一个新的连接。以下是配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">failover:(uri1,...,uriN)?transportOptions </div><div class="line">failover:uri1,...,uriN</div></pre></td></tr></table></figure></p>
<p>Transport Options的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Option Name</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">initialReconnectDelay</td>
<td style="text-align:center">10</td>
<td style="text-align:center">How long to wait before the first reconnect attempt (in ms)</td>
</tr>
<tr>
<td style="text-align:center">maxReconnectDelay</td>
<td style="text-align:center">30000</td>
<td style="text-align:center">The maximum amount of time we ever wait between reconnect attempts (in ms)</td>
</tr>
<tr>
<td style="text-align:center">useExponentialBackOff</td>
<td style="text-align:center">true</td>
<td style="text-align:center">Should an exponential backoff be used between reconnect attempts</td>
</tr>
<tr>
<td style="text-align:center">backOffMultiplier</td>
<td style="text-align:center">2</td>
<td style="text-align:center">The exponent used in the exponential backoff attempts</td>
</tr>
<tr>
<td style="text-align:center">maxReconnectAttempts</td>
<td style="text-align:center">0</td>
<td style="text-align:center">If not 0, then this is the maximum number of reconnect attempts before an error is sent back to the client</td>
</tr>
<tr>
<td style="text-align:center">randomize</td>
<td style="text-align:center">true</td>
<td style="text-align:center">use a random algorithm to choose the URI to use for reconnect from the list provided</td>
</tr>
<tr>
<td style="text-align:center">backup</td>
<td style="text-align:center">false</td>
<td style="text-align:center">initialize and hold a second transport connection - to enable fast failover</td>
</tr>
</tbody>
</table>
<p>例如：<code>failover:(tcp://localhost:61616,tcp://remotehost:61616)?initialReconnectDelay=100</code></p>
<h3 id="Discovery-transport"><a href="#Discovery-transport" class="headerlink" title="Discovery transport"></a>Discovery transport</h3><p>Discovery transport是可靠的tranport。它使用Discovery transport来定位用来连接的URI列表。以下是配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">discovery:(discoveryAgentURI)?transportOptions </div><div class="line">discovery:discoveryAgentURI</div></pre></td></tr></table></figure></p>
<p>Transport Options的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Option Name</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">initialReconnectDelay</td>
<td style="text-align:center">10</td>
<td style="text-align:center">How long to wait before the first reconnect attempt</td>
</tr>
<tr>
<td style="text-align:center">maxReconnectDelay</td>
<td style="text-align:center">30000</td>
<td style="text-align:center">The maximum amount of time we ever wait between reconnect attempts</td>
</tr>
<tr>
<td style="text-align:center">useExponentialBackOff</td>
<td style="text-align:center">true</td>
<td style="text-align:center">Should an exponential backoff be used btween reconnect attempts</td>
</tr>
<tr>
<td style="text-align:center">backOffMultiplier</td>
<td style="text-align:center">2</td>
<td style="text-align:center">The exponent used in the exponential backoff attempts</td>
</tr>
<tr>
<td style="text-align:center">maxReconnectAttempts</td>
<td style="text-align:center">0</td>
<td style="text-align:center">If not 0, then this is the maximum number of reconnect attempts before an error is sent back to the client</td>
</tr>
</tbody>
</table>
<p>例如：<code>discovery:(multicast://default)?initialReconnectDelay=100</code><br>为了使用Discovery来发现broker，需要为broker启用discovery agent。 以下是XML配置文件中的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;broker name=&quot;foo&quot;&gt; </div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">                &lt;transportConnector uri=&quot;tcp://localhost:0&quot; discoveryUri=&quot;multicast://default&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line">... </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>在使用Failover Transport或Discovery transport等能够自动重连的transport的时候，需要注意的是：设想有两个broker，它们都启用AMQ Message Store作为持久化存储，有一个producer和一个consumer连接到某个queue。当因其中一个broker失效时而切换到另一个 broker的时候，如果失效的broker的queue中还有未被consumer消费的消息，那么这个queue里的消息仍然滞留在失效broker 的中，直到失效的broker被修复并重新切换回这个被修复的broker后，之前被保留的消息才会被consumer消费掉。如果被处理的消息有时序限制，那么应用程序就需要处理这个问题。另外也可以通过ActiveMQ集群来解决这个问题。<br>在transport重连的时候，可以在connection上注册<code>TransportListener</code>来获得回调，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(ActiveMQConnection)connection).addTransportListener(new TransportListener() &#123; </div><div class="line">public void onCommand(Object cmd) &#123; </div><div class="line">&#125; </div><div class="line"></div><div class="line">public void onException(IOException exp) &#123; </div><div class="line">&#125; </div><div class="line"></div><div class="line">public void transportInterupted() &#123; </div><div class="line">// The transport has suffered an interruption from which it hopes to recover. </div><div class="line">&#125; </div><div class="line"> </div><div class="line">public void transportResumed() &#123; </div><div class="line">// The transport has resumed after an interruption. </div><div class="line">&#125; </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h2><h3 id="AMQ-Message-Store"><a href="#AMQ-Message-Store" class="headerlink" title="AMQ Message Store"></a>AMQ Message Store</h3><p>AMQ Message Store是ActiveMQ5.0缺省的持久化存储。Message commands被保存到transactional journal（由rolling data logs组成）。Messages被保存到data logs中，同时被reference store进行索引以提高存取速度。Date logs由一些单独的data log文件组成，缺省的文件大小是32M，如果某个消息的大小超过了data log文件的大小，那么可以修改配置以增加data log文件的大小。如果某个data log文件中所有的消息都被成功消费了，那么这个data log文件将会被标记，以便在下一轮的清理中被删除或者归档。以下是其配置的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=&quot;broker&quot; persistent=&quot;true&quot; useShutdownHook=&quot;false&quot;&gt; </div><div class="line">        &lt;persistenceAdapter&gt; </div><div class="line">                &lt;amqPersistenceAdapter directory=&quot;$&#123;activemq.base&#125;/data&quot; maxFileLength=&quot;32mb&quot;/&gt; </div><div class="line">        &lt;/persistenceAdapter&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">Property name</th>
<th style="text-align:center">Default value</th>
<th style="text-align:center">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">directory</td>
<td style="text-align:center">activemq-data</td>
<td style="text-align:center">the path to the directory to use to store the message store data and log files</td>
</tr>
<tr>
<td style="text-align:center">useNIO</td>
<td style="text-align:center">true</td>
<td style="text-align:center">use NIO to write messages to the data logs</td>
</tr>
<tr>
<td style="text-align:center">syncOnWrite</td>
<td style="text-align:center">false</td>
<td style="text-align:center">sync every write to disk</td>
</tr>
<tr>
<td style="text-align:center">maxFileLength</td>
<td style="text-align:center">32mb</td>
<td style="text-align:center">a hint to set the maximum size of the message data logs</td>
</tr>
<tr>
<td style="text-align:center">persistentIndex</td>
<td style="text-align:center">true</td>
<td style="text-align:center">use a persistent index for the message logs. If this is false, an in-memory structure is maintained</td>
</tr>
<tr>
<td style="text-align:center">maxCheckpointMessageAddSize</td>
<td style="text-align:center">4kb</td>
<td style="text-align:center">the maximum number of messages to keep in a transaction before automatically committing</td>
</tr>
<tr>
<td style="text-align:center">cleanupInterval</td>
<td style="text-align:center">30000</td>
<td style="text-align:center">time (ms) before checking for a discarding/moving message data logs that are no longer used</td>
</tr>
<tr>
<td style="text-align:center">indexBinSize</td>
<td style="text-align:center">1024</td>
<td style="text-align:center">default number of bins used by the index. The bigger the bin size - the better the relative performance of the index</td>
</tr>
<tr>
<td style="text-align:center">indexKeySize</td>
<td style="text-align:center">96</td>
<td style="text-align:center">the size of the index key - the key is the message id </td>
</tr>
</tbody>
</table>
<p>indexPageSize 16kb the size of the index page - the bigger the page - the better the write performance of the index  |<br>| directoryArchive | archive | the path to the directory to use to store discarded data logs |<br>| archiveDataLogs | false | if true data logs are moved to the archive directory instead of being deleted | </p>
<h3 id="Kaha-Persistence"><a href="#Kaha-Persistence" class="headerlink" title="Kaha Persistence"></a>Kaha Persistence</h3><p>Kaha Persistence 是一个专门针对消息持久化的解决方案。它对典型的消息使用模式进行了优化。在Kaha中，数据被追加到data logs中。当不再需要log文件中的数据的时候，log文件会被丢弃。以下是其配置的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=&quot;broker&quot; persistent=&quot;true&quot; useShutdownHook=&quot;false&quot;&gt; </div><div class="line">        &lt;persistenceAdapter&gt; </div><div class="line">                &lt;kahaPersistenceAdapter directory=&quot;activemq-data&quot;       maxDataFileLength=&quot;33554432&quot;/&gt; </div><div class="line">        &lt;/persistenceAdapter&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h3 id="JDBC-Persistence"><a href="#JDBC-Persistence" class="headerlink" title="JDBC Persistence"></a>JDBC Persistence</h3><p>目前支持的数据库有Apache Derby, Axion, DB2, HSQL, Informix, MaxDB, MySQL, Oracle, Postgresql, SQLServer, Sybase。<br>如果你使用的数据库不被支持，那么可以调整<code>StatementProvider</code>来保证使用正确的SQL方言（flavour of SQL）。通常绝大多数数据库支持以下adaptor：<br>• org.activemq.store.jdbc.adapter.BlobJDBCAdapter<br>• org.activemq.store.jdbc.adapter.BytesJDBCAdapter<br>• org.activemq.store.jdbc.adapter.DefaultJDBCAdapter<br>• org.activemq.store.jdbc.adapter.ImageJDBCAdapter</p>
<p>也可以在配置文件中直接指定JDBC adaptor，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;jdbcPersistenceAdapter adapterClass=&quot;org.apache.activemq.store.jdbc.adapter.ImageBasedJDBCAdaptor&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>以下是其配置的一个例子： </p>
<pre><code>&lt;persistence&gt; 
     &lt;jdbcPersistence dataSourceRef=&quot; mysql-ds&quot;/&gt; 
&lt;/persistence&gt; 

&lt;bean id=&quot;mysql-ds&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; 
     &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; 
     &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/activemq?relaxAutoCommit=true&quot;/&gt; 
     &lt;property name=&quot;username&quot; value=&quot;activemq&quot;/&gt; 
     &lt;property name=&quot;password&quot; value=&quot;activemq&quot;/&gt; 
     &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt; 
&lt;/bean&gt; 
</code></pre><p>需要注意的是，如果使用MySQL，那么需要设置<code>relaxAutoCommit</code>标志为<code>true</code>。 </p>
<h3 id="Disable-Persistence"><a href="#Disable-Persistence" class="headerlink" title="Disable Persistence"></a>Disable Persistence</h3><p>以下是其配置的一个例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;broker persistent=&quot;false&quot;&gt;&lt;/broker&gt;</div></pre></td></tr></table></figure>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p>ActiveMQ支持可插拔的安全机制，用以在不同的provider之间切换。 </p>
<h3 id="Simple-Authentication-Plugin"><a href="#Simple-Authentication-Plugin" class="headerlink" title="Simple Authentication Plugin"></a>Simple Authentication Plugin</h3><p>Simple Authentication Plugin适用于简单的认证需求，或者用于建立测试环境。它允许在XML配置文件中指定用户、用户组和密码等信息。以下是ActiveMQ配置的一个例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;plugins&gt; </div><div class="line">        ... </div><div class="line">        &lt;simpleAuthenticationPlugin&gt; </div><div class="line">                &lt;users&gt; </div><div class="line">                     &lt;authenticationUser username=&quot;system&quot; password=&quot;manager&quot;   groups=&quot;users,admins&quot;/&gt; </div><div class="line">                     &lt;authenticationUser username=&quot;user&quot; password=&quot;password&quot; groups=&quot;users&quot;/&gt; </div><div class="line">                     &lt;authenticationUser username=&quot;guest&quot; password=&quot;password&quot; groups=&quot;guests&quot;/&gt; </div><div class="line">                &lt;/users&gt; </div><div class="line">        &lt;/simpleAuthenticationPlugin&gt; </div><div class="line">&lt;/plugins&gt;</div></pre></td></tr></table></figure>
<h3 id="JAAS-Authentication-Plugin"><a href="#JAAS-Authentication-Plugin" class="headerlink" title="JAAS Authentication Plugin"></a>JAAS Authentication Plugin</h3><p>JAAS Authentication Plugin依赖标准的JAAS机制来实现认证。通常情况下，你需要通过设置<code>java.security.auth.login.config</code>系统属性来配置login modules的配置文件。如果没有指定这个系统属性，那么JAAS Authentication Plugin会缺省使用<code>login.config</code>作为文件名。以下是一个<code>login.config</code>文件的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">activemq-domain &#123; </div><div class="line">        org.apache.activemq.jaas.PropertiesLoginModule required debug=true org.apache.activemq.jaas.properties.user=&quot;users.properties&quot; org.apache.activemq.jaas.properties.group=&quot;groups.properties&quot;; </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个<code>login.config</code>文件中设置了两个属性：<code>org.apache.activemq.jaas.properties.user</code>和<code>org.apache.activemq.jaas.properties.group</code>分别用来指向<code>user.properties</code>和<code>group.properties</code>文件。需要注意的是，<code>PropertiesLoginModule</code>使用本地文件的查找方式，而且查找时采用的base directory是<code>login.config</code>文件所在的目录。因此这个<code>login.config</code>说明<code>user.properties</code>和<code>group.properties</code>文件存放在跟<code>login.config</code>文件相同的目录里。<br>以下是ActiveMQ配置的一个例子： </p>
<pre><code>&lt;plugins&gt; 
        ... 
        &lt;jaasAuthenticationPlugin configuration=&quot;activemq-domain&quot; /&gt; 
&lt;/plugins&gt; 
</code></pre><p>基于以上的配置，在JAAS的<code>LoginContext</code>中会使用<code>activemq-domain</code>中配置的<code>PropertiesLoginModule</code>来进行登陆。<br>ActiveMQ JAAS还支持<code>LDAPLoginModule</code>、<code>CertificateLoginModule</code>、<code>TextFileCertificateLoginModule</code>等login module。 </p>
<h3 id="Custom-Authentication-Implementation"><a href="#Custom-Authentication-Implementation" class="headerlink" title="Custom Authentication Implementation"></a>Custom Authentication Implementation</h3><p>可以通过编码的方式为ActiveMQ增加认证功能。例如编写一个类继承自<code>XBeanBrokerService</code>。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">package com.yourpackage; </div><div class="line"></div><div class="line">import java.net.URI; </div><div class="line">import java.util.HashMap; </div><div class="line">import java.util.Map; </div><div class="line"></div><div class="line">import org.apache.activemq.broker.Broker; </div><div class="line">import org.apache.activemq.broker.BrokerFactory; </div><div class="line">import org.apache.activemq.broker.BrokerService; </div><div class="line">import org.apache.activemq.security.SimpleAuthenticationBroker; </div><div class="line">import org.apache.activemq.xbean.XBeanBrokerService; </div><div class="line"></div><div class="line">public class SimpleAuthBroker extends XBeanBrokerService &#123; </div><div class="line">        // </div><div class="line">        private String user; </div><div class="line">        private String password; </div><div class="line"></div><div class="line">        @SuppressWarnings(&quot;unchecked&quot;) </div><div class="line">        protected Broker addInterceptors(Broker broker) throws Exception &#123; </div><div class="line">                broker = super.addInterceptors(broker); </div><div class="line">                Map passwords = new HashMap(); </div><div class="line">                passwords.put(getUser(), getPassword()); </div><div class="line">                broker = new SimpleAuthenticationBroker(broker, passwords, new HashMap()); </div><div class="line">                return broker; </div><div class="line">        &#125; </div><div class="line"></div><div class="line">        public String getUser() &#123; </div><div class="line">              return user; </div><div class="line">        &#125; </div><div class="line"></div><div class="line">        public void setUser(String user) &#123; </div><div class="line">                this.user = user; </div><div class="line">        &#125; </div><div class="line"> </div><div class="line">    public String getPassword() &#123; </div><div class="line">         return password; </div><div class="line">    &#125; </div><div class="line">     </div><div class="line">    public void setPassword(String password) &#123; </div><div class="line">            this.password = password; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是ActiveMQ配置文件的一个例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt; </div><div class="line">    … </div><div class="line">    &lt;auth:SimpleAuthBroker </div><div class="line">    xmlns:auth=&quot;java://com.yourpackage&quot; </div><div class="line">    xmlns=&quot;http://activemq.org/config/1.0&quot; brokerName=&quot;SimpleAuthBroker1&quot; user=&quot;user&quot; password=&quot;password&quot; useJmx=&quot;true&quot;&gt; </div><div class="line"></div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">                &lt;transportConnector uri=&quot;tcp://localhost:61616&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line">    &lt;/auth:SimpleAuthBroker&gt; </div><div class="line">    … </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>在这个配置文件中增加了一个namespace auth，用于指向之前编写的哪个类。同时为<code>SimpleAuthBroker</code>注入了两个属性值<code>user</code>和<code>password</code>，因此在被<code>SimpleAuthBroker</code>改写的<code>addInterceptors</code>方法里，可以使用这两个属性进行认证了。ActiveMQ提供的<code>SimpleAuthenticationBroker</code>类继承自<code>BrokerFilter</code>可以简单的看成是Broker的Adaptor），它的构造函数中的两个<code>Map</code>分别是<code>userPasswords</code>和<code>userGroups</code>。<br><code>SimpleAuthenticationBroker</code>在<code>addConnection</code>方法中使用<code>userPasswords</code>进行认证，同时会把<code>userGroups</code>的信息保存到<code>ConnectionContext</code>中。</p>
<h3 id="Authorization-Plugin"><a href="#Authorization-Plugin" class="headerlink" title="Authorization Plugin"></a>Authorization Plugin</h3><p>可以通过Authorization Plugin为认证后的用户授权，以下ActiveMQ配置文件的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;plugins&gt; </div><div class="line">    &lt;jaasAuthenticationPlugin configuration=&quot;activemq-domain&quot;/&gt;  </div><div class="line">    &lt;authorizationPlugin&gt; </div><div class="line">        &lt;map&gt; </div><div class="line">            &lt;authorizationMap&gt; </div><div class="line">                &lt;authorizationEntries&gt; </div><div class="line">                    &lt;authorizationEntry queue=&quot;&gt;&quot; read=&quot;admins&quot; write=&quot;admins&quot; admin=&quot;admins&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry queue=&quot;USERS.&gt;&quot; read=&quot;users&quot; write=&quot;users&quot; admin=&quot;users&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry queue=&quot;GUEST.&gt;&quot; read=&quot;guests&quot; write=&quot;guests,users&quot; admin=&quot;guests,users&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry topic=&quot;&gt;&quot; read=&quot;admins&quot; write=&quot;admins&quot; admin=&quot;admins&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry topic=&quot;USERS.&gt;&quot; read=&quot;users&quot; write=&quot;users&quot; admin=&quot;users&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry topic=&quot;GUEST.&gt;&quot; read=&quot;guests&quot; write=&quot;guests,users&quot; admin=&quot;guests,users&quot; /&gt; </div><div class="line">     </div><div class="line">                    &lt;authorizationEntry topic=&quot;ActiveMQ.Advisory.&gt;&quot; read=&quot;guests,users&quot; write=&quot;guests,users&quot; admin=&quot;guests,users&quot;/&gt; </div><div class="line">                &lt;/authorizationEntries&gt; </div><div class="line">            &lt;/authorizationMap&gt; </div><div class="line">        &lt;/map&gt; </div><div class="line">    &lt;/authorizationPlugin&gt; </div><div class="line">&lt;/plugins&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h2><p>ActiveMQ从多种不同的方面提供了集群的支持。 </p>
<h3 id="Queue-consumer-clusters"><a href="#Queue-consumer-clusters" class="headerlink" title="Queue consumer clusters"></a>Queue consumer clusters</h3><p>ActiveMQ支持订阅同一个queue的consumers上的集群。如果一个consumer失效，那么所有未被确认 （unacknowledged）的消息都会被发送到这个queue上其它的consumers。如果某个consumer的处理速度比其它consumers更快，那么这个consumer就会消费更多的消息。<br>需要注意的是，笔者发现AcitveMQ5.0版本的Queue consumer clusters存在一个bug：采用AMQ Message Store，运行一个producer，两个consumer，并采用如下的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt; </div><div class="line">    &lt;broker xmlns=&quot;http://activemq.org/config/1.0&quot; brokerName=&quot;BugBroker1&quot; useJmx=&quot;true&quot;&gt; </div><div class="line"></div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">            &lt;transportConnector uri=&quot;tcp://localhost:61616&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line"></div><div class="line">        &lt;persistenceAdapter&gt; </div><div class="line">            &lt;amqPersistenceAdapter directory=&quot;activemq-data/BugBroker1&quot; maxFileLength=&quot;32mb&quot;/&gt; </div><div class="line">        &lt;/persistenceAdapter&gt; </div><div class="line">     </div><div class="line">    &lt;/broker&gt; </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>那么经过一段时间后可能会报出如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR [ActiveMQ Transport: tcp:///127.0.0.1:1843 - RecoveryListenerAdapter.java:58 - RecoveryListenerAdapter] Message id ID:versus-1837-1203915536609-0:2:1:1:419 could not be recovered from the data store!</div></pre></td></tr></table></figure></p>
<p>Apache官方文档说，此bug已经被修正，预定在5.1.0版本上体现。 </p>
<h3 id="Broker-clusters"><a href="#Broker-clusters" class="headerlink" title="Broker clusters"></a>Broker clusters</h3><p>一个常见的场景是有多个JMS broker，一个客户连接到其中一个broker。如果这个broker失效，那么客户会自动重新连接到其它的broker。在ActiveMQ中使用<code>failover://</code> 协议来实现这个功能。ActiveMQ3.x版本的<code>reliable://</code>协议已经变更为<code>failover://</code>。<br>如果某个网络上有多个brokers而且客户使用静态发现（使用Static Transport或Failover Transport）或动态发现（使用Discovery Transport），那么客户可以容易地在某个broker失效的情况下切换到其它的brokers。然而，stand alone brokers并不了解其它brokers上的consumers，也就是说如果某个broker上没有consumers，那么这个broker上的消息可能会因得不到处理而积压起来。目前的解决方案是使用Network of brokers，以便在broker之间存储转发消息。ActiveMQ在未来会有更好的特性，用来在客户端处理这个问题。<br>从ActiveMQ1.1版本起，ActiveMQ支持networks of brokers。它支持分布式的queues和topics。一个broker会相同对待所有的订阅（subscription）：不管他们是来自本地的客户连接，还是来自远程broker，它都会递送有关的消息拷贝到每个订阅。远程broker得到这个消息拷贝后，会依次把它递送到其内部的本地连接上。有两种方式配置Network of brokers，一种是使用static transport：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=&quot;receiver&quot; persistent=&quot;false&quot; useJmx=&quot;false&quot;&gt; </div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">                &lt;transportConnector uri=&quot;tcp://localhost:62002&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line">        </div><div class="line">        &lt;networkConnectors&gt; </div><div class="line">                &lt;networkConnector uri=&quot;static:( tcp://localhost:61616,tcp://remotehost:61616)&quot;/&gt; </div><div class="line">        &lt;/networkConnectors&gt; </div><div class="line">… </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>另外一种是使用multicast discovery，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;broker name=&quot;sender&quot; persistent=&quot;false&quot; useJmx=&quot;false&quot;&gt; </div><div class="line">    &lt;transportConnectors&gt; </div><div class="line">        &lt;transportConnector uri=&quot;tcp://localhost:0&quot; discoveryUri=&quot;multicast://default&quot;/&gt; </div><div class="line">    &lt;/transportConnectors&gt; </div><div class="line">    &lt;networkConnectors&gt; </div><div class="line">        &lt;networkConnector uri=&quot;multicast://default&quot;/&gt; </div><div class="line">    &lt;/networkConnectors&gt; </div><div class="line">... </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>Network Connector有以下属性： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Property</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">name</td>
<td style="text-align:center">bridge</td>
<td style="text-align:center">name of the network - for more than one network connector between the same two brokers - use different names</td>
</tr>
<tr>
<td style="text-align:center">dynamicOnly</td>
<td style="text-align:center">false</td>
<td style="text-align:center">if true, only forward messages if a consumer is active on the connected broker</td>
</tr>
<tr>
<td style="text-align:center">decreaseNetworkConsumerPriority</td>
<td style="text-align:center">false</td>
<td style="text-align:center">decrease the priority for dispatching to a Queue consumer the further away it is (in network hops) from the producer</td>
</tr>
<tr>
<td style="text-align:center">networkTTL</td>
<td style="text-align:center">1</td>
<td style="text-align:center">the number of brokers in the network that messages and subscriptions can pass through</td>
</tr>
<tr>
<td style="text-align:center">conduitSubscriptions</td>
<td style="text-align:center">true</td>
<td style="text-align:center">multiple consumers subscribing to the same destination are treated as one consumer by the network</td>
</tr>
<tr>
<td style="text-align:center">excludedDestinations</td>
<td style="text-align:center">empty</td>
<td style="text-align:center">destinations matching this list won’t be forwarded across the network</td>
</tr>
<tr>
<td style="text-align:center">dynamicallyIncludedDestinations</td>
<td style="text-align:center">empty</td>
<td style="text-align:center">destinations that match this list will be forwarded across the network n.b. an empty list means all destinations not in the excluded list will be forwarded</td>
</tr>
<tr>
<td style="text-align:center">staticallyIncludedDestinations</td>
<td style="text-align:center">empty</td>
<td style="text-align:center">destinations that match will always be passed across the network - even if no consumers have ever registered an interest</td>
</tr>
<tr>
<td style="text-align:center">duplex</td>
<td style="text-align:center">false</td>
<td style="text-align:center">if true, a network connection will be used to both produce AND Consume messages. This is useful for hub and spoke scenarios when the hub is behind a firewall etc.</td>
</tr>
</tbody>
</table>
<p>关于conduitSubscriptions属性，这里稍稍说明一下。设想有两个brokers，分别是brokerA和brokerB，它们之间用 forwarding bridge连接。有一个consumer连接到brokerA并订阅queue：<code>Q.TEST</code>。有两个consumers连接到brokerB，也是订 阅queue：<code>Q.TEST</code>。这三个consumers有相同的优先级。然后启动一个producer。</p>
]]></content>
    
    <summary type="html">
    
      ActiveMQ理解
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActiveMQ/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>JMS概念</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMQ_%E5%88%9D%E6%AD%A5%E5%85%A5%E9%97%A8%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMQ_初步入门及相关概念理解/</id>
    <published>2017-04-05T05:45:24.000Z</published>
    <updated>2017-04-05T20:24:34.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JMS的基本构件"><a href="#JMS的基本构件" class="headerlink" title="JMS的基本构件"></a>JMS的基本构件</h2><h3 id="连接工厂"><a href="#连接工厂" class="headerlink" title="连接工厂"></a>连接工厂</h3><p>连接工厂是客户用来创建连接的对象，例如ActiveMQ提供的<code>ActiveMQConnectionFactory</code>。 </p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>JMS <code>Connection</code>封装了客户与JMS提供者之间的一个虚拟的连接。 </p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>JMS <code>Session</code>是生产和消费消息的一个单线程上下文。会话用于创建消息生产者（producer）、消息消费者（consumer）和消息（message）等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接收被组合到了一个原子操作中。 </p>
<h3 id="目的地"><a href="#目的地" class="headerlink" title="目的地"></a>目的地</h3><p>目的地是客户用来指定它生产的消息的目标和它消费的消息的来源的对象。JMS1.0.2规范中定义了两种消息传递域：点对点（PTP）消息传递域和发布/订阅消息传递域。 </p>
<h4 id="点对点消息传递域的特点如下："><a href="#点对点消息传递域的特点如下：" class="headerlink" title="点对点消息传递域的特点如下："></a>点对点消息传递域的特点如下：</h4><p>• 每个消息只能有一个消费者。<br>• 消息的生产者和消费者之间没有时间上的相关性。无论消费者在生产者发送消息的时候是否处于运行状态，它都可以提取消息。(前提是没有其他消费者消费了该消息)<br>• 在点对点消息传递域中，目的地被称为队列（queue）</p>
<h4 id="发布-订阅消息传递域的特点如下："><a href="#发布-订阅消息传递域的特点如下：" class="headerlink" title="发布/订阅消息传递域的特点如下："></a>发布/订阅消息传递域的特点如下：</h4><p>• 每个消息可以有多个消费者。<br>• 生产者和消费者之间有时间上的相关性。订阅一个主题的消费者只能消费自它订阅之后发布的消息。JMS规范允许客户创建持久订阅，这在一定程度上放松了时间上的相关性要求。持久订阅允许消费者消费它在未处于激活状态时发送的消息。<br>• 在发布/订阅消息传递域中，目的地被称为主题（topic）。 </p>
<h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><p>消息生产者是由会话创建的一个对象，用于把消息发送到一个目的地。 </p>
<h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>消息消费者是由会话创建的一个对象，它用于接收发送到目的地的消息。消息的消费可以采用以下两种方法之一： </p>
<p>• 同步消费。通过调用消费者的<code>receive</code>方法从目的地中显式提取消息。<code>receive</code>方法可以一直阻塞到消息到达。<br>• 异步消费。客户可以为消费者注册一个消息监听器，以定义在消息到达时所采取的动作。 </p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>JMS消息由以下三部分组成：<br>• 消息头。每个消息头字段都有相应的getter和setter方法。<br>• 消息属性。如果需要除消息头字段以外的值，那么可以使用消息属性。<br>• 消息体。JMS定义的消息类型有<code>TextMessage</code>、<code>MapMessage</code>、<code>BytesMessage</code>、<code>StreamMessage</code>和<code>ObjectMessage</code>。 </p>
<h2 id="JMS的可靠性机制"><a href="#JMS的可靠性机制" class="headerlink" title="JMS的可靠性机制"></a>JMS的可靠性机制</h2><h3 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h3><p>JMS消息只有在被确认之后，才认为已经被成功地消费了。消息的成功消费通常包含三个阶段：客户接收消息、客户处理消息和消息被确认。<br>在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式（acknowledgement mode）。该参数有以下三个可选值：<br>• <code>Session.AUTO_ACKNOWLEDGE</code>。当客户成功地从<code>receive</code>方法返回的时候，或者从<code>MessageListener.onMessage</code>方法成功返回的时候，会话自动确认客户收到的消息。<br>• <code>Session.CLIENT_ACKNOWLEDGE</code>。 客户通过消息的<code>acknowledge</code>方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行：确认一个被消费的消息将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。<br>• <code>Session.DUPS_OK_ACKNOWLEDGE</code>。 </p>
<p>The duplicates okay acknowledgement mode closely resembles the auto acknowledgement mode. However, rather than pass <code>Session.AUTO_ACKNOWLEDGE</code>, you specify <code>Session.DUPS_OK_ACKNOWLEDGE</code> as the acknowledgement mode of <code>createSession()</code>‘s second argument. With less overhead than auto mode, in duplicates okay mode, the JMS provider guarantees at-least-once message delivery. During failure recovery, certain messages are probably delivered more than once.如果JMS provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的<code>JMSRedelivered</code>字段设置为true。 </p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>JMS 支持以下两种消息提交模式：<br>• <code>PERSISTENT</code>。指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失。<br>• <code>NON_PERSISTENT</code>。不要求JMS provider持久保存消息。 </p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>可以使用消息优先级来指示JMS provider首先提交紧急的消息。优先级分10个级别，从0（最低）到9（最高）。如果不指定优先级，默认级别是4。需要注意的是，JMS provider并不一定保证按照优先级的顺序提交消息。 </p>
<h3 id="消息过期"><a href="#消息过期" class="headerlink" title="消息过期"></a>消息过期</h3><p>可以设置消息在一定时间后过期，默认是永不过期。 </p>
<h3 id="临时目的地"><a href="#临时目的地" class="headerlink" title="临时目的地"></a>临时目的地</h3><p>可以通过会话上的<code>createTemporaryQueue</code>方法和<code>createTemporaryTopic</code>方法来创建临时目的地。它们的存在时间只限于创建它们的连接所保持的时间。只有创建该临时目的地的连接上的消息消费者才能够从临时目的地中提取消息。 </p>
<h3 id="持久订阅"><a href="#持久订阅" class="headerlink" title="持久订阅"></a>持久订阅</h3><p>首先消息生产者必须使用<code>PERSISTENT</code>提交消息。客户可以通过会话上的<code>createDurableSubscriber</code>方法来创建一个持久订阅，该方法的第一个参数必须是一个<code>topic</code>。第二个参数是订阅的名称。<br>JMS provider会存储发布到持久订阅对应的topic上的消息。如果最初创建持久订阅的客户或者任何其它客户使用相同的连接工厂和连接的客户ID、相同的主题和相同的订阅名再次调用会话上的<code>createDurableSubscriber</code>方法，那么该持久订阅就会被激活。JMS provider会向客户发送客户处于非激活状态时所发布的消息。<br><strong>持久订阅在某个时刻只能有一个激活的订阅者。</strong>持久订阅在创建之后会一直保留，直到应用程序调用会话上的<code>unsubscribe</code>方法。 </p>
<h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>在一个JMS客户端，可以使用本地事务来组合消息的发送和接收。JMS Session接口提供了<code>commit</code>和<code>rollback</code>方法。<br>事务提交意味着生产的所有消息被发送，消费的所有消息被确认；事务回滚意味着生产的所有消息被销毁，消费的所有消息被恢复并重新提交，除非它们已经过期。 </p>
<blockquote>
<p>需要注意的是，如果使用请求/回复机制，即发送一个消息，同时希望在同一个事务中等待接收该消息的回复，那么程序将被挂起，因为直到事务提交，发送操作才会真正执行。<br>所以，消息的生产和消费不能包含在同一个事务中。 </p>
</blockquote>
<h2 id="JMS-规范的变迁"><a href="#JMS-规范的变迁" class="headerlink" title="JMS 规范的变迁"></a>JMS 规范的变迁</h2><p>JMS最新版本是1.1。它和1.0.2版本最大的差别是，JMS1.1通过统一消息传递域简化了消息传递。这不仅简化了JMS API，也有利于开发人员灵活选择消息传递域，同时也有助于程序的重用和维护。<br>以下是不同消息传递域的相应接口： </p>
<table>
<thead>
<tr>
<th style="text-align:center">JMS公共</th>
<th style="text-align:center">点对点域</th>
<th style="text-align:center">发布/订阅域</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ConnectionFactory</code></td>
<td style="text-align:center"><code>QueueConnectionFactory</code></td>
<td style="text-align:center"><code>TopicConnectionFactory</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Connection</code></td>
<td style="text-align:center"><code>QueueConnection</code></td>
<td style="text-align:center"><code>TopicConnection</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Destination</code></td>
<td style="text-align:center"><code>Queue</code></td>
<td style="text-align:center"><code>Topic</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Session</code></td>
<td style="text-align:center"><code>QueueSession</code></td>
<td style="text-align:center"><code>TopicSession</code></td>
</tr>
<tr>
<td style="text-align:center"><code>MessageProducer</code></td>
<td style="text-align:center"><code>QueueSender</code></td>
<td style="text-align:center"><code>TopicPublisher</code></td>
</tr>
<tr>
<td style="text-align:center"><code>MessageConsumer</code></td>
<td style="text-align:center"><code>QueueReceiver</code></td>
<td style="text-align:center"><code>TopicSubscriber</code></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      JMS概念
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMq性能优化</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMq%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMq性能优化/</id>
    <published>2017-04-05T05:30:41.000Z</published>
    <updated>2017-04-05T05:38:01.424Z</updated>
    
    <content type="html"><![CDATA[<p>ActiveMq是比较稳定的，吞吐速度也很快，如果出现入队列或者出队列慢问题，先检查一下自己的代码，是不是本身取到数据后处理过慢。</p>
<h2 id="1-使用spring的JmsTemplate"><a href="#1-使用spring的JmsTemplate" class="headerlink" title="1. 使用spring的JmsTemplate"></a>1. 使用spring的<code>JmsTemplate</code></h2><p><code>JmsTemplate</code>的<code>send</code>和<code>convertAndSend</code>会使用持久化<code>mode</code>，即使你设置了<code>NON_PERSISTENT</code>。这会导致入队列速度变得非常慢。</p>
<p>解决办法，使用下面的<code>MyJmsTemplate</code>代替<code>JmsTemplate</code>。</p>
<pre><code>public class MyJmsTemplate extends JmsTemplate {
    private Session session;

    public MyJmsTemplate() {
        super();
    }

    public MyJmsTemplate(ConnectionFactory connectionFactory) {
        super(connectionFactory);
    }

    public void doSend(MessageProducer producer, Message message) throws JMSException {
        if (isExplicitQosEnabled()) {
            producer.send(message, getDeliveryMode(), getPriority(), getTimeToLive());
        } else {
            producer.send(message);
        }
    }

    public Session getSession() {
        return session;
    }

    public void setSession(Session session) {
        this.session = session;
    }
}
</code></pre><h2 id="2-DeliveryMode的选择，如果你入队列的数据，不考虑MQ挂掉的情况（这概率很小），使用NON-PERSISTENT会显著提高数据写入速度。"><a href="#2-DeliveryMode的选择，如果你入队列的数据，不考虑MQ挂掉的情况（这概率很小），使用NON-PERSISTENT会显著提高数据写入速度。" class="headerlink" title="2. DeliveryMode的选择，如果你入队列的数据，不考虑MQ挂掉的情况（这概率很小），使用NON_PERSISTENT会显著提高数据写入速度。"></a>2. <code>DeliveryMode</code>的选择，如果你入队列的数据，不考虑MQ挂掉的情况（这概率很小），使用<code>NON_PERSISTENT</code>会显著提高数据写入速度。</h2><h2 id="3-生产者使用事务会提高入队列性能，但是消费者如果启动了事务则会显著影响数据的消费速度。"><a href="#3-生产者使用事务会提高入队列性能，但是消费者如果启动了事务则会显著影响数据的消费速度。" class="headerlink" title="3. 生产者使用事务会提高入队列性能，但是消费者如果启动了事务则会显著影响数据的消费速度。"></a>3. 生产者使用事务会提高入队列性能，但是消费者如果启动了事务则会显著影响数据的消费速度。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</div></pre></td></tr></table></figure>
<p>代码中的<code>false</code>代表不启动事物。</p>
<h2 id="4-消费者的消息处理即onMessage方法优化"><a href="#4-消费者的消息处理即onMessage方法优化" class="headerlink" title="4. 消费者的消息处理即onMessage方法优化:"></a>4. 消费者的消息处理即<code>onMessage方</code>法优化:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class SmsMoPool implements MessageListener &#123;</div><div class="line">    private final static Logger logger = LoggerFactory.getLogger(SmsMoPool.class);</div><div class="line">    private DefaultEventPubliser moEventPublisher;</div><div class="line">    private final EventFactory eventFactory = new DefaultEventFactory();</div><div class="line">    private DefaultDataGather dataGather;</div><div class="line">    private ExecutorService pool = Executors.newFixedThreadPool(5);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onMessage(final Message message) &#123;</div><div class="line">        pool.execute(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                final ObjectMessage msg = (ObjectMessage) message;</div><div class="line">                Serializable obj = null;</div><div class="line">                try &#123;</div><div class="line">                    obj = msg.getObject();</div><div class="line">                &#125; catch (JMSException e) &#123;</div><div class="line">                    logger.error(&quot;从消息队列获得上行信息异常&#123;&#125;&quot;, e);</div><div class="line">                &#125;</div><div class="line">                if (obj != null) &#123;</div><div class="line">                    dataGather.incrementDateCount(MasEntityConstants.TRAFFIC_SMS_MO_IN);</div><div class="line">                    AgentToServerReq req = (AgentToServerReq) obj;</div><div class="line">                    if (logger.isInfoEnabled()) &#123;</div><div class="line">                        logger.info(&quot;驱动--&gt;调度：&#123;&#125;&quot;, req.toXmlStr());</div><div class="line">                    &#125;</div><div class="line">                    Event event = eventFactory.createMoEvent(req);</div><div class="line">                    moEventPublisher.publishEvent(event);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码使用了线程池，另一点要注意的是<code>msg.getObject();</code>这个方法是一个比较耗时的方法，你的代码中不应该出现多次<code>getObject()</code>。</p>
<h2 id="5-消费者使用预取，如何使用预取，下面以spring版本为例"><a href="#5-消费者使用预取，如何使用预取，下面以spring版本为例" class="headerlink" title="5. 消费者使用预取，如何使用预取，下面以spring版本为例"></a>5. 消费者使用预取，如何使用预取，下面以spring版本为例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;</div><div class="line">    &lt;constructor-arg value=&quot;data.mo?consumer.prefetchSize=100&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>预取数量根据具体入队列数据而定，以上设置100，是针对2000/sec入队列速度设定的。<br>另外如果是慢消费者，这里可设置为1。</p>
<h2 id="6-检查你的MQ数据吞吐速度，保持生产和消费的平衡，不会出现大量积压。"><a href="#6-检查你的MQ数据吞吐速度，保持生产和消费的平衡，不会出现大量积压。" class="headerlink" title="6. 检查你的MQ数据吞吐速度，保持生产和消费的平衡，不会出现大量积压。"></a>6. 检查你的MQ数据吞吐速度，保持生产和消费的平衡，不会出现大量积压。</h2><h2 id="7-ActiveMQ使用TCP协议时tcpNoDelay-默认是false-，设置为true可以提高性能。"><a href="#7-ActiveMQ使用TCP协议时tcpNoDelay-默认是false-，设置为true可以提高性能。" class="headerlink" title="7. ActiveMQ使用TCP协议时tcpNoDelay=默认是false ，设置为true可以提高性能。"></a>7. ActiveMQ使用TCP协议时<code>tcpNoDelay=</code>默认是<code>false</code> ，设置为<code>true</code>可以提高性能。</h2><p>还是spring版本的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;mqPoolConnectionFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot; destroy-method=&quot;stop&quot;&gt;</div><div class="line">       &lt;property name=&quot;connectionFactory&quot;&gt;</div><div class="line">           &lt;bean id=&quot;mqConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot; p:useAsyncSend=&quot;true&quot;</div><div class="line">                 p:brokerURL=&quot;failover://(tcp://127.0.0.1:61616?tcpNoDelay=true)&quot;/&gt;</div><div class="line">       &lt;/property&gt;</div><div class="line">   &lt;/bean&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      ActiveMq性能优化
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActivefMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActivefMQ/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出JMS(一)--JMS基本概念</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJMS_%E4%B8%80_--JMS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/深入浅出JMS_一_--JMS基本概念/</id>
    <published>2017-04-05T05:15:49.000Z</published>
    <updated>2017-04-05T05:28:39.827Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>The Java Message Service (JMS) API is a messaging standard that allows application components based on the Java Platform Enterprise Edition (Java EE) to create, send, receive, and read messages. It enables distributed communication that is loosely coupled, reliable, and asynchronous.</p>
</blockquote>
<p>JMS（JAVA Message Service,java消息服务）API是一个消息服务的标准(规范)，允许基于JavaEE平台的应用程序组件创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠并采用异步方式。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JMS是java的消息服务，JMS的客户端之间通过JMS服务进行异步消息传输。</p>
<h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><ul>
<li>Point-to-Point(P2P)</li>
<li>Publish/Subscribe(Pub/Sub)</li>
</ul>
<p>即点对点和发布订阅模型</p>
<h4 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h4><p><img src="/img/JMS P2P模式" alt="JMS P2P模式"></p>
<ul>
<li>消息队列（Queue）</li>
<li>发送者(Sender)</li>
<li>接收者(Receiver)</li>
</ul>
<p>每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到它们被消费或超时。</p>
<h5 id="P2P的特点"><a href="#P2P的特点" class="headerlink" title="P2P的特点"></a>P2P的特点</h5><p>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)<br>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列；接收者在成功接收消息之后需向队列应答成功；如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。</p>
<h4 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h4><p><img src="/img/Pub Sub模式图" alt="Pub/Sub模式图"> </p>
<ul>
<li>主题（Topic）</li>
<li>发布者（Publisher）</li>
<li>订阅者（Subscriber） </li>
</ul>
<p>多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p>
<h5 id="Pub-Sub的特点"><a href="#Pub-Sub的特点" class="headerlink" title="Pub/Sub的特点"></a>Pub/Sub的特点</h5><ul>
<li>每个消息可以有多个消费者</li>
<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。</li>
<li>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</li>
<li>如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型</li>
</ul>
<h2 id="消息的消费"><a href="#消息的消费" class="headerlink" title="消息的消费"></a>消息的消费</h2><p>在JMS中，消息的产生和消息是异步的。</p>
<ul>
<li>同步<br>订阅者或接收者调用<code>receive</code>方法来接收消息，<code>receive</code>方法在能够接收到消息之前（或超时之前）将一直阻塞 </li>
<li>异步<br>订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的<code>onMessage</code>方法。</li>
</ul>
<h2 id="JMS编程模型"><a href="#JMS编程模型" class="headerlink" title="JMS编程模型"></a>JMS编程模型</h2><p>(1) <code>ConnectionFactory</code></p>
<p>创建<code>Connection</code>对象的工厂，针对两种不同的jms消息模型，分别有<code>QueueConnectionFactory</code>和<code>TopicConnectionFactory</code>两种。可以通过JNDI来查找<code>ConnectionFactory</code>对象。</p>
<p>(2) <code>Destination</code></p>
<p><code>Destination</code>的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者或消费者来说，它的<code>Destination</code>是某个队列（Queue）或某个主题（Topic）。</p>
<p><code>Destination</code>实际上就是两种类型的对象：<code>Queue</code>、<code>Topic</code>。<br>(3) <code>Connection</code></p>
<p><code>Connection</code>表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。<code>Connection</code>可以产生一个或多个<code>Session</code>。跟<code>ConnectionFactory</code>一样，<code>Connection</code>也有两种类型：<code>QueueConnection</code>和<code>TopicConnection</code>。</p>
<p>(4) <code>Session</code></p>
<p><code>Session</code>是操作消息的接口。可以通过session创建生产者、消费者、消息等。<code>Session</code>提供了事务的功能。当需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分<code>QueueSession</code>和<code>TopicSession</code>。</p>
<p>(5) 消息的生产者</p>
<p>消息生产者由<code>Session</code>创建，并用于将消息发送到<code>Destination</code>。同样，消息生产者分两种类型：<code>QueueSender</code>和<code>TopicPublisher</code>。可以调用消息生产者的方法（<code>send</code>或<code>publish</code>方法）发送消息。</p>
<p>(6) 消息消费者</p>
<p>消息消费者由<code>Session</code>创建，用于接收被发送到<code>Destination</code>的消息。两种类型：<code>QueueReceiver</code>和<code>TopicSubscriber</code>。可分别通过<code>session</code>的<code>createReceiver(Queue)</code>或<code>createSubscriber(Topic)</code>来创建。当然，也可以<code>session</code>的<code>creatDurableSubscriber</code>方法来创建持久化的订阅者。</p>
<p>(7) <code>MessageListener</code></p>
<p>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的<code>onMessage</code>方法。EJB中的MDB（Message-Driven Bean）就是一种<code>MessageListener</code>。</p>
<h2 id="企业消息系统的好处"><a href="#企业消息系统的好处" class="headerlink" title="企业消息系统的好处"></a>企业消息系统的好处</h2><p>应用程序A将Message发送到服务器上，然后应用程序B从服务器中接收A发来的消息： </p>
<p><img src="/img/企业消息系统的好处" alt="企业消息系统的好处"></p>
<ul>
<li>提供消息灵活性</li>
<li>松散耦合</li>
<li>异步性</li>
</ul>
]]></content>
    
    <summary type="html">
    
      深入浅出JMS(一)--JMS基本概念
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ入门实例</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMQ%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMQ入门实例/</id>
    <published>2017-04-05T05:08:11.000Z</published>
    <updated>2017-04-05T05:14:59.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-下载ActiveMQ"><a href="#1-下载ActiveMQ" class="headerlink" title="1.下载ActiveMQ"></a>1.下载ActiveMQ</h2><p>去官方网站下载：<a href="http://activemq.apache.org/" target="_blank" rel="external">http://activemq.apache.org/</a></p>
<h2 id="2-运行ActiveMQ"><a href="#2-运行ActiveMQ" class="headerlink" title="2.运行ActiveMQ"></a>2.运行ActiveMQ</h2><p>解压缩<code>apache-activemq-5.5.1-bin.zip</code>，然后双击<code>apache-activemq-5.5.1\bin\activemq.bat</code>运行ActiveMQ程序。</p>
<p>启动ActiveMQ以后，登陆：<code>http://localhost:8161/admin/</code>，创建一个<code>Queue</code>，命名为<code>FirstQueue</code>。</p>
<h2 id="3-创建Eclipse项目并运行"><a href="#3-创建Eclipse项目并运行" class="headerlink" title="3.创建Eclipse项目并运行"></a>3.创建Eclipse项目并运行</h2><p>创建project：<code>ActiveMQ-5.5</code>，并导入<code>apache-activemq-5.5.1\lib</code>目录下需要用到的jar文件，项目结构如下图所示：</p>
<p><img src="/img/ActiveMQ的Eclipse项目.jpg" alt="ActiveMQ的Eclipse项目"></p>
<h3 id="3-1-Sender-java"><a href="#3-1-Sender-java" class="headerlink" title="3.1.Sender.java"></a>3.1.<code>Sender.java</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.activemq;</div><div class="line"></div><div class="line">import javax.jms.Connection;</div><div class="line">import javax.jms.ConnectionFactory;</div><div class="line">import javax.jms.DeliveryMode;</div><div class="line">import javax.jms.Destination;</div><div class="line">import javax.jms.MessageProducer;</div><div class="line">import javax.jms.Session;</div><div class="line">import javax.jms.TextMessage;</div><div class="line">import org.apache.activemq.ActiveMQConnection;</div><div class="line">import org.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"></div><div class="line">public class Sender &#123;</div><div class="line">    private static final int SEND_NUMBER = 5;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // ConnectionFactory ：连接工厂，JMS 用它创建连接</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        // Connection ：JMS 客户端到JMS Provider 的连接</div><div class="line">        Connection connection = null;</div><div class="line">        // Session： 一个发送或接收消息的线程</div><div class="line">        Session session;</div><div class="line">        // Destination ：消息的目的地;消息发送给谁.</div><div class="line">        Destination destination;</div><div class="line">        // MessageProducer：消息发送者</div><div class="line">        MessageProducer producer;</div><div class="line">        // TextMessage message;</div><div class="line">        // 构造ConnectionFactory实例对象，此处采用ActiveMq的实现jar</div><div class="line">        connectionFactory = new ActiveMQConnectionFactory(</div><div class="line">                ActiveMQConnection.DEFAULT_USER,</div><div class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</div><div class="line">                &quot;tcp://localhost:61616&quot;);</div><div class="line">        try &#123;</div><div class="line">            // 构造从工厂得到连接对象</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            // 启动</div><div class="line">            connection.start();</div><div class="line">            // 获取操作连接</div><div class="line">            session = connection.createSession(Boolean.TRUE,</div><div class="line">                    Session.AUTO_ACKNOWLEDGE);</div><div class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</div><div class="line">            // 得到消息生成者【发送者】</div><div class="line">            producer = session.createProducer(destination);</div><div class="line">            // 设置不持久化，此处学习，实际根据项目决定</div><div class="line">            producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</div><div class="line">            // 构造消息，此处写死</div><div class="line">            sendMessage(session, producer);</div><div class="line">            session.commit();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (null != connection)</div><div class="line">                    connection.close();</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void sendMessage(Session session, MessageProducer producer)</div><div class="line">            throws Exception &#123;</div><div class="line">        for (int i = 1; i &lt;= SEND_NUMBER; i++) &#123;</div><div class="line">            TextMessage message = session</div><div class="line">                    .createTextMessage(&quot;ActiveMq 发送的消息&quot; + i);</div><div class="line">            // 发送消息到目的地方</div><div class="line">            System.out.println(&quot;发送消息：&quot; + &quot;ActiveMq 发送的消息&quot; + i);</div><div class="line">            producer.send(message);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-Receiver-java"><a href="#3-2-Receiver-java" class="headerlink" title="3.2.Receiver.java"></a>3.2.Receiver.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.activemq;</div><div class="line"></div><div class="line">import javax.jms.Connection;</div><div class="line">import javax.jms.ConnectionFactory;</div><div class="line">import javax.jms.Destination;</div><div class="line">import javax.jms.MessageConsumer;</div><div class="line">import javax.jms.Session;</div><div class="line">import javax.jms.TextMessage;</div><div class="line">import org.apache.activemq.ActiveMQConnection;</div><div class="line">import org.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"></div><div class="line">public class Receiver &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // ConnectionFactory ：连接工厂，JMS 用它创建连接</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        // Connection ：JMS 客户端到JMS Provider 的连接</div><div class="line">        Connection connection = null;</div><div class="line">        // Session： 一个发送或接收消息的线程</div><div class="line">        Session session;</div><div class="line">        // Destination ：消息的目的地;消息发送给谁.</div><div class="line">        Destination destination;</div><div class="line">        // 消费者，消息接收者</div><div class="line">        MessageConsumer consumer;</div><div class="line">        connectionFactory = new ActiveMQConnectionFactory(</div><div class="line">                ActiveMQConnection.DEFAULT_USER,</div><div class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</div><div class="line">                &quot;tcp://localhost:61616&quot;);</div><div class="line">        try &#123;</div><div class="line">            // 构造从工厂得到连接对象</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            // 启动</div><div class="line">            connection.start();</div><div class="line">            // 获取操作连接</div><div class="line">            session = connection.createSession(Boolean.FALSE,</div><div class="line">                    Session.AUTO_ACKNOWLEDGE);</div><div class="line">   </div><div class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</div><div class="line">            consumer = session.createConsumer(destination);</div><div class="line">            while (true) &#123;</div><div class="line">                //设置接收者接收消息的时间，为了便于测试，这里谁定为100s</div><div class="line">                TextMessage message = (TextMessage) consumer.receive(100000);</div><div class="line">                if (null != message) &#123;</div><div class="line">                    System.out.println(&quot;收到消息&quot; + message.getText());</div><div class="line">                &#125; else &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (null != connection)</div><div class="line">                    connection.close();</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h2><p>最后接收者跟发送者在不同的机器上测试</p>
<h2 id="5-测试过程"><a href="#5-测试过程" class="headerlink" title="5.测试过程"></a>5.测试过程</h2><p>运行<code>Receiver</code>后没有任何信息，运行Sender以后，显示如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">发送消息：ActiveMq 发送的消息1</div><div class="line">发送消息：ActiveMq 发送的消息2</div><div class="line">发送消息：ActiveMq 发送的消息3</div><div class="line">发送消息：ActiveMq 发送的消息4</div><div class="line">发送消息：ActiveMq 发送的消息5</div></pre></td></tr></table></figure></p>
<p>而<code>Receiver</code>现如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">收到消息ActiveMq 发送的消息1</div><div class="line">收到消息ActiveMq 发送的消息2</div><div class="line">收到消息ActiveMq 发送的消息3</div><div class="line">收到消息ActiveMq 发送的消息4</div><div class="line">收到消息ActiveMq 发送的消息5</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      ActiveMQ入门实例
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>activemq的几种基本通信方式总结</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/activemq%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/activemq的几种基本通信方式总结/</id>
    <published>2017-04-05T03:09:12.000Z</published>
    <updated>2017-04-05T05:07:35.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>面向消息队列是一个总体比较合理的应用系统集成方案。<br>ActiveMQ是JMS消息通信规范的一个实现。消息通信模式主要有发布-订阅、点对点。</p>
<h2 id="基础流程"><a href="#基础流程" class="headerlink" title="基础流程"></a>基础流程</h2><p>ActiveMQ启动服务的过程:</p>
<ol>
<li>获得JMS connection factory，通过提供特定环境的连接信息来构造factory。</li>
<li>利用factory构造JMS connection.</li>
<li>启动connection</li>
<li>通过connection创建JMS session.</li>
<li>指定JMS destination.</li>
<li>创建JMS producer和JMS message并提供destination.</li>
<li>创建JMS consumer和注册JMS message listener.</li>
<li>发送和接收JMS message.</li>
<li>关闭所有JMS资源，包括connection, session, producer, consumer等。</li>
</ol>
<h2 id="publish-subscribe"><a href="#publish-subscribe" class="headerlink" title="publish-subscribe"></a>publish-subscribe</h2><p>发布订阅模式类似于订阅报纸。</p>
<p><img src="/img/JMS发布订阅模式示意图.jpg" alt="JMS发布订阅模式示意图"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="publisher"><a href="#publisher" class="headerlink" title="publisher"></a>publisher</h4><p>publisher是属于发布信息的一方，它通过定义一个或者多个topic，然后给这些topic发送消息。<br>publisher的构造函数如下：</p>
<pre><code>public Publisher() throws JMSException {  
    factory = new ActiveMQConnectionFactory(brokerURL);  
    connection = factory.createConnection();  
    try {  
        connection.start();  
    } catch (JMSException jmse) {  
        connection.close();  
        throw jmse;  
    }  
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
    producer = session.createProducer(null);  
}
</code></pre><p>按照前面说的流程定义了基本的<code>connectionFactory</code>, <code>connection</code>,<code>session</code>,<code>producer</code>。。</p>
<h4 id="接着定义一系列的topic让所有的consumer来订阅"><a href="#接着定义一系列的topic让所有的consumer来订阅" class="headerlink" title="接着定义一系列的topic让所有的consumer来订阅"></a>接着定义一系列的topic让所有的consumer来订阅</h4><pre><code>protected void setTopics(String[] stocks) throws JMSException {  
    destinations = new Destination[stocks.length];  
    for(int i = 0; i &lt; stocks.length; i++) {  
        destinations[i] = session.createTopic(&quot;STOCKS.&quot; + stocks[i]);  
    }  
}  
</code></pre><h4 id="定义好topic之后要给这些指定的topic发消息："><a href="#定义好topic之后要给这些指定的topic发消息：" class="headerlink" title="定义好topic之后要给这些指定的topic发消息："></a>定义好topic之后要给这些指定的topic发消息：</h4><pre><code>protected void sendMessage(String[] stocks) throws JMSException {  
    for(int i = 0; i &lt; stocks.length; i++) {  
        Message message = createStockMessage(stocks[i], session);  
        System.out.println(&quot;Sending: &quot; + ((ActiveMQMapMessage)message).getContentMap() + &quot; on destination: &quot; + destinations[i]);  
        producer.send(destinations[i], message);  
    }  
}  

protected Message createStockMessage(String stock, Session session) throws JMSException {  
    MapMessage message = session.createMapMessage();  
    message.setString(&quot;stock&quot;, stock);  
    message.setDouble(&quot;price&quot;, 1.00);  
    message.setDouble(&quot;offer&quot;, 0.01);  
    message.setBoolean(&quot;up&quot;, true);          
    return message;  
}  
</code></pre><p>在<code>sendMessage</code>方法里遍历每个<code>topic</code>，然后给每个<code>topic</code>发送定义的<code>Message</code>消息。</p>
<h4 id="publisher发布消息"><a href="#publisher发布消息" class="headerlink" title="publisher发布消息"></a>publisher发布消息</h4><pre><code>public static void main(String[] args) throws JMSException {  
    if(args.length &lt; 1)  
        throw new IllegalArgumentException();  

    // Create publisher       
    Publisher publisher = new Publisher();  

    // Set topics  
    publisher.setTopics(args);  

    for(int i = 0; i &lt; 10; i++) {  
        publisher.sendMessage(args);  
        System.out.println(&quot;Publisher &apos;&quot; + i + &quot; price messages&quot;);  
        try {  
            Thread.sleep(1000);  
        } catch(InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
    // Close all resources  
    publisher.close();  
}  
</code></pre><h4 id="close方法关闭资源："><a href="#close方法关闭资源：" class="headerlink" title="close方法关闭资源："></a><code>close</code>方法关闭资源：</h4><pre><code>public void close() throws JMSException {  
    if (connection != null) {  
        connection.close();  
    }  
}  
</code></pre><h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><p>具体的步骤:<br>1.初始化资源。 </p>
<ol>
<li>接收消息。 </li>
<li>必要的时候关闭资源。</li>
</ol>
<h4 id="初始化资源放到构造函数里面："><a href="#初始化资源放到构造函数里面：" class="headerlink" title="初始化资源放到构造函数里面："></a>初始化资源放到构造函数里面：</h4><pre><code>public Consumer() throws JMSException {  
    factory = new ActiveMQConnectionFactory(brokerURL);  
    connection = factory.createConnection();  
    connection.start();  
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
}  
</code></pre><h4 id="接收和处理消息的方法"><a href="#接收和处理消息的方法" class="headerlink" title="接收和处理消息的方法"></a>接收和处理消息的方法</h4><p>分为同步和异步的：</p>
<ul>
<li>同步  <code>MessageConsumer.receive()</code>方法</li>
<li><p>异步  注册<code>MessageListener</code>，使用<code>MessageConsumer.setMessageListener()</code>。</p>
<p>  public static void main(String[] args) throws JMSException {  </p>
<pre><code>Consumer consumer = new Consumer();  
for (String stock : args) {  
    Destination destination = consumer.getSession().createTopic(&quot;STOCKS.&quot; + stock);  
    MessageConsumer messageConsumer = consumer.getSession().createConsumer(destination);  
    messageConsumer.setMessageListener(new Listener());  
}  
</code></pre><p>  }  </p>
<p>  public Session getSession() {  </p>
<pre><code>return session;  
</code></pre><p>  }  </p>
</li>
</ul>
<blockquote>
<p>这里的代码不要当真了，写得很烂</p>
</blockquote>
<h4 id="Listener负责处理接收到的消息："><a href="#Listener负责处理接收到的消息：" class="headerlink" title="Listener负责处理接收到的消息："></a><code>Listener</code>负责处理接收到的消息：</h4><pre><code>public class Listener implements MessageListener {  
    public void onMessage(Message message) {  
        try {  
            MapMessage map = (MapMessage)message;  
            String stock = map.getString(&quot;stock&quot;);  
            double price = map.getDouble(&quot;price&quot;);  
            double offer = map.getDouble(&quot;offer&quot;);  
            boolean up = map.getBoolean(&quot;up&quot;);  
            DecimalFormat df = new DecimalFormat( &quot;#,###,###,##0.00&quot; );  
            System.out.println(stock + &quot;\t&quot; + df.format(price) + &quot;\t&quot; + df.format(offer) + &quot;\t&quot; + (up?&quot;up&quot;:&quot;down&quot;));  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  
}  
</code></pre><p>实现了<code>MessageListener</code>接口，里面的<code>onMessage</code>方法在接收到消息之后会被调用的方法。</p>
<h3 id="实现pub-sub模式的步骤"><a href="#实现pub-sub模式的步骤" class="headerlink" title="实现pub-sub模式的步骤"></a>实现pub-sub模式的步骤</h3><p>两者设定一个共同的topic。</p>
<p>在publisher端通过<code>session</code>创建<code>producer</code>，根据指定的参数创建<code>destination</code>，然后将消息和<code>destination</code>作为<code>producer.send()</code>方法的参数。</p>
<p>在consumer端也要创建类似的<code>connection</code>,<code>session</code>。通过<code>session</code>得到<code>destination</code>，再通过<code>session.createConsumer(destination)</code>来得到一个<code>MessageConsumer</code>对象。有了这个<code>MessageConsumer</code>就可以自行选择是直接同步的<code>receive</code>消息还是注册listener了。</p>
<h2 id="p2p"><a href="#p2p" class="headerlink" title="p2p"></a>p2p</h2><p><img src="/img/JMS点对点模式示意图.jpg" alt="JMS点对点模式示意图"></p>
<p>在p2p的场景里，相互通信的双方是通过一个类似于队列的方式来进行交流。和pub-sub的区别在于一个消息会发送给订阅此topic的多个订阅者，而在p2p里queue的消息只能被一个接受者接受。</p>
<h3 id="发送者"><a href="#发送者" class="headerlink" title="发送者"></a>发送者</h3><pre><code>public Publisher() throws JMSException {  
    factory = new ActiveMQConnectionFactory(brokerURL);  
    connection = factory.createConnection();  
    connection.start();  
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
    producer = session.createProducer(null);  
}
</code></pre><h4 id="发送消息："><a href="#发送消息：" class="headerlink" title="发送消息："></a>发送消息：</h4><pre><code>public void sendMessage() throws JMSException {  
    for(int i = 0; i &lt; jobs.length; i++)  
    {  
        String job = jobs[i];  
        Destination destination = session.createQueue(&quot;JOBS.&quot; + job);  
        Message message = session.createObjectMessage(i);  
        System.out.println(&quot;Sending: id: &quot; + ((ObjectMessage)message).getObject() + &quot; on queue: &quot; + destination);  
        producer.send(destination, message);  
    }  
}  
</code></pre><h4 id="消息发送者的启动代码："><a href="#消息发送者的启动代码：" class="headerlink" title="消息发送者的启动代码："></a>消息发送者的启动代码：</h4><pre><code>public static void main(String[] args) throws JMSException {  
    Publisher publisher = new Publisher();  
    for(int i = 0; i &lt; 10; i++) {  
        publisher.sendMessage();  
        System.out.println(&quot;Published &quot; + i + &quot; job messages&quot;);  
    try {  
            Thread.sleep(1000);  
        } catch (InterruptedException x) {  
            e.printStackTrace();  
        }  
    }  
    publisher.close();  
}  
</code></pre><p>在这里发送10条消息，在每个<code>sendMessage</code>的方法里实际上是针对每个<code>queue</code>发送了10条。</p>
<h3 id="接收者"><a href="#接收者" class="headerlink" title="接收者"></a>接收者</h3><pre><code>public Consumer() throws JMSException {  
    factory = new ActiveMQConnectionFactory(brokerURL);  
    connection = factory.createConnection();  
    connection.start();  
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
}  


public static void main(String[] args) throws JMSException {  
        Consumer consumer = new Consumer();  
        for (String job : consumer.jobs) {  
            Destination destination = consumer.getSession().createQueue(&quot;JOBS.&quot; + job);  
            MessageConsumer messageConsumer = consumer.getSession().createConsumer(destination);  
            messageConsumer.setMessageListener(new Listener(job));  
        }  
    }  

    public Session getSession() {  
        return session;  
    }
</code></pre><h4 id="MessageListener接口实现类"><a href="#MessageListener接口实现类" class="headerlink" title="MessageListener接口实现类"></a><code>MessageListener</code>接口实现类</h4><pre><code>import javax.jms.Message;  
import javax.jms.MessageListener;  
import javax.jms.ObjectMessage;  

public class Listener implements MessageListener {        
    private String job;  

    public Listener(String job) {  
        this.job = job;  
    }  

    public void onMessage(Message message) {  
        try {  
            //do something here  
            System.out.println(job + &quot; id:&quot; + ((ObjectMessage)message).getObject());  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }        
}
</code></pre><h2 id="比较pub-sub和p2p模式"><a href="#比较pub-sub和p2p模式" class="headerlink" title="比较pub-sub和p2p模式"></a>比较pub-sub和p2p模式</h2><p>基本的处理流程都是类似的，除了在pub-sub中要通过<code>createTopic</code>来设置topic，而在p2p中要通过<code>createQueue</code>来创建通信队列。</p>
<h2 id="request-response"><a href="#request-response" class="headerlink" title="request-response"></a>request-response</h2><p>和前面两种方式比较起来，request-response的通信方式很常见，但是不是默认提供的一种模式。在前面的两种模式中都是一方负责发送消息而另外一方负责处理。而实际中的很多应用需要双方都能给对方发送消息。<br>请求-应答方式并不是JMS规范系统默认提供的一种通信方式，而是通过在现有通信方式的基础上稍微运用一点技巧实现的。</p>
<blockquote>
<p>以下这种方式只能说是很差，并不是什么高明的做法</p>
</blockquote>
<p><img src="/img/JMS实际应用中产生的应答方式示意图.jpg" alt="JMS实际应用中产生的应答方式示意图"><br>在JMS里面，如果要实现请求/应答的方式，可以利用<code>JMSReplyTo</code>和<code>JMSCorrelationID</code>消息头来将通信的双方关联起来。另外，<code>QueueRequestor</code>和<code>TopicRequestor</code>能够支持简单的请求/应答过程。</p>
<pre><code>// client side  
Destination tempDest = session.createTemporaryQueue();  
MessageConsumer responseConsumer = session.createConsumer(tempDest);  
...  

// send a request..  
message.setJMSReplyTo(tempDest)  
message.setJMSCorrelationID(myCorrelationID);  

producer.send(message);  
</code></pre><p>client端创建一个临时队列并在发送的消息里指定了发送返回消息的<code>destination</code>以及<code>correlationID</code>。那么在处理消息的server端得到这个消息后就知道该发送给谁了。Server端的大致流程如下：</p>
<pre><code>public void onMessage(Message request) {  

  Message response = session.createMessage();  
  response.setJMSCorrelationID(request.getJMSCorrelationID())  

  producer.send(request.getJMSReplyTo(), response)  
}  
</code></pre><p>这里是在server端注册<code>MessageListener</code>，通过设置返回信息的<code>CorrelationID</code>和<code>JMSReplyTo</code>将信息返回。</p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client:"></a>Client:</h3><pre><code>public Client() {  
    ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://localhost:61616&quot;);  
    Connection connection;  
    try {  
        connection = connectionFactory.createConnection();  
        connection.start();  
        Session session = connection.createSession(transacted, ackMode);  
        Destination adminQueue = session.createQueue(clientQueueName);  

        //Setup a message producer to send message to the queue the server is consuming from  
        this.producer = session.createProducer(adminQueue);  
        this.producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);  

        //Create a temporary queue that this client will listen for responses on then create a consumer  
        //that consumes message from this temporary queue...for a real application a client should reuse  
        //the same temp queue for each message to the server...one temp queue per client  
        Destination tempDest = session.createTemporaryQueue();  
        MessageConsumer responseConsumer = session.createConsumer(tempDest);  

        //This class will handle the messages to the temp queue as well  
        responseConsumer.setMessageListener(this);  

        //Now create the actual message you want to send  
        TextMessage txtMessage = session.createTextMessage();  
        txtMessage.setText(&quot;MyProtocolMessage&quot;);  

        //Set the reply to field to the temp queue you created above, this is the queue the server  
        //will respond to  
        txtMessage.setJMSReplyTo(tempDest);  

        //Set a correlation ID so when you get a response you know which sent message the response is for  
        //If there is never more than one outstanding message to the server then the  
        //same correlation ID can be used for all the messages...if there is more than one outstanding  
        //message to the server you would presumably want to associate the correlation ID with this  
        //message somehow...a Map works good  
        String correlationId = this.createRandomString();  
        txtMessage.setJMSCorrelationID(correlationId);  
        this.producer.send(txtMessage);  
    } catch (JMSException e) {  
        //Handle the exception appropriately  
    }  
}  
</code></pre><p>这里的代码除了初始化构造函数里的参数还同时设置了两个destination，一个是自己要发送消息出去的destination，在<code>session.createProducer(adminQueue);</code>这一句设置。另外一个是自己要接收的消息destination, 通过<code>Destination tempDest = session.createTemporaryQueue(); responseConsumer = session.createConsumer(tempDest);</code> 这两句指定了要接收消息的目的地。这里是用的一个临时队列。在前面指定了返回消息的通信队列之后，需要通知server端知道发送返回消息给哪个队列。于是<code>txtMessage.setJMSReplyTo(tempDest);</code>指定了这一部分，同时<code>txtMessage.setJMSCorrelationID(correlationId);</code>方法主要是为了保证每次发送回来请求的server端能够知道对应的是哪个请求。这里一个请求和一个应答是相当于对应一个相同的序列号一样。</p>
<p>同时，因为client端在发送消息之后还要接收server端返回的消息，所以它也要实现一个消息receiver的功能。这里采用实现<code>MessageListener</code>接口的方式：</p>
<pre><code>public void onMessage(Message message) {  
    String messageText = null;  
    try {  
        if (message instanceof TextMessage) {  
            TextMessage textMessage = (TextMessage) message;  
            messageText = textMessage.getText();  
            System.out.println(&quot;messageText = &quot; + messageText);  
        }  
    } catch (JMSException e) {  
        //Handle the exception appropriately  
    }  
}  
</code></pre><h3 id="Server"><a href="#Server" class="headerlink" title="Server:"></a>Server:</h3><p>这里server端要执行的过程和client端相反，它是先接收消息，在接收到消息后根据提供的<code>JMSCorelationID</code>来发送返回的消息：</p>
<pre><code>public void onMessage(Message message) {  
    try {  
        TextMessage response = this.session.createTextMessage();  
        if (message instanceof TextMessage) {  
            TextMessage txtMsg = (TextMessage) message;  
            String messageText = txtMsg.getText();  
            response.setText(this.messageProtocol.handleProtocolMessage(messageText));  
        }  

        //Set the correlation ID from the received message to be the correlation id of the response message  
        //this lets the client identify which message this is a response to if it has more than  
        //one outstanding message to the server  
        response.setJMSCorrelationID(message.getJMSCorrelationID());  

        //Send the response to the Destination specified by the JMSReplyTo field of the received message,  
        //this is presumably a temporary queue created by the client  
        this.replyProducer.send(message.getJMSReplyTo(), response);  
    } catch (JMSException e) {  
        //Handle the exception appropriately  
    }  
}
</code></pre><p>前面，在<code>replyProducer.send()</code>方法里，<code>message.getJMSReplyTo()</code>就得到了要发送消息回去的destination。<br>另外，设置这些发送返回信息的replyProducer的信息主要在构造函数相关的方法里实现了：</p>
<pre><code>public Server() {  
    try {  
        //This message broker is embedded  
        BrokerService broker = new BrokerService();  
        broker.setPersistent(false);  
        broker.setUseJmx(false);  
        broker.addConnector(messageBrokerUrl);  
        broker.start();  
    } catch (Exception e) {  
        //Handle the exception appropriately  
    }  

    //Delegating the handling of messages to another class, instantiate it before setting up JMS so it  
    //is ready to handle messages  
    this.messageProtocol = new MessageProtocol();  
    this.setupMessageQueueConsumer();  
}  

private void setupMessageQueueConsumer() {  
    ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(messageBrokerUrl);  
    Connection connection;  
    try {  
        connection = connectionFactory.createConnection();  
        connection.start();  
        this.session = connection.createSession(this.transacted, ackMode);  
        Destination adminQueue = this.session.createQueue(messageQueueName);  

        //Setup a message producer to respond to messages from clients, we will get the destination  
        //to send to from the JMSReplyTo header field from a Message  
        this.replyProducer = this.session.createProducer(null);  
        this.replyProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);  

        //Set up a consumer to consume messages off of the admin queue  
        MessageConsumer consumer = this.session.createConsumer(adminQueue);  
        consumer.setMessageListener(this);  
    } catch (JMSException e) {  
        //Handle the exception appropriately  
    }  
}
</code></pre><p>对于请求/应答的方式来说，这种典型交互的过程就是Client端在设定正常发送请求的Queue同时也设定一个临时的Queue。同时在要发送的message里头指定要返回消息的destination以及CorelationID，这些就好比是一封信里面所带的回执。根据这个信息人家才知道怎么给你回信。对于Server端来说则要额外创建一个producer，在处理接收到消息的方法里再利用producer将消息发回去。这一系列的过程看起来很像http协议里面请求-应答的方式，都是一问一答。</p>
<h2 id="一些应用和改进"><a href="#一些应用和改进" class="headerlink" title="一些应用和改进"></a>一些应用和改进</h2><p>回顾前面三种基本的通信方式，发现它们都存在着一定的共同点，比如说都要初始化<code>ConnectionFactory</code>, <code>Connection</code>, <code>Session</code>等。在使用完之后都要将这些资源关闭。如果每一个实现它的通信端都这么写一通的话，其实是一种简单的重复。从工程的角度来看是完全没有必要的。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>通过工厂方法封装这些对象的创建和销毁，然后简单的通过调用工厂方法的方式得到它们。<br>既然基本的流程都是在开头创建资源在结尾销毁，也可以采用Template Method模式的思路。通过继承一个抽象类，在抽象类里提供了资源的封装。所有继承的类只要实现怎么去使用这些资源的方法就可以了。</p>
]]></content>
    
    <summary type="html">
    
      activemq的几种基本通信方式总结
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS，ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS%EF%BC%8CActiveMQ/"/>
    
    
      <category term="activeMQ" scheme="http://jishusuishouji.github.io/tags/activeMQ/"/>
    
  </entry>
  
  <entry>
    <title>基于ZooKeeper和Thrift构建动态RPC调用</title>
    <link href="http://jishusuishouji.github.io/2017/04/03/thrift/%E5%9F%BA%E4%BA%8EZooKeeper%E5%92%8CThrift%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81RPC%E8%B0%83%E7%94%A8/"/>
    <id>http://jishusuishouji.github.io/2017/04/03/thrift/基于ZooKeeper和Thrift构建动态RPC调用/</id>
    <published>2017-04-03T10:49:07.000Z</published>
    <updated>2017-04-03T14:57:53.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本功能"><a href="#一、基本功能" class="headerlink" title="一、基本功能"></a>一、基本功能</h2><p>实现服务端向ZooKeeper集群注册自己提供的服务，并且把自己的IP地址和服务端口创建到具体的服务目录下。客户端向ZooKeeper集群监听自己关注的RPC服务（例如：<code>sayHello</code>和天气服务）， 监听服务目录下的IP地址列表变化。若要在自己的项目中使用，可以采用阿里的Dubbo分布式服务框架。<br>在WEB端展示可以访问的RPC服务，WEB端可以通过RPC客户端向指定IP地址的RPC服务器发出调用RPC服务，RPC服务端向客户端反馈提供的服务内容，WEB客户端展示内容。<br>只是展示动态RPC基本原理，真正的调用一般都不是web端触发的，应该是RPC的客户端根据监听到的多个IP服务提供者，根据每个IP的负载情况，动态选择最优可用的RPC服务端并且调用服务。 </p>
<p>我们提供2个基本RPC服务，网络及应用部署如图:<br><img src="/img/基本RPC服务网络及应用部署" alt="基本RPC服务网络及应用部署"></p>
<h2 id="二、ZooKeeper介绍"><a href="#二、ZooKeeper介绍" class="headerlink" title="二、ZooKeeper介绍"></a>二、ZooKeeper介绍</h2><p>ZooKeeper是一个开放源代码的分布式应用程序协调服务，由知名互联网公司雅虎创建，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。<br>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。它是一个为分布式应用提供一致性服务的软件，以下是ZooKeeper典型的应用场景</p>
<ul>
<li>数据发布和订阅：就是发布者将数据发布到ZooKeeper的一个或一系列节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中管理和数据的动态更新。</li>
<li>负载均衡：用来对多个计算机、网络连接、CPU、磁盘驱动或其他资源进分配负载，已达到优化资源使用、最大化吞吐率、最下化响应和避免过载。</li>
<li>命名服务：命名服务是分布式系统最基本的公共服务之一。在分布式系统中，被命名的实体通常可以就是集群中的机器、提供的服务地址或远程对象等–这些我们都可以统称它们的名称（Name），其中较常见的就是一些分布式服务框架（如RPC、RMI）中的服务地址列表，通过使用命名服务，客户端应用能够指定名字来获取资源的实体、服务地址和提供者的信息。</li>
<li>集群管理：随着分布式系统规模的日益扩大，集群中的机器规模也随之变大、因此集群监控与集群控制就变得很重要。</li>
<li>分布式锁：分布式锁就是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。</li>
<li>分布式队列：利用Zookeeper的功能我们也可以实现类似于ActiveMQ、Kafka和HornetQ等的消息中间件。</li>
</ul>
<h2 id="三、构建ZooKeeper集群机及RPC服务机"><a href="#三、构建ZooKeeper集群机及RPC服务机" class="headerlink" title="三、构建ZooKeeper集群机及RPC服务机"></a>三、构建ZooKeeper集群机及RPC服务机</h2><p>在Ubuntu桌面系统下完成，利用Oracle下的虚拟机软件VirtualBox。虚拟出了５个Ubuntu 操作系统，３个ZooKeeper机，分别是ZooKeeper-1,ZooKeeper-2,ZooKeeper-3个构建出一个ZooKeeper集群。２个RPC服务机，把在宿主机编写好的程序，通过打包的方式，发布到RPC服务机的jetty下，提供RPC服务 。</p>
<h2 id="四、配置ZooKeeper"><a href="#四、配置ZooKeeper" class="headerlink" title="四、配置ZooKeeper"></a>四、配置ZooKeeper</h2><p>从官方网站下载后，解压到了虚拟机的<code>/work/</code>目录下，将<code>/work/zookeeper-3.4.8/conf/</code>目录下的<code>zoo_sample.cfg</code>重新复制一份命名为<code>zoo.cfg</code>,打开<code>zoo.cfg</code>文件。　<br>修改配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tickTime=2000    </div><div class="line">ddataDir=/work/data/zookeeper   </div><div class="line">clientPort=2181 </div><div class="line">　   Server.1=192.168.0.3:2888:3888</div><div class="line">Server.2=192.168.0.4:2888:3888</div><div class="line">Server.3=192.168.0.5:2888:3888</div></pre></td></tr></table></figure></p>
<p>参数说明:<br><code>tickTime</code>: zookeeper中使用的基本时间单位, 毫秒值.<br><code>dataDir</code>: 数据和日志的目录. 可以是任意目录.此处我们配置到了<code>/work/data/zookeeper</code>目录下<br><code>clientPort</code>: 监听client连接的端口号.<br><code>Server.X=HOST/IP:port:port</code>　<br>     <code>Server.X</code> ：X是我们配置zookeeper集群服务每台机子的编号，需要在每台机子的<code>/work/data/zookeeper/</code>下创建<code>myid</code>文件，内容就是机子的编号。</p>
<h2 id="五、启动、关闭"><a href="#五、启动、关闭" class="headerlink" title="五、启动、关闭"></a>五、启动、关闭</h2><p>切换到<code>/work/zookeeper-3.4.8/bin</code>目录下 </p>
<h3 id="1-启动"><a href="#1-启动" class="headerlink" title="1. 启动"></a>1. 启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./zkServer.sh start</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /work/zookeeper-3.4.8/bin/../conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div></pre></td></tr></table></figure>
<h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./zkCli.sh</div><div class="line">[zk: localhost:2181(CONNECTED) 0]</div></pre></td></tr></table></figure>
<p>进入ZooKeeper 客户端终端命令就说明ZooKeeper启动成功了。 </p>
<h3 id="3-关闭"><a href="#3-关闭" class="headerlink" title="3. 关闭"></a>3. 关闭</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">./zkServer.sh stop</div><div class="line"></div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /work/tool/zookeeper-3.4.8/bin/../conf/zoo.cfg</div><div class="line">Stopping zookeeper ... STOPPED</div></pre></td></tr></table></figure>
<h2 id="六、利用Thrift提供RPC服务"><a href="#六、利用Thrift提供RPC服务" class="headerlink" title="六、利用Thrift提供RPC服务"></a>六、利用Thrift提供RPC服务</h2><h3 id="定义Weather-thrift文件"><a href="#定义Weather-thrift文件" class="headerlink" title="定义Weather.thrift文件"></a>定义<code>Weather.thrift</code>文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">namespace java com.rpc.weather</div><div class="line">　　　　 　　service weather&#123; </div><div class="line">    　　string getWeather(1:string city) </div><div class="line"> 　　&#125;</div></pre></td></tr></table></figure>
<h3 id="生成JAVA文件接口"><a href="#生成JAVA文件接口" class="headerlink" title="生成JAVA文件接口"></a>生成JAVA文件接口</h3><p>在windows环境下使用Thrift工具编译<code>.thrift</code>文件，就会生成相应的<code>.java</code> 文件。该文件包含了在<code>.thrift</code>文件中描述的服务类的接口定义，即<code>.Iface</code>接口，以及服务调用的底层通信细节。命令如下:　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thrift.exe -r -gen java 　weather.thrift</div></pre></td></tr></table></figure></p>
<p>该命令会自动生产相应的JAVA文件</p>
<p><code>gen-java</code>目录就是生成好代码的地方</p>
<h3 id="实现RPC接口功能"><a href="#实现RPC接口功能" class="headerlink" title="实现RPC接口功能"></a>实现RPC接口功能</h3><p>weather的接口实现比较复杂，在这里我们用简单些Hello来说明，道理是一样的。Hello接口的实现： hello只是一个简单的反馈功能，它把客户端传递过来的参数经过简单的组合一起反馈给ＲＰＣ的客户端，本例只是简单展示了一下ＲＰＣ服务处理能力，实现上面已经生产好的Hello.Iface 接口。代码如下：<br>public class HelloServiceImpl implements com.rpc.sayhello.Hello.Iface {<br>    public String helloString(String para) throws TException {<br>        System.out.println(“helloString be calling”);<br>        return “你好:” + para + “,欢迎来到”+GetIP.IP()+”服务器!”;<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>1<br>2<br>3<br>4<br>5<br>6</p>
<h2 id="七、RPC服务注册"><a href="#七、RPC服务注册" class="headerlink" title="七、RPC服务注册"></a>七、RPC服务注册</h2><p>我们在ZooKeeper注册了2个服务（2个ZNode节点），分别是sayHello及Weather。用2个IP提供RPC的服务。目录结构如图-：<br>这里写图片描述<br>在Zookeeper的每个节点，都可以分为持久节点和临时节点　持久节点是指一旦这个节点被创建了，除非主动进行删除操作，否则这个节点将一直保存在ＺooKeeper中.而临时节点就不一样了，它的生命周期和客户端回话绑定，一旦客户端回话失效，那么这个客户端创建的所有临时节点都会被移除。ZooKeeper主要是利用了“心跳检测”功能，它会定时向各个服务提供者发送一个请求，如果长期没有响应，服务中心就认为该服务提供者已经“挂了”，并将其剔除。注意临时节点下不可以在创建任何节点。</p>
<p>注册天气服务的主要代码：</p>
<p>private void createServerHost()  {<br>        Stat stat = zookeeper.exists(WeatherConstants.RPCNAME + “/“ + GetIP.IP() + “:” + WeatherConstants.WeahterPort,false);//检查节点是否存在<br>        if (stat == null) {<br>　　　　　　// 这里是临时的节点，会因服务器的宕机、网络失效而消失<br>    path = zookeeper.create(WeatherConstants.RPCNAME + “/“ + GetIP.IP() + “:” + 　　WeatherConstants.WeahterPort, “”.getBytes(),Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);//创建节点　<br>        }<br>    }<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<h2 id="八、RPC客戶端服务监听"><a href="#八、RPC客戶端服务监听" class="headerlink" title="八、RPC客戶端服务监听"></a>八、RPC客戶端服务监听</h2><p>Watcher(事件监听器)，是ZooKeeper的一个很重要的特性。ZooKeeper允许用户在指定的节点上注册一些Watcher，并且在一些特定的事件触发的时候，ZooKeeper服务器会将事件通知到感兴趣的客户端。利用Watcher监听2个服务节点下的IP变化，一旦我们监听的服务下的节点有变化（增加或减少）ZooKeeper就会向我们注册的监听类发送“NodeChildrenChanged”事件，我们就可以在此时更新地址列表变化，从而进行更新。<br>需要注意的是ZooKeeper服务器在向客户端发送Watcher的通知的时候，仅仅只会发出一个通知，而不会把节点的变化情况发送给客户端，客户端需要自己重新获取。另外，由于Watcher通知是一次性的，一旦触发一次通知后，该Watcher就失效了，因此客户端需要反复注册Watcher。</p>
<p>监听服务列表的变化<br>在监听WatchWeather类内我们定义了一个weatherlist的数组列表，用来存储提供天气的所有ＲＰＣ服务的地址和端口。<br>通过zookeeper.getChildren获取在zookeeper注册的所有提供天气的ＩＰ地址。并且注册了在这个节点下的监听类。</p>
<p>　　　　weatherlist = zookeeper.getChildren(WeatherConstants.RPCNAME, this);<br>　　　 //在监听的WatchWeather实现Watcher接口的process方法：<br>　　　　public void process(WatchedEvent event) {<br>        if (EventType.NodeChildrenChanged == event.getType()) { 　<br>        　　weatherlist = zookeeper.getChildren(WeatherConstants.RPCNAME, this);<br>　　　　　}  　<br>    }<br>　　<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>只要我们监听的节点下有变动就会接受到NodeChildrenChanged 事件，在这里我们再次获取了节点下的最新ＩＰ地址列表，并且重新注册了监听类。</p>
<h2 id="九、调用RPC服务"><a href="#九、调用RPC服务" class="headerlink" title="九、调用RPC服务"></a>九、调用RPC服务</h2><p>public class CallWeatherRPC {<br>    public String callWeather(String ip, int port, String city) {<br>        String retString = null;<br>        TTransport transport = new TSocket(ip, port);<br>        transport.open();<br>        TProtocol protocol = new TBinaryProtocol(transport);<br>        weather.Client client = new weather.Client(protocol);//weather为定义接口实现的文件<br>        retString = client.getWeather(city);//调用ＲＰＣ服务<br>        transport.close();<br>        return retString;<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>此处是使用了Thrift的客户端调用RPC服务端的相应程序，主要特点是IP地址不固定，可以有多地址可以调用。</p>
]]></content>
    
    <summary type="html">
    
      基于ZooKeeper和Thrift构建动态RPC调用
    
    </summary>
    
      <category term="分布式" scheme="http://jishusuishouji.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="RPC" scheme="http://jishusuishouji.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RPC/"/>
    
      <category term="Thrift" scheme="http://jishusuishouji.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RPC/Thrift/"/>
    
    
      <category term="Thrift" scheme="http://jishusuishouji.github.io/tags/Thrift/"/>
    
      <category term="RPC" scheme="http://jishusuishouji.github.io/tags/RPC/"/>
    
      <category term="ZoopKeeper" scheme="http://jishusuishouji.github.io/tags/ZoopKeeper/"/>
    
  </entry>
  
  <entry>
    <title>Apache Thrift学习之一（入门及Java实例演示）</title>
    <link href="http://jishusuishouji.github.io/2017/04/03/thrift/Apache_Thrift%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80%EF%BC%88%E5%85%A5%E9%97%A8%E5%8F%8AJava%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA%EF%BC%89/"/>
    <id>http://jishusuishouji.github.io/2017/04/03/thrift/Apache_Thrift学习之一（入门及Java实例演示）/</id>
    <published>2017-04-03T09:58:39.000Z</published>
    <updated>2017-04-04T14:33:34.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Apache Thrift是Facebook实现的一种高效的、支持多种编程语言的远程服务调用的框架。Thrift是由Facebook开发的，并在2008年捐给了Apache基金会，成为了一个孵化器项目。</p>
<p>Thrift是一个软件框架，用来进行可扩展且跨语言的服务开发。它结合了功能强大的软件堆栈和代码生成引擎，</p>
<p>Thrift是一个驱动层接口，它提供了用于客户端使用多种语言实现的API。<br>Thrift是个代码生成库，支持的客户端语言包括C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 。它的目标是为了各种流行的语言提供便利的RPC调用机制，而不需要使用那些开销巨大的方式，比如SOAP。</p>
<p>要使用Thrift，就要使用一个语言中立的服务定义文件，描述数据类型和服务接口。这个文件会被用作引擎的输入，编译器为每种支持的语言生成代码。这种静态生成的设计让它非常容易被开发者所使用，而且因为类型验证都发生在编译期而非运行期，所以代码可以很有效率地运行。</p>
<p>Thrift的设计提供了以下这些特性：<br>1、语言无关的类型<br>因为类型是使用定义文件按照语言中立的方式规定的，所以它们可以被不同的语言分享。比如，C++的结构可以和Python的字典类型相互交换数据。<br>2、通用传输接口<br>不论你使用的是磁盘文件、内存数据还是socket流，都可以使用同一段应用代码。<br>3、协议无关<br>Thrift会对数据类型进行编码和解码，可以跨协议使用。<br>4、支持版本<br>数据类型可以加入版本信息，来支持客户端API的更新。</p>
<h2 id="二、下载配置"><a href="#二、下载配置" class="headerlink" title="二、下载配置"></a>二、下载配置</h2><h3 id="1）安装thrift：到thrift官网下载exe文件，然后将文件重命名为thrift-exe-拷贝到D-EBOOK-thrift目录下-或者任何目录下-，然后就可以在dos环境下使用了"><a href="#1）安装thrift：到thrift官网下载exe文件，然后将文件重命名为thrift-exe-拷贝到D-EBOOK-thrift目录下-或者任何目录下-，然后就可以在dos环境下使用了" class="headerlink" title="1）安装thrift：到thrift官网下载exe文件，然后将文件重命名为thrift.exe,拷贝到D:\EBOOK\thrift目录下(或者任何目录下)，然后就可以在dos环境下使用了"></a>1）安装thrift：到thrift官网下载exe文件，然后将文件重命名为<code>thrift.exe</code>,拷贝到<code>D:\EBOOK\thrift</code>目录下(或者任何目录下)，然后就可以在dos环境下使用了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\EBOOK\thrift&gt;thrift -gen java D:\work\workspace\thriftworkspace\demo1\demoHello.thrift</div></pre></td></tr></table></figure>
<p>输出的java文件默认输出到当前目录下<code>D:\EBOOK\thrift\gen-java</code>，也可以使用<code>-o</code>参数指定输出路径;</p>
<h3 id="2）下载相关依赖包"><a href="#2）下载相关依赖包" class="headerlink" title="2）下载相关依赖包"></a>2）下载相关依赖包</h3><h4 id="2-1）libthrift-jar-，下载地址：http-repo1-maven-org-maven2-org-apache-thrift-libthrift-0-9-0"><a href="#2-1）libthrift-jar-，下载地址：http-repo1-maven-org-maven2-org-apache-thrift-libthrift-0-9-0" class="headerlink" title="2.1）libthrift.jar ，下载地址：http://repo1.maven.org/maven2/org/apache/thrift/libthrift/0.9.0/"></a>2.1）<code>libthrift.jar</code> ，下载地址：<a href="http://repo1.maven.org/maven2/org/apache/thrift/libthrift/0.9.0/" target="_blank" rel="external">http://repo1.maven.org/maven2/org/apache/thrift/libthrift/0.9.0/</a></h4><h4 id="2-2）slf4j-api-jar"><a href="#2-2）slf4j-api-jar" class="headerlink" title="2.2）slf4j-api.jar"></a>2.2）<code>slf4j-api.jar</code></h4><h4 id="2-3）slf4j-simple-jar"><a href="#2-3）slf4j-simple-jar" class="headerlink" title="2.3）slf4j-simple.jar"></a>2.3）<code>slf4j-simple.jar</code></h4><p>到官网<a href="http://thrift.apache.org/download" target="_blank" rel="external">http://thrift.apache.org/download</a> 下载最新版本，截止今日（2016-05-23）最新版本为0.9.3</p>
<h3 id="3-Maven项目设置依赖包"><a href="#3-Maven项目设置依赖包" class="headerlink" title="3) Maven项目设置依赖包"></a>3) Maven项目设置依赖包</h3><p>如果是Maven构建项目的，直接在<code>pom.xml</code>中添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">  &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;libthrift&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;0.8.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<h3 id="4-手动编译"><a href="#4-手动编译" class="headerlink" title="4).手动编译"></a>4).手动编译</h3><p>如果自己编译lib包，把下载的压缩包解压到<code>X</code>盘，然后在<code>X:\thrift-0.8.0\lib\java</code> 目录下运行<code>ant</code>进行自动编译，会在<code>X:\thrift-0.8.0\lib\java\build\</code> 目录下看到编译好的lib包：<code>libthrift-0.8.0.jar</code></p>
<h2 id="三、基本概念"><a href="#三、基本概念" class="headerlink" title="三、基本概念"></a>三、基本概念</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><h4 id="基本类型："><a href="#基本类型：" class="headerlink" title="基本类型："></a>基本类型：</h4><p><code>bool</code>：布尔值，<code>true</code>或<code>false</code>，对应Java的<code>boolean</code><br><code>byte</code>：8位有符号整数，对应Java的<code>byte</code><br><code>i16</code>：16位有符号整数，对应Java的<code>short</code><br><code>i32</code>：32位有符号整数，对应Java的<code>int</code><br><code>i64</code>：64位有符号整数，对应Java的<code>long</code><br><code>double</code>：64 位浮点数，对应Java的<code>double</code><br><code>string</code>：utf-8编码的字符串，对应Java的<code>String</code></p>
<h4 id="结构体类型："><a href="#结构体类型：" class="headerlink" title="结构体类型："></a>结构体类型：</h4><p><code>struct</code>：定义公共的对象，类似于C语言中的结构体定义，在Java中是一个JavaBean</p>
<h4 id="容器类型："><a href="#容器类型：" class="headerlink" title="容器类型："></a>容器类型：</h4><p><code>list</code>：对应Java的<code>ArrayList</code><br><code>set</code>：对应Java的<code>HashSet</code><br><code>map</code>：对应Java的<code>HashMap</code></p>
<h4 id="异常类型："><a href="#异常类型：" class="headerlink" title="异常类型："></a>异常类型：</h4><p><code>exception</code>：对应Java的<code>Exception</code></p>
<h4 id="服务类型："><a href="#服务类型：" class="headerlink" title="服务类型："></a>服务类型：</h4><p><code>service</code>：对应服务的类</p>
<h3 id="2-服务端编码基本步骤："><a href="#2-服务端编码基本步骤：" class="headerlink" title="2.服务端编码基本步骤："></a>2.服务端编码基本步骤：</h3><ul>
<li>实现服务处理接口impl</li>
<li>创建<code>TProcessor</code>(业务处理器)</li>
<li>创建<code>TServerTransport</code>()</li>
<li>创建<code>TProtocol</code>(传输协议)</li>
<li>创建<code>TServer</code></li>
<li>启动<code>Server</code></li>
</ul>
<h3 id="3-客户端编码基本步骤："><a href="#3-客户端编码基本步骤：" class="headerlink" title="3.客户端编码基本步骤："></a>3.客户端编码基本步骤：</h3><ul>
<li>创建<code>Transport</code></li>
<li>创建<code>TProtocol</code></li>
<li>基于<code>TTransport</code>和<code>TProtocol</code>创建<code>Client</code></li>
<li>调用<code>Client</code>的相应方法</li>
</ul>
<h3 id="4-数据传输协议"><a href="#4-数据传输协议" class="headerlink" title="4.数据传输协议"></a>4.数据传输协议</h3><p><code>TBinaryProtocol</code>: 二进制格式.<br><code>TCompactProtocol</code>: 压缩格式<br><code>TJSONProtocol</code>: JSON格式<br><code>TSimpleJSONProtocol</code>: 提供JSON只写协议, 生成的文件很容易通过脚本语言解析</p>
<blockquote>
<p>客户端和服务端的协议要一致</p>
</blockquote>
<p>##四、实例演示</p>
<h3 id="1-thrift生成代码"><a href="#1-thrift生成代码" class="headerlink" title="1. thrift生成代码"></a>1. thrift生成代码</h3><p>创建Thrift文件：<code>D:\work\workspace\thriftworkspace\demo1\demoHello.thrift</code> ,内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">namespace java com.dxz.thrift.demo</div><div class="line"> </div><div class="line">service  HelloWorldService &#123;</div><div class="line">  string sayHello(1:string username)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>thrift-0.8.0.exe是官网提供的windows下编译工具，运用这个工具生成相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\EBOOK\thrift&gt;thrift-0.9.3.exe -r -gen java D:\work\workspace\thriftworkspace\demo1\demoHello.thrift</div></pre></td></tr></table></figure></p>
<p>将生成的<code>HelloWorldService.java</code>文件copy到自己测试的工程中，我的工程是用maven构建的，故在<code>pom.xml</code>中增加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;libthrift&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;0.8.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.5.8&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>如果是ant构建的工程，将<code>libthrift-0.9.3.jar</code>加入到工程中</p>
<h3 id="2-实现接口Iface"><a href="#2-实现接口Iface" class="headerlink" title="2. 实现接口Iface"></a>2. 实现接口Iface</h3><p>java代码：<code>HelloWorldImpl.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line">import org.apache.thrift.TException;</div><div class="line">public class HelloWorldImpl implements HelloWorldService.Iface &#123;</div><div class="line">    public HelloWorldImpl() &#123;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public String sayHello(String username) throws TException &#123;</div><div class="line">        return &quot;Hi,&quot; + username + &quot; welcome to thrift world&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-TSimpleServer服务端"><a href="#3-TSimpleServer服务端" class="headerlink" title="3.TSimpleServer服务端"></a>3.<code>TSimpleServer</code>服务端</h3><h4 id="简单的单线程服务模型，一般用于测试。"><a href="#简单的单线程服务模型，一般用于测试。" class="headerlink" title="简单的单线程服务模型，一般用于测试。"></a>简单的单线程服务模型，一般用于测试。</h4><p>编写服务端server代码：<code>HelloServerDemo.java</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TProcessor;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.protocol.TJSONProtocol;</div><div class="line">import org.apache.thrift.protocol.TSimpleJSONProtocol;</div><div class="line">import org.apache.thrift.server.TServer;</div><div class="line">import org.apache.thrift.server.TSimpleServer;</div><div class="line">import org.apache.thrift.transport.TServerSocket;</div><div class="line"></div><div class="line">public class HelloServerDemo &#123;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line"></div><div class="line">    public void startServer() &#123;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;HelloWorld TSimpleServer start ....&quot;);</div><div class="line"></div><div class="line">            TProcessor tprocessor = new HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(new HelloWorldImpl());</div><div class="line">            //HelloWorldService.Processor&lt;HelloWorldService.Iface&gt; tprocessor =</div><div class="line">            new HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(new HelloWorldImpl());</div><div class="line"></div><div class="line">            // 简单的单线程服务模型，一般用于测试</div><div class="line">            TServerSocket serverTransport = new TServerSocket(SERVER_PORT);</div><div class="line">            TServer.Args tArgs = new TServer.Args(serverTransport);</div><div class="line">            tArgs.processor(tprocessor);</div><div class="line">            tArgs.protocolFactory(new TBinaryProtocol.Factory());</div><div class="line">            // tArgs.protocolFactory(new TCompactProtocol.Factory());</div><div class="line">            // tArgs.protocolFactory(new TJSONProtocol.Factory());</div><div class="line">            TServer server = new TSimpleServer(tArgs);</div><div class="line">            server.serve();</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            System.out.println(&quot;Server start error!!!&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloServerDemo server = new HelloServerDemo();</div><div class="line">        server.startServer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="编写客户端Client代码：HelloClientDemo-java"><a href="#编写客户端Client代码：HelloClientDemo-java" class="headerlink" title="编写客户端Client代码：HelloClientDemo.java"></a>编写客户端Client代码：<code>HelloClientDemo.java</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TException;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.protocol.TJSONProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocol;</div><div class="line">import org.apache.thrift.transport.TSocket;</div><div class="line">import org.apache.thrift.transport.TTransport;</div><div class="line">import org.apache.thrift.transport.TTransportException;</div><div class="line"></div><div class="line">public class HelloClientDemo &#123;</div><div class="line"></div><div class="line">    public static final String SERVER_IP = &quot;localhost&quot;;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line">    public static final int TIMEOUT = 30000;</div><div class="line"></div><div class="line">    public void startClient(String userName) &#123;</div><div class="line">        TTransport transport = null;</div><div class="line">        try &#123;</div><div class="line">            transport = new TSocket(SERVER_IP, SERVER_PORT, TIMEOUT);</div><div class="line">            // 协议要和服务端一致</div><div class="line">            TProtocol protocol = new TBinaryProtocol(transport);</div><div class="line">            // TProtocol protocol = new TCompactProtocol(transport);</div><div class="line">            // TProtocol protocol = new TJSONProtocol(transport);</div><div class="line">            HelloWorldService.Client client = new HelloWorldService.Client(protocol);</div><div class="line">            transport.open();</div><div class="line">            String result = client.sayHello(userName);</div><div class="line">            System.out.println(&quot;Thrify client result =: &quot; + result);</div><div class="line">        &#125; catch (TTransportException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (TException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (null != transport) &#123;</div><div class="line">                transport.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloClientDemo client = new HelloClientDemo();</div><div class="line">        client.startClient(&quot;china&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先运行服务端程序，日志如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HelloWorld TSimpleServer start ....</div></pre></td></tr></table></figure></p>
<p>再运行客户端调用程序，日志如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thrify client result =: Hi,china welcome to thrift world.</div></pre></td></tr></table></figure></p>
<p>测试成功，和预期的返回信息一致。</p>
<h3 id="4-TThreadPoolServer-服务模型"><a href="#4-TThreadPoolServer-服务模型" class="headerlink" title="4.TThreadPoolServer 服务模型"></a>4.TThreadPoolServer 服务模型</h3><p>线程池服务模型，使用标准的阻塞式IO，预先创建一组线程处理请求。</p>
<h4 id="编写服务端代码：HelloServerDemo2-java"><a href="#编写服务端代码：HelloServerDemo2-java" class="headerlink" title="编写服务端代码：HelloServerDemo2.java"></a>编写服务端代码：<code>HelloServerDemo2.java</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TProcessor;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.server.TServer;</div><div class="line">import org.apache.thrift.server.TThreadPoolServer;</div><div class="line">import org.apache.thrift.transport.TServerSocket;</div><div class="line"></div><div class="line">public class HelloServerDemo2 &#123;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line"></div><div class="line">    public void startServer() &#123;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;HelloWorld TThreadPoolServer start ....&quot;);</div><div class="line"></div><div class="line">            TProcessor tprocessor = new HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(new HelloWorldImpl());</div><div class="line"></div><div class="line">            TServerSocket serverTransport = new TServerSocket(SERVER_PORT);</div><div class="line">            TThreadPoolServer.Args ttpsArgs = new TThreadPoolServer.Args(serverTransport);</div><div class="line">            ttpsArgs.processor(tprocessor);</div><div class="line">            ttpsArgs.protocolFactory(new TBinaryProtocol.Factory());</div><div class="line"></div><div class="line">            // 线程池服务模型，使用标准的阻塞式IO，预先创建一组线程处理请求。</div><div class="line">            TServer server = new TThreadPoolServer(ttpsArgs);</div><div class="line">            server.serve();</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            System.out.println(&quot;Server start error!!!&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloServerDemo2 server = new HelloServerDemo2();</div><div class="line">        server.startServer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端Client代码和之前的一样，只要数据传输的协议一致即可，客户端测试成功，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thrify client result =: Hi,china welcome to thrift world.</div></pre></td></tr></table></figure></p>
<h3 id="5-TNonblockingServer-服务模型"><a href="#5-TNonblockingServer-服务模型" class="headerlink" title="5.TNonblockingServer 服务模型"></a>5.TNonblockingServer 服务模型</h3><p>使用非阻塞式IO，服务端和客户端需要指定<code>TFramedTransport</code>数据传输的方式。</p>
<h4 id="编写服务端代码：HelloServerDemo3-java"><a href="#编写服务端代码：HelloServerDemo3-java" class="headerlink" title="编写服务端代码：HelloServerDemo3.java"></a>编写服务端代码：<code>HelloServerDemo3.java</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TProcessor;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.server.TNonblockingServer;</div><div class="line">import org.apache.thrift.server.TServer;</div><div class="line">import org.apache.thrift.server.TThreadPoolServer;</div><div class="line">import org.apache.thrift.transport.TFramedTransport;</div><div class="line">import org.apache.thrift.transport.TNonblockingServerSocket;</div><div class="line">import org.apache.thrift.transport.TServerSocket;</div><div class="line"></div><div class="line">public class HelloServerDemo3 &#123;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line"></div><div class="line">    public void startServer() &#123;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;HelloWorld TNonblockingServer start ....&quot;);</div><div class="line"></div><div class="line">            TProcessor tprocessor = new HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(new HelloWorldImpl());</div><div class="line"></div><div class="line">            TNonblockingServerSocket tnbSocketTransport = new TNonblockingServerSocket(SERVER_PORT);</div><div class="line">            TNonblockingServer.Args tnbArgs = new TNonblockingServer.Args(tnbSocketTransport);</div><div class="line">            tnbArgs.processor(tprocessor);</div><div class="line">            tnbArgs.transportFactory(new TFramedTransport.Factory());</div><div class="line">            tnbArgs.protocolFactory(new TCompactProtocol.Factory());</div><div class="line"></div><div class="line">            // 使用非阻塞式IO，服务端和客户端需要指定TFramedTransport数据传输的方式</div><div class="line">            TServer server = new TNonblockingServer(tnbArgs);</div><div class="line">            server.serve();</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            System.out.println(&quot;Server start error!!!&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloServerDemo3 server = new HelloServerDemo3();</div><div class="line">        server.startServer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="编写客户端代码：HelloClientDemo3-java"><a href="#编写客户端代码：HelloClientDemo3-java" class="headerlink" title="编写客户端代码：HelloClientDemo3.java"></a>编写客户端代码：<code>HelloClientDemo3.java</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TException;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.protocol.TJSONProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocol;</div><div class="line">import org.apache.thrift.transport.TSocket;</div><div class="line">import org.apache.thrift.transport.TTransport;</div><div class="line">import org.apache.thrift.transport.TTransportException;</div><div class="line">import org.apache.thrift.TException;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocol;</div><div class="line">import org.apache.thrift.transport.TFramedTransport;</div><div class="line">import org.apache.thrift.transport.TSocket;</div><div class="line">import org.apache.thrift.transport.TTransport;</div><div class="line">import org.apache.thrift.transport.TTransportException;</div><div class="line"></div><div class="line">public class HelloClientDemo3 &#123;</div><div class="line"></div><div class="line">    public static final String SERVER_IP = &quot;localhost&quot;;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line">    public static final int TIMEOUT = 30000;</div><div class="line"></div><div class="line">    public void startClient(String userName) &#123;</div><div class="line">        TTransport transport = null;</div><div class="line">        try &#123;</div><div class="line">            transport = new TFramedTransport(new TSocket(SERVER_IP, SERVER_PORT, TIMEOUT));</div><div class="line">            // 协议要和服务端一致</div><div class="line">            TProtocol protocol = new TCompactProtocol(transport);</div><div class="line">            HelloWorldService.Client client = new HelloWorldService.Client(protocol);</div><div class="line">            transport.open();</div><div class="line">            String result = client.sayHello(userName);</div><div class="line">            System.out.println(&quot;Thrify client result =: &quot; + result);</div><div class="line">        &#125; catch (TTransportException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (TException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (null != transport) &#123;</div><div class="line">                transport.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloClientDemo3 client = new HelloClientDemo3();</div><div class="line">        client.startClient(&quot;HelloClientDemo3&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端的测试成功，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thrify client result =: Hi,HelloClientDemo3 welcome to thrift world.</div></pre></td></tr></table></figure></p>
<h3 id="6-THsHaServer服务模型"><a href="#6-THsHaServer服务模型" class="headerlink" title="6.THsHaServer服务模型"></a>6.THsHaServer服务模型</h3><p>半同步半异步的服务端模型，需要指定为：<code>TFramedTransport</code>数据传输的方式。</p>
<h4 id="编写服务端代码：HelloServerDemo4-java"><a href="#编写服务端代码：HelloServerDemo4-java" class="headerlink" title="编写服务端代码：HelloServerDemo4.java"></a>编写服务端代码：<code>HelloServerDemo4.java</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TProcessor;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.server.THsHaServer;</div><div class="line">import org.apache.thrift.server.TNonblockingServer;</div><div class="line">import org.apache.thrift.server.TServer;</div><div class="line">import org.apache.thrift.server.TSimpleServer;</div><div class="line">import org.apache.thrift.server.TThreadPoolServer;</div><div class="line">import org.apache.thrift.transport.TFramedTransport;</div><div class="line">import org.apache.thrift.transport.TNonblockingServerSocket;</div><div class="line">import org.apache.thrift.transport.TServerSocket;</div><div class="line"></div><div class="line">public class HelloServerDemo4 &#123;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line"></div><div class="line">    public void startServer() &#123;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;HelloWorld THsHaServer start ....&quot;);</div><div class="line"></div><div class="line">            TProcessor tprocessor = new HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(new HelloWorldImpl());</div><div class="line"></div><div class="line">            TNonblockingServerSocket tnbSocketTransport = new TNonblockingServerSocket(SERVER_PORT);</div><div class="line">            THsHaServer.Args thhsArgs = new THsHaServer.Args(tnbSocketTransport);</div><div class="line">            thhsArgs.processor(tprocessor);</div><div class="line">            thhsArgs.transportFactory(new TFramedTransport.Factory());</div><div class="line">            thhsArgs.protocolFactory(new TBinaryProtocol.Factory());</div><div class="line"></div><div class="line">            // 半同步半异步的服务模型</div><div class="line">            TServer server = new THsHaServer(thhsArgs);</div><div class="line">            server.serve();</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            System.out.println(&quot;Server start error!!!&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloServerDemo4 server = new HelloServerDemo4();</div><div class="line">        server.startServer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="客户端代码HelloClientDemo4-java"><a href="#客户端代码HelloClientDemo4-java" class="headerlink" title="客户端代码HelloClientDemo4.java"></a>客户端代码<code>HelloClientDemo4.java</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import org.apache.thrift.TException;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocol;</div><div class="line">import org.apache.thrift.transport.TSocket;</div><div class="line">import org.apache.thrift.transport.TTransport;</div><div class="line">import org.apache.thrift.transport.TTransportException;</div><div class="line"></div><div class="line">public class HelloClientDemo4 &#123;</div><div class="line"></div><div class="line">    public static final String SERVER_IP = &quot;localhost&quot;;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line">    public static final int TIMEOUT = 30000;</div><div class="line"></div><div class="line">    public void startClient(String userName) &#123;</div><div class="line">        TTransport transport = null;</div><div class="line">        try &#123;</div><div class="line">            transport = new TFramedTransport(new TSocket(SERVER_IP, SERVER_PORT, TIMEOUT));</div><div class="line">            // 协议要和服务端一致</div><div class="line">            TProtocol protocol = new TBinaryProtocol(transport);</div><div class="line">            // TProtocol protocol = new TCompactProtocol(transport);</div><div class="line">            // TProtocol protocol = new TJSONProtocol(transport);</div><div class="line">            HelloWorldService.Client client = new HelloWorldService.Client(protocol);</div><div class="line">            transport.open();</div><div class="line">            String result = client.sayHello(userName);</div><div class="line">            System.out.println(&quot;Thrify client result =: &quot; + result);</div><div class="line">        &#125; catch (TTransportException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (TException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (null != transport) &#123;</div><div class="line">                transport.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloClientDemo4 client = new HelloClientDemo4();</div><div class="line">        client.startClient(&quot;HelloClientDemo4&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：Thrify client result =: Hi,HelloClientDemo4 welcome to thrift world.</p>
<h3 id="7-异步客户端"><a href="#7-异步客户端" class="headerlink" title="7.异步客户端"></a>7.异步客户端</h3><p>编写服务端代码：HelloServerDemo5.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TProcessor;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.server.TNonblockingServer;</div><div class="line">import org.apache.thrift.server.TServer;</div><div class="line">import org.apache.thrift.transport.TFramedTransport;</div><div class="line">import org.apache.thrift.transport.TNonblockingServerSocket;</div><div class="line"></div><div class="line">public class HelloServerDemo5 &#123;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line"></div><div class="line">    public void startServer() &#123;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;HelloWorld TNonblockingServer start ....&quot;);</div><div class="line"></div><div class="line">            TProcessor tprocessor = new HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(new HelloWorldImpl());</div><div class="line"></div><div class="line">            TNonblockingServerSocket tnbSocketTransport = new TNonblockingServerSocket(SERVER_PORT);</div><div class="line">            TNonblockingServer.Args tnbArgs = new TNonblockingServer.Args(tnbSocketTransport);</div><div class="line">            tnbArgs.processor(tprocessor);</div><div class="line">            tnbArgs.transportFactory(new TFramedTransport.Factory());</div><div class="line">            tnbArgs.protocolFactory(new TCompactProtocol.Factory());</div><div class="line"></div><div class="line">            // 使用非阻塞式IO，服务端和客户端需要指定TFramedTransport数据传输的方式</div><div class="line">            TServer server = new TNonblockingServer(tnbArgs);</div><div class="line">            server.serve();</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            System.out.println(&quot;Server start error!!!&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloServerDemo5 server = new HelloServerDemo5();</div><div class="line">        server.startServer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编写客户端Client代码：<code>HelloAsynClientDemo.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import java.util.concurrent.CountDownLatch;</div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line">import org.apache.thrift.TException;</div><div class="line">import org.apache.thrift.async.AsyncMethodCallback;</div><div class="line">import org.apache.thrift.async.TAsyncClientManager;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocolFactory;</div><div class="line">import org.apache.thrift.transport.TNonblockingSocket;</div><div class="line">import org.apache.thrift.transport.TNonblockingTransport;</div><div class="line">import com.dxz.thrift.demo.HelloWorldService.AsyncClient.sayHello_call;</div><div class="line"></div><div class="line">public class HelloAsynClientDemo &#123;</div><div class="line"></div><div class="line">    public static final String SERVER_IP = &quot;localhost&quot;;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line">    public static final int TIMEOUT = 30000;</div><div class="line"></div><div class="line">    public void startClient(String userName) &#123;</div><div class="line">        try &#123;</div><div class="line">            TAsyncClientManager clientManager = new TAsyncClientManager();</div><div class="line">            TNonblockingTransport transport = new TNonblockingSocket(SERVER_IP, SERVER_PORT, TIMEOUT);</div><div class="line"></div><div class="line">            TProtocolFactory tprotocol = new TCompactProtocol.Factory();</div><div class="line">            HelloWorldService.AsyncClient asyncClient = new HelloWorldService.AsyncClient(tprotocol, clientManager,</div><div class="line">                    transport);</div><div class="line">            System.out.println(&quot;Client start .....&quot;);</div><div class="line"></div><div class="line">            CountDownLatch latch = new CountDownLatch(1);</div><div class="line">            AsynCallback callBack = new AsynCallback(latch);</div><div class="line">            System.out.println(&quot;call method sayHello start ...&quot;);</div><div class="line">            asyncClient.sayHello(userName, callBack);</div><div class="line">            System.out.println(&quot;call method sayHello .... end&quot;);</div><div class="line">            boolean wait = latch.await(30, TimeUnit.SECONDS);</div><div class="line">            System.out.println(&quot;latch.await =:&quot; + wait);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;startClient end.&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public class AsynCallback implements AsyncMethodCallback&lt;sayHello_call&gt; &#123;</div><div class="line">        private CountDownLatch latch;</div><div class="line"></div><div class="line">        public AsynCallback(CountDownLatch latch) &#123;</div><div class="line">            this.latch = latch;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onComplete(sayHello_call response) &#123;</div><div class="line">            System.out.println(&quot;onComplete&quot;);</div><div class="line">            try &#123;</div><div class="line">                // Thread.sleep(1000L * 1);</div><div class="line">                System.out.println(&quot;AsynCall result =:&quot; + response.getResult().toString());</div><div class="line">            &#125; catch (TException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; finally &#123;</div><div class="line">                latch.countDown();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onError(Exception exception) &#123;</div><div class="line">            System.out.println(&quot;onError :&quot; + exception.getMessage());</div><div class="line">            latch.countDown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloAsynClientDemo client = new HelloAsynClientDemo();</div><div class="line">        client.startClient(&quot;HelloAsynClientDemo&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先运行服务程序，再运行客户端程序，测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Client start .....</div><div class="line">call method sayHello start ...</div><div class="line">call method sayHello .... end</div><div class="line">onComplete</div><div class="line">AsynCall result =:Hi,HelloAsynClientDemo welcome to thrift world.</div><div class="line">latch.await =:true</div><div class="line">startClient end.</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      Apache Thrift学习之一（入门及Java实例演示）
    
    </summary>
    
      <category term="RPC" scheme="http://jishusuishouji.github.io/categories/RPC/"/>
    
      <category term="Thrift" scheme="http://jishusuishouji.github.io/categories/RPC/Thrift/"/>
    
    
      <category term="facebook" scheme="http://jishusuishouji.github.io/tags/facebook/"/>
    
      <category term="Thrift" scheme="http://jishusuishouji.github.io/tags/Thrift/"/>
    
      <category term="RPC" scheme="http://jishusuishouji.github.io/tags/RPC/"/>
    
  </entry>
  
  <entry>
    <title>facebook的thriff 基于rpc的远程调用实现</title>
    <link href="http://jishusuishouji.github.io/2017/04/03/thriff/facebook%E7%9A%84thriff_%E5%9F%BA%E4%BA%8Erpc%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jishusuishouji.github.io/2017/04/03/thriff/facebook的thriff_基于rpc的远程调用实现/</id>
    <published>2017-04-03T09:05:33.000Z</published>
    <updated>2017-04-03T09:28:52.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RPC、RMI、JMS概念："><a href="#RPC、RMI、JMS概念：" class="headerlink" title="RPC、RMI、JMS概念："></a>RPC、RMI、JMS概念：</h2><h3 id="RPC与RMI的对比"><a href="#RPC与RMI的对比" class="headerlink" title="RPC与RMI的对比"></a>RPC与RMI的对比</h3><p>-远程过程调用 (RPC)是平台中立的，它不理会操作系统之间以及编程语言之间的差异。即RPC支持多种语言，而RMI只支持Java写的应用程序。<br>另外RMI调用远程对象方法，允许方法返回Java对象以及基本数据类型。而RPC不支持对象的概念，传送到RPC服务的消息由外部数据表示 (External Data Representation, XDR) 语言表示，这种语言抽象了字节序类和数据类型结构之间的差异。只有由XDR定义的数据类型才能被传递，RPC不允许传递对象。可以说RMI是面向对象方式的Java RPC。</p>
<h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>Java消息服务(Java Messaging Service, JMS) 是一种允许应用程序创建、发送、接受和读取消息的Java API。JMS与RMI的区别在于，采用JMS服务，对象是在物理上被异步从网络的某个JVM上直接移动到另一个JVM上。(严重怀疑)</p>
<p>而RMI对象是绑定在本地JVM中，只有函数参数和返回值是通过网络传送的。</p>
<h2 id="thrift概念"><a href="#thrift概念" class="headerlink" title="thrift概念"></a>thrift概念</h2><p>是facebook提供的一种跨平台远程通信框架，效率比较高。</p>
<h2 id="thirift用法"><a href="#thirift用法" class="headerlink" title="thirift用法"></a>thirift用法</h2><h3 id="1-编写一个thrift文件Test-thrift，用于确定连接双方的接口。"><a href="#1-编写一个thrift文件Test-thrift，用于确定连接双方的接口。" class="headerlink" title="1.编写一个thrift文件Test.thrift，用于确定连接双方的接口。"></a>1.编写一个thrift文件<code>Test.thrift</code>，用于确定连接双方的接口。</h3><p>简单例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">service Test &#123;</div><div class="line">  void  ping(1: i32 length)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-使用thrift编译"><a href="#2-使用thrift编译" class="headerlink" title="2.使用thrift编译"></a>2.使用thrift编译</h3><p>thrift可以用不同命令生成不同文件：</p>
<h4 id="a-生成java文件"><a href="#a-生成java文件" class="headerlink" title="a.生成java文件"></a>a.生成java文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thrift  -gen java Test.thrift</div></pre></td></tr></table></figure>
<p>完成后生成一个java文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;                                   </div><div class="line">  public interfaceIface &#123;                   </div><div class="line">    public void ping(int length)throws org.apache.thrift.TException;             </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="b-生成node-js文件："><a href="#b-生成node-js文件：" class="headerlink" title="b.生成node.js文件："></a>b.生成node.js文件：</h4><p>thrift原生支持<code>node.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thrift  -gen js:node Test.thrift</div></pre></td></tr></table></figure></p>
<p>完成后生成<code>Test.js</code>和<code>Test_types.js</code>两个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Thrift = require(&apos;thrift&apos;).Thrift;</div><div class="line">                                </div><div class="line">var ttypes = require(&apos;./Test_types&apos;);</div><div class="line">//HELPER FUNCTIONS AND STRUCTURES</div><div class="line">                                </div><div class="line">var Test_ping_args =function(args) &#123;</div><div class="line">  this.length = null;</div><div class="line">  if(args) &#123;</div><div class="line">    if(args.length !== undefined) &#123;</div><div class="line">      this.length = args.length;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过需要在node.js里加载thrift库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm intall thrift</div></pre></td></tr></table></figure></p>
<p>准备工作到此结束！</p>
<h3 id="3-实战："><a href="#3-实战：" class="headerlink" title="3.实战："></a>3.实战：</h3><p>使用java当客户端,Node.js当服务端。<br>java客户端代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package apache.thrift;</div><div class="line">              </div><div class="line">import org.apache.thrift.TException;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocol;</div><div class="line">import org.apache.thrift.transport.TFramedTransport;</div><div class="line">import org.apache.thrift.transport.TSocket;</div><div class="line">import org.apache.thrift.transport.TTransport;</div><div class="line">import org.apache.thrift.transport.TTransportException;</div><div class="line">              </div><div class="line"></div><div class="line">public class TestUserStorage &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        TTransport transport =new TFramedTransport(new TSocket(&quot;localhost&quot;,9799));</div><div class="line">        try&#123;</div><div class="line">            transport.open();</div><div class="line">        &#125;catch(TTransportException e1) &#123;</div><div class="line">            e1.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        TProtocol protocol =new TBinaryProtocol(transport);</div><div class="line">              </div><div class="line">        UserStorage.Client client =new UserStorage.Client(protocol);</div><div class="line">        try&#123;</div><div class="line">            client.store(new UserProfile(1,&quot;&quot;,&quot;&quot;));</div><div class="line">            System.out.println(client.retrieve(1));</div><div class="line">        &#125;catch(TException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意两个地方：thrift在java中的实现很多，但是node-thrift模块目前只支持<code>TFramedTransport</code>，<code>TBinaryProtocol</code>，所以使用其他实现时server会出错。另外transport是需要先open进行连接的。</p>
<p>node服务端代码：</p>
<pre><code>var thrift = require(&apos;thrift&apos;);

var UserStorage = require(&apos;./gen-nodejs/UserStorage.js&apos;),
    ttypes = require(&apos;./gen-nodejs/user_types&apos;);

var users = {};

var server = thrift.createServer(UserStorage, {
  store:function(user, success) {
    console.log(&quot;server stored:&quot;, user.uid);
    users[user.uid] = user;
    success();
  },

  retrieve:function(uid, success) {
    console.log(&quot;server retrieved:&quot;, uid);
    success(users[uid]);
  },
});

server.listen(9799);
</code></pre><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">client: UserProfile(uid:1, name:, blurb:)</div><div class="line">server: server stored: 1</div><div class="line">server retrieved: 1</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      facebook的thriff 基于rpc的远程调用实现
    
    </summary>
    
      <category term="RPC" scheme="http://jishusuishouji.github.io/categories/RPC/"/>
    
      <category term="thriff" scheme="http://jishusuishouji.github.io/categories/RPC/thriff/"/>
    
    
      <category term="thriff" scheme="http://jishusuishouji.github.io/tags/thriff/"/>
    
      <category term="rpc" scheme="http://jishusuishouji.github.io/tags/rpc/"/>
    
      <category term="facebook" scheme="http://jishusuishouji.github.io/tags/facebook/"/>
    
  </entry>
  
  <entry>
    <title>hexo安装部署</title>
    <link href="http://jishusuishouji.github.io/2017/04/03/hexo/hexo%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    <id>http://jishusuishouji.github.io/2017/04/03/hexo/hexo安装部署/</id>
    <published>2017-04-03T02:39:14.000Z</published>
    <updated>2017-04-03T04:00:31.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo -g  #-g表示全局安装, npm默认为当前项目安装</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Hexo博客的初始化"><a href="#Hexo博客的初始化" class="headerlink" title="Hexo博客的初始化"></a>Hexo博客的初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd ~/git</div><div class="line">hexo init hexo  #执行init命令初始化到你指定的hexo目录</div><div class="line">cd hexo</div><div class="line">npm install    #install before start blogging</div><div class="line">hexo generate       #自动根据当前目录下文件,生成静态网页</div><div class="line">hexo server         #运行本地服务</div></pre></td></tr></table></figure>
<p>浏览器输入<code>http://localhost:4000</code>就可以看到效果。</p>
<h2 id="Hexo博客目录结构"><a href="#Hexo博客目录结构" class="headerlink" title="Hexo博客目录结构"></a>Hexo博客目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── .deploy       #需要部署的文件</div><div class="line">├── node_modules  #Hexo插件</div><div class="line">├── public        #生成的静态网页文件</div><div class="line">├── scaffolds     #模板</div><div class="line">├── source        #博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里</div><div class="line">|   ├── _drafts   #草稿</div><div class="line">|   └── _posts    #文章</div><div class="line">├── themes        #主题</div><div class="line">├── _config.yml   #全局配置文件</div><div class="line">└── package.json</div></pre></td></tr></table></figure>
<h2 id="安装git插件"><a href="#安装git插件" class="headerlink" title="安装git插件"></a>安装git插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<h2 id="自动生成分类和标签的index-html"><a href="#自动生成分类和标签的index-html" class="headerlink" title="自动生成分类和标签的index.html"></a>自动生成分类和标签的<code>index.html</code></h2><h3 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h3><ul>
<li>go to your hexo folder</li>
<li><code>hexo new page categories</code></li>
<li>in the <code>source\categories\index.md</code>, add <code>type: &quot;tags&quot;</code></li>
<li>if you don’t want to have comments on that page, also add <code>comments: false</code></li>
</ul>
<h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><ul>
<li>go to your hexo folder</li>
<li><code>hexo new page tags</code></li>
<li>in the <code>source\tags\index.md</code>, add <code>type: &quot;tags&quot;</code></li>
<li>if you don’t want to have comments on that page, also add <code>comments: false</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      hexo安装部署
    
    </summary>
    
      <category term="hexo" scheme="http://jishusuishouji.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://jishusuishouji.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster实现原理</title>
    <link href="http://jishusuishouji.github.io/2017/04/03/redis/Redis_Cluster%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://jishusuishouji.github.io/2017/04/03/redis/Redis_Cluster实现原理/</id>
    <published>2017-04-03T00:56:20.000Z</published>
    <updated>2017-04-05T03:07:43.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Redis-Cluster主要特性和设计"><a href="#一、Redis-Cluster主要特性和设计" class="headerlink" title="一、Redis Cluster主要特性和设计"></a>一、Redis Cluster主要特性和设计</h2><h3 id="集群目标"><a href="#集群目标" class="headerlink" title="集群目标"></a>集群目标</h3><p>1）高性能和线性扩展，最大可以支撑到1000个节点；<br>Cluster架构中无Proxy层，Master与slave之间使用异步replication，且不存在操作的merge。（即操作不能跨多个nodes，不存在merge层）</p>
<p>2）一定程度上保证writes的安全性，需要客户端容忍一定程度的数据丢失;<br>集群将会尽可能（best-effort）保存客户端write操作的数据；<br>通常在<code>failover</code>期间，会有短暂时间内的数据丢失（因为异步replication引起）；<br>当客户端与少数派的节点处于网络分区时（network partition），丢失数据的可能性会更高。（因为节点有效性检测、<code>failover</code>需要更长的时间）</p>
<p>3）可用性：只要集群中大多数<code>master</code>可达、且失效的<code>master</code>至少有一个<code>slave</code>可达时，集群都可以继续提供服务；<br>同时“<code>replicas migration</code>”可以将那些拥有多个<code>slaves</code>的<code>master</code>的某个<code>slave</code>，迁移到没有<code>slave</code>的<code>master</code>下，即将整个集群相对<code>slaves</code>的分布更加平衡，尽力确保每个<code>master</code>都有一定数量的<code>slave</code>备份。</p>
<p>（Redis Cluster集群由多个shard组成，每个shard可以由一个master和多个slaves构成，数据根据hash slots配额分布在多个<code>shard</code>节点上，节点之间建立双向TCP链接用于有效性检测、<code>Failover</code>等，Client直接与<code>shard</code>节点进行通讯；<br>Cluster集群没有Proxy层，也没有中央式的Master用于协调集群状态或者state存储；<br>集群暂不提供动态reblance(再平衡)策略）</p>
<p>备注：下文中提到的query、查询等语义，泛指redis的读写操作。</p>
<h3 id="Mutli-key操作"><a href="#Mutli-key操作" class="headerlink" title="Mutli-key操作"></a>Mutli-key操作</h3><p>Redis单实例支持的命令，Cluster也都支持，但是对于“multi-key”操作（即一次RPC调用中需要进行多个key的操作）比如<code>Set</code>类型的交集、并集等，则要求这些key必须属于同一个node。Cluster不能进行跨Nodes操作，也没有nodes提供merge层代理。</p>
<p>Cluster中实现了一个称为“hash tags”的概念，每个key都可以包含一个自定义的“<code>tags</code>”，那么在存储时将根据tags计算此key应该分布在哪个nodes上（而不是使用key计算，但是存储层面仍然是key）；此特性，可以强制某些keys被保存在同一个节点上，以便于进行“multikey”操作，比如“<code>foo</code>”和“<code>{foo}.student</code>”将会被保存在同一个node上。不过在人工对slots进行resharding期间，multikey操作可能不可用。</p>
<p>我们在Redis单例中，偶尔会用到“SELECT”指令，即可以将key保存在特定的database中（默认database索引号为0）；但是在Cluster环境下，将不支持<code>SELECT</code>命令，所有的key都将保存在默认的database中。</p>
<h3 id="客户端与Server角色"><a href="#客户端与Server角色" class="headerlink" title="客户端与Server角色"></a>客户端与Server角色</h3><p>集群中nodes负责存储数据，保持集群的状态，包括keys与nodes的对应关系（内部其实为slots与nodes对应关系）。nodes也能够自动发现其他的nodes，检测失效的节点，当某个master失效时还应该能将合适的slave提升为master。</p>
<p>为了达成这些行为，集群中的每个节点都通过TCP与其他所有nodes建立连接，它们之间的通信协议和方式称为“Redis Cluster Bus”。Nodes之间使用gossip协议向其他nodes传播集群信息，以达到自动发现的特性，通过发送ping来确认其他nodes工作是否正常，也会在合适的时机发送集群的信息。当然在Failover时（包括人为failover）也会使用Bus来传播消息。<br>（gossip：最终一致性，分布式服务数据同步算法，node首先需要知道（可以读取配置）集群中至少一个seed node，此node向seed发送ping请求，此时seed节点pong返回自己已知的所有nodes列表，然后node解析nodes列表并与它们都建立tcp连接，同时也会向每个nodes发送ping，并从它们的pong结果中merge出全局nodes列表，并逐步与所有的nodes建立连接…….数据传输的方式也是类似，网络拓扑结构为full mesh）</p>
<p>因为Node并不提供Proxy机制，当Client将请求发给错误的nodes时（此node上不存在此key所属的slot），node将会反馈“MOVED”或者“ASK”错误信息，以便Client重新定向到合适的node。理论上，Client可以将请求发送给任意一个nodes，然后根据再根据错误信息转发给合适的node，客户端可以不用保存集群的状态信息，当然这种情况下性能比较低效，因为Client可能需要2次TCP调用才能获取key的结果，通常客户端会缓存集群中nodes与slots的映射关系，并在遇到“Redirected”错误反馈时，才会更新本地的缓存。</p>
<h3 id="安全写入（write-safety）"><a href="#安全写入（write-safety）" class="headerlink" title="安全写入（write safety）"></a>安全写入（write safety）</h3><p>在Master-slaves之间使用异步replication机制，在failover之后，新的Master将会最终替代其他的replicas（即slave）。在出现网络分区时（network partition），总会有一个窗口期（node timeout）可能会导致数据丢失；不过，Client与多数派的Master、少数派Master处于一个分区（网络分区，因为网络阻断问题，导致Clients与Nodes被隔离成2部分）时，这两种情况下影响并不相同。</p>
<p>1）write提交到master，master执行完毕后向Client反馈“OK”，不过此时可能数据还没有传播给slaves（异步replication）；如果此时master不可达的时间超过阀值（node timeout，参见配置参数），那么将触发slave被选举为新的Master（即Failover），这意味着那些没有replication到slaves的writes将永远丢失了！<br>2）还有一种情况导致数据丢失：<br>A）因为网络分区，此时master不可达，且Master与Client处于一个分区，且是少数派分区。<br>B）Failover机制，将其中一个slave提升为新Master。<br>C）此后网络分区消除，旧的Master再次可达，此时它将被切换成slave。<br>D）那么在网络分区期间，处于少数派分区的Client仍然将write提交到旧的Master，因为它们觉得Master仍然有效；当旧的Master再次加入集群，切换成slave之后，这些数据将永远丢失。</p>
<p>在第二种情况下，如果Master无法与其他大多数Masters通讯的时间超过阀值后，此Master也将不再接收Writes，自动切换为readonly状态。当网络分区消除后，仍然会有一小段时间，客户端的write请求被拒绝，因为此时旧的Master需要更新本地的集群状态、与其他节点建立连接、角色切换为slave等等，同时Client端的路由信息也需要更新。<br>只有当此master被大多数其他master不可达的时间达到阀值时，才会触发Failover，这个时间称为<code>NODE_TIMEOUT</code>，可以通过配置设定。所以当网络分区在此时间被消除的话，writes不会有任何丢失。反之，如果网络分区持续时间超过此值，处于“小分区”（minority）端的Master将会切换为<code>readonly</code>状态，拒绝客户端继续提交writes请求，那么“大分区”端将会进行<code>failover</code>，这意味着<code>NODE_TIMEOUT</code>期间发生在“小分区”端的writes操作将丢失（因为新的Master上没有同步到那些数据）。 </p>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>处于“小分区”的集群节点是不可用的；“大分区”端必须持有大多数Masters，同时每个不可达的Master至少有一个slave也在“大分区”端，当<code>NODE_TIMEOUT</code>时，触发<code>failover</code>，此后集群才是可用的。Redis Cluster在小部分nodes失效后仍然可以恢复有效性，如果application希望大面积节点失效仍然有效，那么Cluster不适合这种情况。</p>
<p>比如集群有N个Master，且每个Master都有一个slave，那么集群的有效性只能容忍一个节点（master）被分区隔离（即一个master处于小分区端，其他处于大分区端），当第二个节点被分区隔离之前仍保持可用性的概率为1 - (1/(N <em> 2 - 1))（解释：当第一个节点失效后，剩余N </em> 2 -1个节点，此时没有slave的Master失效的概率为1/(N <em> 2 -1)）。比如有5个Master，每个Master有一个slave，当2个nodes被隔离出去（或者失效）后，集群可用性的概率只有1/(5 </em> 2 - 1) = 11.11%。<br>幸好Redis Cluster提供了“replicas migration”机制，在实际应用方面，可以有效的提高集群的可用性，当每次failover发生后，集群都会重新配置、平衡slaves的分布，以更好的抵御下一次失效情况的发生。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Redis Cluster并没有提供Proxy层，而是告知客户端将key的请求转发给合适的nodes。Client保存集群中nodes与keys的映射关系（slots），并保持此数据的更新，所以通常Client总能够将请求直接发送到正确的nodes上。因为采用异步replication，所以master不会等待slaves也保存成功后才向客户端反馈结果，除非显式的指定了<code>WAIT</code>指令。multi-key指令仅限于单个节点内，除了resharding操作外，节点的数据不会在节点间迁移。每个操作只会在特定的一个节点上执行，所以集群的性能为master节点的线性扩展。同时，Clients与每个nodes保持链接，所以请求的延迟等同于单个节点，即请求的延迟并不会因为Cluster的规模增大而受到影响。高性能和扩展性，同时保持合理的数据安全性，是Redis Cluster的设计目标。</p>
<p>Redis Cluster没有Proxy层，Client请求的数据也无法在nodes间merge；因为Redis核心就是K-V数据存储，没有scan类型（<code>sort</code>，<code>limit</code>，<code>group by</code>）的操作，因此merge操作并不被Redis Cluster所接受，而且这种特性会极大增加了Cluster的设计复杂度。</p>
<h2 id="二、Cluster主要组件"><a href="#二、Cluster主要组件" class="headerlink" title="二、Cluster主要组件"></a>二、Cluster主要组件</h2><h3 id="keys分布模型"><a href="#keys分布模型" class="headerlink" title="keys分布模型"></a>keys分布模型</h3><p>集群将key分成16384个slots（hash 槽），slot是数据映射的单位，言外之意，Redis Cluster最多支持16384个nodes（每个nodes持有一个slot）。集群中的每个master持有16384个slots中的一部分，处于“stable”状态时，集群中没有任何slots在节点间迁移，即任意一个hash slot只会被单个node所服务（master，当然可以有多个slave用于replicas，slave也可以用来扩展read请求）。keys与slot的映射关系，是按照如下算法计算的：<code>HASH_SLOT = CRC16(key) mod 16384</code>。其中<code>CRC16</code>是一种冗余码校验和，可以将字符串转换成16位的数字。</p>
<h3 id="hash-tags"><a href="#hash-tags" class="headerlink" title="hash tags"></a>hash tags</h3><p>在计算hash slots时有一个意外的情况，用于支持“hash tags”；hash tags用于确保多个keys能够被分配在同一个hash slot中，用于支持multi-key操作。hash tags的实现比较简单，key中“<code>{}</code>”之间的字符串就是当前key的hash tags，如果存在多个“<code>{}</code>”，首个符合规则的字符串作为<code>hash tags</code>，如果“<code>{}</code>”存在多级嵌套，那么最内层首个完整的字符串作为<code>hash tags</code>，比如“<code>{foo}.student</code>”，那么“<code>foo</code>”是hash tags。如果key中存在合法的hash tags，那么在计算hash slots时，将使用hash tags，而不再使用原始的key。即“<code>foo</code>”与“<code>{foo}.student</code>”将得到相同的slot值，不过“<code>{foo}.student</code>”仍作为key来保存数据，即redis中数据的key仍为“<code>{foo}.student</code>”。</p>
<h3 id="集群节点的属性"><a href="#集群节点的属性" class="headerlink" title="集群节点的属性"></a>集群节点的属性</h3><p>集群中每个节点都有唯一的名字，称之为node ID，一个160位随机数字的16进制表示，在每个节点首次启动时创建。每个节点都将各自的ID保存在实例的配置文件中，此后将一直使用此ID，或者说只要配置文件不被删除，或者没有使用“CLUSTER RESET”指令重置集群，那么此ID将永不会修改。</p>
<p>集群通过node ID来标识节点，而不是使用IP + port，因为node可以修改它的IP和port，不过如果ID不变，我们仍然认定它是集群中合法一员。集群可以在cluster Bus中通过gossip协议来探测IP、port的变更，并重新配置。</p>
<p>node ID并不是与node相关的唯一信息，不过是唯一一个全局一致的。每个node还持有如下相关的信息，有些信息是关系集群配置的，其他的信息比如最后ping时间等。每个node也保存其他节点的IP、Port、flags（比如flags表示它是master还是slave）、最近ping的时间、最近pong接收时间、当前配置的epoch、链接的状态，最重要的是还包含此node上持有的hash slots。这些信息均可通过“CLUSTER NODES”指令开查看。</p>
<h3 id="Cluster-Bus"><a href="#Cluster-Bus" class="headerlink" title="Cluster Bus"></a>Cluster Bus</h3><p>每个Node都有一个特定的TCP端口，用来接收其他nodes的链接；此端口号为面向Client的端口号+10000，比如客户端端口号为<code>6379</code>，那么此node的BUS端口号为<code>16379</code>，客户端端口号可以在配置文件中声明。由此可见，nodes之间的交互通讯是通过Bus端口进行，使用了特定的二进制协议，此端口通常应该只对nodes可用，可以借助防火墙技术来屏蔽其他非法访问。</p>
<h3 id="集群拓扑"><a href="#集群拓扑" class="headerlink" title="集群拓扑"></a>集群拓扑</h3><p>Redis Cluster中每个node都与其他nodes的Bus端口建立TCP链接（full mesh，全网）。比如在由N个节点组成的集群中，每个node有N-1个向外发出的TCP链接，以及N-1个其他nodes发过来的TCP链接；这些TCP链接总是keepalive，不是按需创建的。如果ping发出之后，node在足够长的时间内仍然没有pong响应，那么此node将会被标记为“不可达”，那么与此node的链接将会被刷新或者重建。Nodes之间通过gossip协议和配置更新的机制，来避免每次都交互大量的消息，最终确保在nodes之间的信息传送量是可控的。</p>
<h3 id="节点间handshake"><a href="#节点间handshake" class="headerlink" title="节点间handshake"></a>节点间handshake</h3><p>Nodes通过Bus端口发送ping、pong；如果一个节点不属于集群，那么它的消息将会被其他nodes全部丢弃。一个节点被认为是集群成员的方式有2种：<br>1）如果此node在“Cluster meet”指令中引入，此命令的主要意义就是将指定node加入集群。那么对于当前节点，将认为指定的node为“可信任的”。（此后将会通过gossip协议传播给其他nodes）<br>2）当其他nodes通过gossip引入了新的nodes，这些nodes也是被认为是“可信任的”。</p>
<p>只要我们将一个节点加入集群，最终此节点将会与其他节点建立链接，即cluster可以通过信息交换来自动发现新的节点，链接拓扑仍然是full mesh。</p>
<h2 id="三、重定向与resharding"><a href="#三、重定向与resharding" class="headerlink" title="三、重定向与resharding"></a>三、重定向与resharding</h2><h3 id="MOVED重定向"><a href="#MOVED重定向" class="headerlink" title="MOVED重定向"></a>MOVED重定向</h3><p>理论上，Client可以将请求随意发给任何一个node，包括slaves，此node解析query，如果可以执行（比如语法正确，multiple keys都应该在一个node slots上），它会查看key应该属于哪个slot、以及此slot所在的nodes，如果当前node持有此slot，那么query直接执行即可，否则当前node将会向Client反馈“MOVED”错误：</p>
<pre><code>GET X  
-MOVED 3999 127.0.0.1:6381  
</code></pre><p>错误信息中包括此<code>key</code>对应的slot（3999），以及此slot所在node的ip和port，对于Client 而言，收到<code>MOVED</code>信息后，它需要将请求重新发给指定的node。不过，当node向Client返回<code>MOVED</code>之前，集群的配置也在变更（节点调整、resharding、failover等，可能会导致slot的位置发生变更），此时Client可能需要等待更长的时间，不过最终node会反馈<code>MOVED</code>信息，且信息中包含指定的新的node位置。虽然Cluster使用ID标识node，但是在<code>MOVED</code>信息中尽可能地暴露给客户端便于使用的ip + port。</p>
<p>当Client遇到“<code>MOVED</code>”错误时，将会使用“<code>CLUSTER NODES</code>”或者“<code>CLUSTER SLOTS</code>”指令获取集群的最新信息，主要是nodes与slots的映射关系；因为遇到<code>MOVED</code>，一般也不会仅仅一个slot发生的变更，通常是一个或者多个节点的slots发生了变化，所以进行一次全局刷新是有必要的；我们还应该明白，Client将会把集群的这些信息在被缓存，以便提高query的性能。</p>
<p>还有一个错误信息：“<code>ASK</code>”，它与“<code>MOVED</code>”都属于重定向错误，客户端的处理机制基本相同，只是<code>ASK</code>不会触发Client刷新本地的集群信息。</p>
<h3 id="集群运行时重新配置（live-reconfiguration）"><a href="#集群运行时重新配置（live-reconfiguration）" class="headerlink" title="集群运行时重新配置（live reconfiguration）"></a>集群运行时重新配置（live reconfiguration）</h3><p>我们可以在Cluster运行时增加、删除nodes，这两种操作都会导致：slots在nodes的迁移；当然这种机制也可用来集群数据的rebalance等等。</p>
<p>1）集群中新增一个node，我们需要将其他nodes上的部分slots迁移到此新nodes上，以实现数据负载的均衡分配。<br>2）集群中移除一个node，那么在移除节点之前，必须将此节点上（如果此节点没有任何<code>slaves</code>）的slots迁移到其他nodes。<br>3）如果数据负载不均衡，比如某些slots数据集较大、负载较大时，我们需要它们迁移到负载较小的nodes上（即手动resharding），以实现集群的负载平衡。</p>
<p>Cluster支持slots在nodes间移动；从实际的角度来看，一个slot只是一序列keys的逻辑标识，所以Cluster中slot的迁移，其实就是一序列keys的迁移，不过resharding操作只能以slot为单位（而不能仅仅迁移某些keys）。Redis提供了如下几个操作：</p>
<p>1）<code>CLUSTER ADDSLOTS [slot]</code> ….<br>2）<code>CLUSTER DELSLOTS [slot]</code> …<br>3）<code>CLUSTER SETSLOT [slot] NODE [node]</code><br>4）<code>CLUSTER SETSLOT [slot] MIGRATING [destination-node]</code><br>5）<code>CLUSTER SETSLOT [slot] IMPORTING [source-node]</code></p>
<p>前两个指令：<code>ADDSLOTS</code>和<code>DELSLOTS</code>，用于向当前node分配或者移除slots，指令可以接受多个slot值。分配slots的意思是告知指定的master（即此指令需要在某个master节点执行）此后由它接管相应slots的服务；slots分配后，这些信息将会通过gossip发给集群的其他nodes。<br><code>ADDSLOTS</code>指令通常在创建一个新的Cluster时使用，一个新的Cluster有多个空的Masters构成，此后管理员需要手动为每个master分配slots，并将16384个slots分配完毕，集群才能正常服务。简而言之，<code>ADDSLOTS</code>只能操作那些尚未分配的（即不被任何nodes持有）slots，我们通常在创建新的集群或者修复一个broken的集群（集群中某些slots因为nodes的永久失效而丢失）时使用。为了避免出错，Redis Cluster提供了一个redis-trib辅助工具，方便我们做这些事情。</p>
<p><code>DELSLOTS</code>就是将指定的slots删除，前提是这些slots必须在当前node上，被删除的slots处于“未分配”状态（当然其对应的keys数据也被clear），即尚未被任何nodes覆盖，这种情况可能导致集群处于不可用状态，此指令通常用于debug，在实际环境中很少使用。那些被删除的slots，可以通过<code>ADDSLOTS</code>重新分配。</p>
<p><code>SETSLOT</code>是个很重要的指令，对集群slots进行reshard的最重要手段；它用来将单个slot在两个nodes间迁移。根据slot的操作方式，它有两种状态“<code>MIGRATING</code>”、“<code>IMPORTING</code>”（或者说迁移的方式）<br>1）<code>MIGRATING</code>：将slot的状态设置为“<code>MIGRATING</code>”，并迁移到destination-node上，需要注意当前node必须是slot的持有者。在迁移期间，Client的查询操作仍在当前node上执行，如果key不存在，则会向Client反馈“-<code>ASK</code>”重定向信息，此后Client将会把请求重新提交给迁移的目标node。<br>2）<code>IMPORTING</code>：将slot的状态设置为“IMPORTING”，并将其从source-node迁移到当前node上，前提是source-node必须是slot的持有者。Client交互机制同上。</p>
<p>假如我们有两个节点A、B，其中slot 8在A上，我们希望将8从A迁移到B，可以使用如下方式：<br>1）在B上：<code>CLUSTER SETSLOT 8 IMPORTING A</code><br>2）在A上：<code>CLUSTER SETSLOT 8 MIGRATING B</code><br>在迁移期间，集群中其他的nodes的集群信息不会改变，即slot 8仍对应A，即此期间，Client查询仍在A上：<br>1）如果key在A上存在，则由A执行。<br>2）否则，将向客户端返回ASK，客户端将请求重定向到B。<br>这种方式下，新key的创建就不会在A上执行，而是在B上执行，这也就是ASK重定向的原因（迁移之前的keys在A，迁移期间created的keys在B上）；当上述<code>SETSLOT</code>执行完毕后，slot的状态也会被自动清除，同时将slot迁移信息传播给其他nodes，至此集群中slot的映射关系将会变更，此后slot 8的数据请求将会直接提交到B上。</p>
<h3 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h3><p>在上文中，我们已经介绍了<code>MOVED</code>重定向，<code>ASK</code>与其非常相似。在resharding期间，为什么不能用<code>MOVED</code>？MOVED意思为hash slots已经永久被另一个node接管、接下来的相应的查询应该与它交互，<code>ASK</code>的意思是当前query暂时与指定的node交互；在迁移期间，slot 8的keys有可能仍在A上，所以Client的请求仍然需要首先经由A，对于A上不存在的，我们才需要到B上进行尝试。迁移期间，Redis Cluster并没有粗暴的将slot 8的请求全部阻塞、直到迁移结束，这种方式尽管不再需要<code>ASK</code>，但是会影响集群的可用性。<br>1）当Client接收到<code>ASK</code>重定向，它仅仅将当前query重定向到指定的node；此后的请求仍然交付给旧的节点。<br>2）客户端并不会更新本地的slots映射，仍然保持slot 8与A的映射；直到集群迁移完毕，且遇到<code>MOVED</code>重定向。</p>
<p>一旦slot 8迁移完毕之后（集群的映射信息也已更新），如果Client再次在A上访问slot 8时，将会得到<code>MOVED</code>重定向信息，此后客户端也更新本地的集群映射信息。</p>
<h3 id="客户端首次链接以及重定向处理"><a href="#客户端首次链接以及重定向处理" class="headerlink" title="客户端首次链接以及重定向处理"></a>客户端首次链接以及重定向处理</h3><p>可能有些Cluster客户端的实现，不会在内存中保存slots映射关系（即nodes与slots的关系），每次请求都从声明的、已知的nodes中，随机访问一个node，并根据重定向（<code>MOVED</code>）信息来寻找合适的node，这种访问模式，通常是非常低效的。<br>当然，Client应该尽可能的将slots配置信息缓存在本地，不过配置信息也不需要绝对的实时更新，因为在请求时偶尔出现“重定向”，Client也能兼容此次请求的正确转发，此时再更新slots配置。（所以Client通常不需要间歇性的检测Cluster中配置信息是否已经更新）客户端通常是全量更新slots配置：<br>1）首次链接到集群的某个节点<br>2）当遇到<code>MOVED</code>重定向消息时<br>遇到<code>MOVED</code>时，客户端仅仅更新特定的slot是不够的，因为集群中的reshard通常会影响到多个slots。客户端通过向任意一个nodes发送“<code>CLUSTER NODES</code>”或者“<code>CLUSTER SLOTS</code>”指令均可以获得当前集群最新的slots映射信息；“<code>CLUSTER SLOTS</code>”指令返回的信息更易于Client解析。如果集群处于broken状态，即某些slots尚未被任何nodes覆盖，指令返回的结果可能是不完整的。</p>
<h3 id="Multikeys操作"><a href="#Multikeys操作" class="headerlink" title="Multikeys操作"></a>Multikeys操作</h3><p>前文已经介绍，基于hash tags机制，我们可以在集群中使用<code>Multikeys</code>操作。不过，在resharding期间，Multikeys操作将可能不可用，比如这些keys不存在于同一个slot（迁移会导致keys被分离）；比如<code>Multikeys</code>逻辑上属于同一个slot，但是因为resharding，它们可能暂时不处于同一个nodes，有些可能在迁移的目标节点上（比如<code>Multikeys</code>包含a、b、c三个keys，逻辑上它们都属于slot 8，但是其中c在迁移期间创建，它被存储在节点B上，a、b仍然在节点A），此时将会向客户端返回“<code>-TRYAGAIN</code>”错误，那么客户端此后将需要重试一次，或者直接返回错误（如果迁移操作被中断），无论如何最终<code>Multikeys</code>的访问逻辑是一致的，slots的状态也是最终确定的。</p>
<h3 id="slaves扩展reads请求"><a href="#slaves扩展reads请求" class="headerlink" title="slaves扩展reads请求"></a>slaves扩展reads请求</h3><p>通常情况下，read、write请求都将有持有slots的master节点处理；因为redis的slaves可以支持read操作（前提是application能够容忍stale数据），所以客户端可以使用“<code>READONLY</code>”指令来扩展read请求。<br>“<code>READONLY</code>”表明其可以访问集群的slaves节点，能够容忍stale数据，而且此次链接不会执行writes操作。当链接设定为<code>readonly</code>模式后，Cluster只有当keys不被slave的master节点持有时才会发送重定向消息（即Client的read请求总是发给slave，只有当此slave的master不持有slots时才会重定向，很好理解）：<br>1）此slave的master节点不持有相应的slots<br>2）集群重新配置，比如reshard或者slave迁移到了其他master上，此slave本身也不持有此slot。</p>
<p>此时Client更新本地的slot配置信息，同上文所述。（目前很多Client实现均基于连接池，所以不能非常便捷的设置<code>READLONLY</code>选项，非常遗憾）</p>
<h2 id="四、容错（Fault-Tolerance）"><a href="#四、容错（Fault-Tolerance）" class="headerlink" title="四、容错（Fault Tolerance）"></a>四、容错（Fault Tolerance）</h2><h3 id="心跳与gossip消息"><a href="#心跳与gossip消息" class="headerlink" title="心跳与gossip消息"></a>心跳与gossip消息</h3><p>集群中的nodes持续的交换ping、pong数据，这两种数据包的结构一样，同样都能携带集群的配置信息，唯一不同的就是<code>message</code>中的<code>type</code>字段。<br>通常，一个node发送ping消息，那么接收者将会反馈pong消息；不过有时候并非如此，或许接收者将pong信息发给其他的nodes，而不是直接反馈给发送者，比如当集群中添加新的node时。<br>通常一个node每秒都会随机向几个nodes发送ping，所以无论集群规模多大，每个nodes发送的ping数据包的总量是恒定的。每个node都确保尽可能的向那些在半个NODE_TIMEOUT时间内，尚未发送过ping或者接收到它们的pong消息的nodes发送ping。在NODE_TIMEOUT逾期之前，nodes也会尝试与那些通讯异常的nodes重新建立TCP链接，确保不能仅仅因为当前链接异常而认为它们就是不可达的。</p>
<p>当NODE_TIMEOUT值较小、集群中nodes规模较大时，那么全局交换的信息量也会非常庞大，因为每个node都尽力在半个NODE_TIMEOUT时间内，向其他nodes发送ping。比如有100个nodes，<code>NODE_TIMEOUT</code>为60秒，那么每个node在30秒内向其他99各nodes发送ping，平均每秒3.3个消息，那么整个集群全局就是每秒330个消息。这些消息量，并不会对集群的带宽带来不良问题。</p>
<h3 id="心跳数据包的内容"><a href="#心跳数据包的内容" class="headerlink" title="心跳数据包的内容"></a>心跳数据包的内容</h3><p>1）node ID<br>2）currentEpoch和configEpoch<br>3）node flags：比如表示此node是maste、slave等<br>4）hash slots：发送者持有的slots<br>5）如果发送者是slave，那么其master的ID<br>6）其他..</p>
<p>ping和pong数据包中也包含gossip部分，这部分信息包含sender持有的集群视图，不过它只包含sender已知的随机几个nodes，nodes的数量根据集群规模的大小按比例计算。gossip部分包含了nodes的ID、ip+port、flags，那么接收者将根据sender的视图，来判定节点的状态，这对故障检测、节点自动发现非常有用。</p>
<h3 id="失效检测"><a href="#失效检测" class="headerlink" title="失效检测"></a>失效检测</h3><p>集群失效检测就是，当某个master或者slave不能被大多数nodes可达时，用于故障迁移并将合适的<code>slave</code>提升为master。当slave提升未能有效实施时，集群将处于error状态且停止接收Client端查询。<br>如上所述，每个node有持有其已知nodes的列表包括flags，有2个flag状态：PFAIL和FAIL；PFAIL表示“可能失效”，是一种尚未完全确认的失效状态（即某个节点或者少数masters认为其不可达）。FAIL表示此node已经被集群大多数masters判定为失效（大多数master已认定为不可达，且不可达时间已达到设定值，需要failover）。</p>
<h3 id="PFAIL："><a href="#PFAIL：" class="headerlink" title="PFAIL："></a>PFAIL：</h3><p>一个被标记为PFAIL的节点，表示此node不可达的时间超过NODE_TIMEOUT，master和slave有可以被标记为PFAIL。所谓不可达，就是当“active ping”（发送ping且能受到pong）尚未成功的时间超过<code>NODE_TIMEOUT</code>，因此我们设定的NODE_TIMEOUT的值应该比网络交互往返的时间延迟要大一些（通常要大的多，以至于交互往返时间可以忽略）。为了避免误判，当一个node在半个NODE_TIMEOUT时间内仍未能pong，那么当前node将会尽力尝试重新建立连接进行重试，以排除pong未能接收是因为当前链接故障的问题。</p>
<h3 id="FAIL："><a href="#FAIL：" class="headerlink" title="FAIL："></a>FAIL：</h3><p>PFAIL只是当前node有关于其他nodes的本地视图，可能每个node对其他nodes的本地视图都不一样，所以PFAIL还不足以触发Failover。处于PFAIL状态下的node可以被提升到FAIL状态。如上所述，每个node在向其他nodes发送gossip消息时，都会包含本地视图中几个随机nodes的状态信息；每个node最终都会从其他nodes发送的消息中获得一组nodes的flags。因此，每个node都可以通过这种机制来通知其他nodes，它检测到的故障情况。</p>
<h3 id="PFAIL被上升为FAIL的集中情况："><a href="#PFAIL被上升为FAIL的集中情况：" class="headerlink" title="PFAIL被上升为FAIL的集中情况："></a>PFAIL被上升为FAIL的集中情况：</h3><p>1）比如A节点，认为B为PFAIL<br>2）那么A通过gossip信息，收集集群中大多数masters关于B的状态视图。<br>3）多数master都认为B为PFAIL，或者PFAIL情况持续时间为NODE_TIMEOUT * FAIL_REPORT_VALIDITY_MULT（此值当前为2）</p>
<p>如果上述条件成立，那么A将会：<br>1）将B节点设定为FAIL<br>2）将FAIL信息发送给其所有能到达的所有节点。</p>
<p>每个接收到FAIL消息的节点都会强制将此node标记为FAIL状态，不管此节点在本地视图中是否为PFAIL。FAIL状态是单向的，即PFAIL可以转换为FAIL，但是FAIL状态只能清除，不能回转为PFAIL：</p>
<p>1）当此node已经变的可达，且为slave，这种情况下FAIL状态将会被清除，因为没有发生failover。<br>2）此node已经可达，且是一个没有服务任何slots的master（空的master）；这种情况下，FAIL将会被清除，因为master没有持有slots，所以它并没有真正参与到集群中，需要等到重新配置以便它加入集群。<br>3）此node已经可达，且是master，且在较长时间内（N倍的NODE_TIMEOUT）没有检测到slave的提升，即没有slave发生failover（比如此master下没有slave），那么它只能重新加入集群且仍为master。</p>
<p>需要注意的是PFAIL-&gt;FAIL的转变，使用了“协议”（agreement）的形式：<br>1）nodes会间歇性的收集其他nodes的视图，即使大多数masters都“agree”，事实上这个状态，仅仅是我们从不同的nodes、不同的时间收集到的，我们无法确认（也不需要）在特定时刻大多数masters是否“agree”。我们丢弃较旧的故障报告，所以此故障（FAIL）是有大多数masters在一段时间内的信号。<br>2）虽然每个node在检测到FAIL情况时，都会通过FAIL消息发送给其他nodes，但是无法保证消息一定会到达所有的nodes，比如可能当前节点（发送消息的node）因为网络分区与其他部分nodes隔离了。</p>
<p>如果只有少数master认为某个node为FAIL，并不会触发相应的slave提升，即failover，因为可能是因为网络分区导致。FAIL标记只是用来触发slave 提升；在原理上，当master不可达时将会触发slave提升，不过当master仍然被大多数可达时，它会拒绝提供相应的确认。</p>
<h2 id="五、Failover相关的配置"><a href="#五、Failover相关的配置" class="headerlink" title="五、Failover相关的配置"></a>五、Failover相关的配置</h2><h3 id="集群currentEpoch"><a href="#集群currentEpoch" class="headerlink" title="集群currentEpoch"></a>集群currentEpoch</h3><p>Redis Cluster使用了类似于Raft算法“term”（任期）的概念，那么在redis Cluster中term称为epoch，用来给events增量版本号。当多个nodes提供了信息有冲突时，它可以作为node来知道哪个状态是最新的。currentEpoch为一个64位无签名数字。<br>在集群node创建时，master和slave都会将各自的currentEpoch设置为0，每次从其他node接收到数据包时，如果发现发送者的epoch值比自己的大，那么当前node将自己的currentEpoch设置为发送者的epoch。由此，最终所有的nodes都会认同集群中最大的epoch值；当集群的状态变更，或者node为了执行某个行为需求agreement时，都将需要epoch（传递或者比较）。</p>
<p>当前来说，只有在slave提升期间发生；currentEpoch为集群的逻辑时钟（logical clock），指使持有较大值的获胜。（currentEpoch，当前集群已达成认同的epoch值，通常所有的nodes应该一样）</p>
<h3 id="configEpoch"><a href="#configEpoch" class="headerlink" title="configEpoch"></a>configEpoch</h3><p>每个master总会在ping、pong数据包中携带自己的configEpoch以及它持有的slots列表。新创建的node，其configEpoch为0，slaves通过递增它们的configEpoch来替代失效的master，并尝试获得其他大多数master的授权（认同）。当slave被授权，一个新的configEpoch被生成，slave提升为master且使用此configEpoch。<br>接下来介绍configEpoch帮助解决冲突，当不同的nodes宣称有分歧的配置时。<br>slaves在ping、pong数据包中也会携带自己的configEpoch信息，不过这个epoch为它与master在最近一次数据交换时，master的configEpoch。<br>每当节点发现configEpoch值变更时，都会将新值写入nodes.conf文件，当然currentEpoch也也是如此。这两个变量在写入文件后会伴随磁盘的fsync，持久写入。严格来说，集群中所有的master都持有唯一的configEpoch值。同一组master-slaves持有相同的configEpoch。</p>
<h3 id="slave选举与提升"><a href="#slave选举与提升" class="headerlink" title="slave选举与提升"></a>slave选举与提升</h3><p>在slaves节点中进行选举，在其他masters的帮助下进行投票，选举出一个slave并提升为master。当master处于FAIL状态时，将会触发slave的选举。slaves都希望将自己提升为master，此master的所有slaves都可以开启选举，不过最终只有一个slave获胜。当如下情况满足时，slave将会开始选举：<br>1）当此slave的master处于FAIL状态<br>2）此master持有非零个slots<br>3）此slave的replication链接与master断开时间没有超过设定值，为了确保此被提升的slave的数据是新鲜的，这个时间用户可以配置。</p>
<p>为了选举，第一步，就是slave自增它的currentEpoch值，然后向其他masters请求投票（需求支持，votes）。slave通过向其他masters传播“FAILOVER_AUTH_REQUEST”数据包，然后最长等待2倍的NODE_TIMEOUT时间，来接收反馈。一旦一个master向此slave投票，将会响应“FAILOVER_AUTH_ACK”，此后在2 <em> NODE_TIMOUT时间内，它将不会向同一个master的slaves投票；虽然这对保证安全上没有必要，但是对避免多个slaves同时选举时有帮助的。slave将会丢弃那些epoch值小于自己的currentEpoch的AUTH_ACK反馈，即不会对上一次选举的投票计数（只对当前轮次的投票计数）。一旦此slave获取了大多数master的ACKs，它将在此次选举中获胜；否则如果大多数master不可达（在2 </em> NODE_TIMEOUT）或者投票额不足，那么它的选举将会被中断，那么其他的slave将会继续尝试。</p>
<h3 id="slave-rank（次序）"><a href="#slave-rank（次序）" class="headerlink" title="slave rank（次序）"></a>slave rank（次序）</h3><p>当master处于FAIL状态时，slave将会随机等待一段时间，然后才尝试选举，等待的时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</div></pre></td></tr></table></figure></p>
<p>一定的延迟确保我们等待FAIL状态在集群中传播，否则slave立即尝试选举（不进行等待的话），不过此时其他masters或许尚未意识到FAIL状态，可能会拒绝投票。</p>
<p>延迟的时间是随机的，这用来“去同步”（desynchronize），避免slaves同时开始选举。SLAVE_RANK表示此slave已经从master复制数据的总量的rank。当master失效时，slaves之间交换消息以尽可能的构建rank，持有replication offset最新的rank为0，第二最新的为1，依次轮推。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。当然rank顺序也不是严格执行的，如果一个持有较小rank的slave选举失败，其他slaves将会稍后继续。</p>
<p>一旦，slave选举成功，它将获取一个新的、唯一的、自增的configEpoch值，此值比集群中任何masters持有的都要大，它开始宣称自己是master，并通过ping、pong数据包传播，并提供自己的新的configEpoch以及持有的slots列表。为了加快其他nodes的重新配置，pong数据包将会在集群中广播。当前node不可达的那些节点，它们可以从其他节点的ping或者pong中获知信息（gossip），并重新配置。</p>
<p>其他节点也会检测到这个新的master和旧master持有相同的slots，且持有更高的configEpoch，此时也会更新自己的配置（epoch，以及master）；旧master的slaves不仅仅更新配置信息，也会重新配置并与新的master跟进（slave of）。</p>
<h3 id="Masters响应slave的投票请求"><a href="#Masters响应slave的投票请求" class="headerlink" title="Masters响应slave的投票请求"></a>Masters响应slave的投票请求</h3><p>当Master接收到slave的“FAILOVER_AUTH_REQUEST”请求后，开始投票，不过需要满足如下条件：<br>1）此master只会对指定的epoch投票一次，并且拒绝对旧的epoch投票：每个master都持有一个lastVoteEpoch，将会拒绝AUTH_REQUEST中currentEpoch比lastVoteEpoch小的请求。当master响应投票时，将会把lastVoteEpoch保存在磁盘中。<br>2）此slave的master处于FAIL状态时，master才会投票。<br>3）如果slave的currentEpoch比此master的currentEpoch小，那么AUTH_REQUEST将会被忽略。因为master只会响应那些与自己的currentEpoch相等的请求。如果同一个slave再此请求投票，持有已经增加的currentEpoch，它（slave）将保证旧的投票响应不能参与计票。</p>
<p>比如master的currentEpoch为5，lastVoteEpoch为1：<br>1）slave的currentEpoch为3<br>2）slave在选举开始时，使用epoch为4（先自增），因为小于master的epoch，所以投票响应被延缓。<br>3）slave在一段时间后将重新选举，使用epoch为5（4 + 1，再次自增），此时master上延缓的响应发给slave，接收后视为有效。</p>
<p>1）master在2 * NODE_TIMEOUT超时之前，不会对同一个master的slave再次投票。这并不是严格需要，因为也不太可能两个slave在相同的epoch下同时赢得选举。不过，它确保当一个slave选举成功后，它（slave）有一段缓冲时间来通知其他的slaves，避免另一个slave赢得了新的一轮的选择，避免不必要的二次failover。<br>2）master并不会尽力选举最合适的slave。当slave的master处于FAIL状态，此master在当前任期（term）内并不投票，只是批准主动投票者（即master不发起选举，只批准别人的投票）。最合适的slave应该在其他slaves之前，首先发起选举。<br>3）当master拒绝一个slave投票，并不会发出一个“否决”响应，而是简单的忽略。<br>4）slave发送的configEpoch是其master的，还包括其master持有的slots；master不会向持有相同slots、但configEpoch只较低的slave投票。</p>
<h3 id="Hash-Slots配置传播"><a href="#Hash-Slots配置传播" class="headerlink" title="Hash Slots配置传播"></a>Hash Slots配置传播</h3><p>Redis Cluster中重要的一部分就是传播集群中哪些节点上持有的哪些hash slots信息；无论是启动一个新的集群，还是当master失效其slave提升后更新配置，这对它们都至关重要。有2种方式用于hash slot配置的传播：<br>1）heartbeat 消息：发送者的ping、pong消息中，总是携带自己目前持有的slots信息，不管自己是master还是slave。<br>2）UPDATE 消息：因为每个心跳消息中会包含发送者的configEpoch和其持有的slots，如果接收者发现发送者的信息已经stale（比如发送者的configEpoch值小于持有相同slots的master的值），它会向发送者反馈新的配置信息（UPDATE），强制stale节点更新它。</p>
<p>当一个新的节点加入集群，其本地的hash slots映射表将初始为NULL，即每个hash slot都没有与任何节点绑定。<br>Rule 1：如果此node本地视图中一个hash slot尚未分配（设置为NULL），并且有一个已知的node声明持有它，那么此node将会修改本地hash slot的映射表，将此slot与那个node关联。slave的failover操作、reshard操作都会导致hash slots映射的变更，新的配置信息将会通过心跳在集群中传播。<br>Rule 2：如果此node的本地视图中一个hash slot已经分配，并且一个已知的node也声明持有它，且此node的configEpoch比当前slot关联的master的configEpoch值更大，那么此node将会把slot重新绑定到新的node上。根据此规则，最终集群中所有的nodes都赞同那个持有声明持有slot、且configEpoch最大值的nodes为slot的持有者。</p>
<h3 id="nodes如何重新加入集群"><a href="#nodes如何重新加入集群" class="headerlink" title="nodes如何重新加入集群"></a>nodes如何重新加入集群</h3><p>node A被告知slot 1、2现在由node B接管，假如这两个slots目前由A持有，且A只持有这两个slots，那么此后A将放弃这2个slots，成为空的节点；此后A将会被重新配置，成为其他新master的slave。这个规则可能有些复杂，A离群一段时间后重新加入集群，此时A发现此前自己持有的slots已经被其他多个nodes接管，比如slot 1被B接管，slot 2被C接管。<br>在重新配置时，最终此节点上的slots将会被清空，那个窃取自己最后一个slot的node，将成为它的新master。<br>节点重新加入集群，通常发生在failover之后，旧的master（也可以为slave）离群，然后重新加入集群。</p>
<h3 id="Replica迁移"><a href="#Replica迁移" class="headerlink" title="Replica迁移"></a>Replica迁移</h3><p>Redis Cluster实现了一个成为“Replica migration”的概念，用来提升集群的可用性。比如集群中每个master都有一个slave，当集群中有一个master或者slave失效时，而不是master与它的slave同时失效，集群仍然可以继续提供服务。<br>1）master A，有一个slave A1<br>2）master A失效，A1被提升为master<br>3）一段时间后，A1也失效了，那么此时集群中没有其他的slave可以接管服务，集群将不能继续服务。</p>
<p>如果masters与slaves之间的映射关系是固定的（fixed），提高集群抗灾能力的唯一方式，就是给每个master增加更多的slaves，不过这种方式开支很大，需要更多的redis实例。<br>解决这个问题的方案，我们可以将集群非对称，且在运行时可以动态调整master-slaves的布局（而不是固定master-slaves的映射），比如集群中有三个master A、B、C，它们对应的slave为A1、B1、C1、C2，即C节点有2个slaves。“Replica迁移”可以自动的重新配置slave，将其迁移到某个没有slave的master下。<br>1）A失效，A1被提升为master<br>2）此时A1没有任何slave，但是C仍然有2个slave，此时C2被迁移到A1下，成为A1的slave<br>3）此后某刻，A1失效，那么C2将被提升为master。集群可以继续提供服务。</p>
<h3 id="Replica迁移算法"><a href="#Replica迁移算法" class="headerlink" title="Replica迁移算法"></a>Replica迁移算法</h3><p>迁移算法并没有使用“agree”形式，而是使用一种算法来避免大规模迁移，这个算法确保最终每个master至少有一个slave即可。起初，我们先定义哪个slave是良好的：一个良好的slave不能处于FAIL状态。触发时机为，任何一个slave检测到某个master没有一个良好slave时。参与迁移的slave必须为，持有最多slaves的master的其中一个slave，且不处于FAIL状态，且持有最小的node ID。<br>比如有10个masters都持有一个slave，有2个masters各持有5个slaves，那么迁移将会发生在持有5个slaves的masters中，且node ID最小的slave node上。我们不再使用“agreement”，不过也有可能当集群的配置不够稳定时，有一种竞争情况的发生，即多个slaves都认为它们自己的ID最小；如果这种情况发生，结果就是可能多个slaves会迁移到同一个master下，不过这并没有什么害处，但是最坏的结果是导致原来的master迁出了所有的slaves，让自己变得单一。但是迁移算法（进程）会在迁移完毕之后重新判断，如果尚未平衡，那么将会重新迁移。<br>最终，每个master最少持有一个slave；这个算法由用户配置的“cluster-migration-barrier”，此配置参数表示一个master至少保留多少个slaves，其他多余的slaves可以被迁出。此值通常为1，如果设置为2，表示一个master持有的slaves个数大于2时，多余的slaves才可以迁移到持有更少slaves的master下。</p>
<h3 id="configEpoch冲突解决算法"><a href="#configEpoch冲突解决算法" class="headerlink" title="configEpoch冲突解决算法"></a>configEpoch冲突解决算法</h3><p>在slave failover期间，会生成新的configEpoch值，需要保证唯一性。不过有2种不同的event会导致configEpoch的创建是不安全的：仅仅自增本地的currentEpoch并希望它不会发生冲突。这两个事件有系统管理员触发：<br>1）CLUSTER FAILOVER：这个指令，就是人为的将某个slave提升为master，而不需要要求大多数masters的投票参与。<br>2）slots的迁移，用于平衡集群的数据分布（reshard）；此时本地的configEpoch也会修改，因为性能的考虑，这个过程也不需要“agreement”。</p>
<p>在手动reshard期间，当一个hash slot从A迁移到B，resharding程序将强制B更新自己的配置信息、epoch值也修改为集群的最大值 + 1（除非B的configEpoch已经是最大值），这种变更则不需要其他nodes的agreement（注意与failover的原理不同）。通常每次resharding都会迁移多个slots，且有多个nodes参与，如果每个slots迁移都需要agreement，才能生成新的epoch，这种性能是很差的，也不可取。我们在首个slots迁移开始时，只会生成一个新的configEpoch，在迁移完毕后，将新的配置传播给集群即可，这种方式在生产环境中更加高效。</p>
<p>因为上述两个情况，有可能（虽然概率极小）最终多个nodes产生了相同的configEpoch；比如管理员正在进行resharding，但是此时failover发生了…无论是failover还是resharding都是将currentEpoch自增，而且resharding不使用agreement形式（即其他nodes或许不知道，而且网络传播可能延迟），这就会发生epoch值的冲突问题。</p>
<p>当持有不同slots的masters持有相同的configEpoch，这并不会有什么问题。比较遗憾的是，人工干预或者resharding会以不同的方式修改了集群的配置，Cluster要求所有的slots都应该被nodes覆盖，所以在任何情况下，我们都希望所有的master都持有不同的configEpoch。避免冲突的算法，就是用来解决当2个nodes持有相同的configEpoch：<br>1）如果一个master节点发现其他master持有相同的configEpoch。<br>2）并且此master逻辑上持有较小的node ID（字典顺序）<br>3）然后此master将自己的currentEpoch加1，并作为自己新的configEpoch。</p>
<p>如果有多个nodes持有相同的congfigEpoch，那么除了持有最大ID的节点外，其他的nodes都将往前推进（+1，直到冲突解决），最终保证每个master都持有唯一的configEpoch（slave的configEpoch与master一样）。对于新创建的cluster也是同理，所有的nodes都初始为不同的configEpoch。</p>
<h3 id="Node-resets"><a href="#Node-resets" class="headerlink" title="Node resets"></a>Node resets</h3><p>所有的nodes都可以进行软件级的reset（不需要重启、重新部署它们），reset为了重用集群（重新设定集群），必须需要将某个（些）节点重置后添加到其他集群。我们可以使用“CLUSTER RESET”指令：<br>1）CLUSTER RESET SOFT<br>2）CLUSTER RESET HARD</p>
<p>指令必须直接发给需要reset的节点，如果没有指定reset类型，默认为SOFT。<br>1）soft和hard：如果节点为slave，那么节点将会转换为master，并清空其持有的数据，成为一个空的master。如果此节点为master，且持有slots数据，那么reset操作将被中断。<br>2）soft和hard：其上持有的slots将会被释放<br>3）soft和hard：此节点上的nodes映射表将会被清除，此后此node将不会知道其他节点的存在与状态。<br>4）hard：currentEpoch、configEpoch、lastVoteEpoch值将被重置为0。<br>5）hard：此nodeID将会重新生成。</p>
<p>持有数据的（slot映射不为空的）master不能被reset（除非现将此master上的slot手动迁移到其他nodes上，或者手动failover，将其切换成slave）；在某些特定的场景下，在执行reset之前，或许需要执行FLUSHALL来清空原有的数据。</p>
<h3 id="集群中移除节点"><a href="#集群中移除节点" class="headerlink" title="集群中移除节点"></a>集群中移除节点</h3><p>我们已经知道，将node移除集群之前，首先将其上的slots迁移到其他nodes上（reshard），然后关闭它。不过这似乎还并未结束，因为其他nodes仍然记住了它的ID，仍然会尝试与它建立连接。因此，当我们确定将节点移除集群时，可以使用“CLUSTER FORGET <node-id>”指令：<br>1）将此node从nodes映射表中移除。<br>2）然后设定一个60秒的隔离时间，阻止持有相同ID的node再次加入集群。</node-id></p>
<p>之所以2）规则，因为FORGET指令将会通过gossip协议传播给其他nodes，集群中所有的节点都收到消息是需要一定的时间延迟。</p>
]]></content>
    
    <summary type="html">
    
      Redis Cluster实现原理
    
    </summary>
    
      <category term="Redis" scheme="http://jishusuishouji.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://jishusuishouji.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>全面剖析Redis Cluster原理和应用</title>
    <link href="http://jishusuishouji.github.io/2017/04/02/redis/%E5%85%A8%E9%9D%A2%E5%89%96%E6%9E%90Redis_Cluster%E5%8E%9F%E7%90%86%E5%92%8C%E5%BA%94%E7%94%A8/"/>
    <id>http://jishusuishouji.github.io/2017/04/02/redis/全面剖析Redis_Cluster原理和应用/</id>
    <published>2017-04-02T15:57:30.000Z</published>
    <updated>2017-04-02T16:04:03.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Redis-Cluster总览"><a href="#1-Redis-Cluster总览" class="headerlink" title="1.Redis Cluster总览"></a>1.Redis Cluster总览</h2><h3 id="1-1-设计原则和初衷"><a href="#1-1-设计原则和初衷" class="headerlink" title="1.1 设计原则和初衷"></a>1.1 设计原则和初衷</h3><p>在官方文档ClusterSpec中，作者详细介绍了Redis集群为什么要设计成现在的样子。最核心的目标有三个：</p>
<ul>
<li>性能：这是Redis赖以生存的看家本领，增加集群功能后当然不能对性能产生太大影响，所以Redis采取了P2P而非Proxy方式、异步复制、客户端重定向等设计，而牺牲了部分的一致性、使用性。</li>
<li>水平扩展：集群的最重要能力当然是扩展，文档中称可以线性扩展到1000结点。</li>
<li>可用性：在Cluster推出之前，可用性要靠Sentinel保证。有了集群之后也自动具有了Sentinel的监控和自动Failover能力。</li>
</ul>
<h3 id="1-2-架构变化与CAP理论"><a href="#1-2-架构变化与CAP理论" class="headerlink" title="1.2 架构变化与CAP理论"></a>1.2 架构变化与CAP理论</h3><p>Redis Cluster集群功能推出已经有一段时间了。在单机版的Redis中，每个Master之间是没有任何通信的，所以我们一般在Jedis客户端或者Codis这样的代理中做Pre-sharding。按照CAP理论来说，单机版的Redis属于保证CP(Consistency &amp; Partition-Tolerancy)而牺牲A(Availability)，也就说Redis能够保证所有用户看到相同的数据（一致性，因为Redis不自动冗余数据）和网络通信出问题时，暂时隔离开的子系统能继续运行（分区容忍性，因为Master之间没有直接关系，不需要通信），但是不保证某些结点故障时，所有请求都能被响应（可用性，某个Master结点挂了的话，那么它上面分片的数据就无法访问了）。</p>
<p>有了Cluster功能后，Redis从一个单纯的NoSQL内存数据库变成了分布式NoSQL数据库，CAP模型也从CP变成了AP。也就是说，通过自动分片和冗余数据，Redis具有了真正的分布式能力，某个结点挂了的话，因为数据在其他结点上有备份，所以其他结点顶上来就可以继续提供服务，保证了Availability。然而，也正因为这一点，Redis无法保证曾经的强一致性了。这也是CAP理论要求的，三者只能取其二。</p>
<p>简单分析了Redis在架构上的变化后，咱们就一起来体验一下Redis Cluster功能吧！</p>
<p>2.Redis集群初探</p>
<p>Redis的安装很简单，以前已经介绍过，就不详细说了。关于Redis Cluster的基础知识之前也有过整理，请参考《Redis集群功能预览》。如果需要全面的了解，那一定要看官方文档Cluster Tutorial，只看这一个就够了！</p>
<p>2.1 集群配置</p>
<p>要想开启Redis Cluster模式，有几项配置是必须的。此外为了方便使用和后续的测试，我还额外做了一些配置：</p>
<p>绑定地址：bind 192.168.XXX.XXX。不能绑定到127.0.0.1或localhost，否则指导客户端重定向时会报”Connection refused”的错误。<br>开启Cluster：cluster-enabled yes<br>集群配置文件：cluster-config-file nodes-7000.conf。这个配置文件不是要我们去配的，而是Redis运行时保存配置的文件，所以我们也不可以修改这个文件。<br>集群超时时间：cluster-node-timeout 15000。结点超时多久则认为它宕机了。<br>槽是否全覆盖：cluster-require-full-coverage no。默认是yes，只要有结点宕机导致16384个槽没全被覆盖，整个集群就全部停止服务，所以一定要改为no<br>后台运行：daemonize yes<br>输出日志：logfile “./redis.log”<br>监听端口：port 7000<br>配置好后，根据我们的集群规模，拷贝出来几份同样的配置文件，唯一不同的就是监听端口，可以依次改为7001、7002… 因为Redis Cluster如果数据冗余是1的话，至少要3个Master和3个Slave，所以我们拷贝出6个实例的配置文件。为了避免相互影响，为6个实例的配置文件建立独立的文件夹。</p>
<p>[root@8gVm redis-3.0.4]# pwd<br>/root/Software/redis-3.0.4<br>[root@8gVm redis-3.0.4]# tree -I “<em>log|nodes</em>“ cfg-cluster/<br>cfg-cluster/<br>├── 7000<br>│   └── redis.conf.7000<br>├── 7001<br>│   └── redis.conf.7001<br>├── 7002<br>│   └── redis.conf.7002<br>├── 7003<br>│   └── redis.conf.7003<br>├── 7004<br>│   └── redis.conf.7004<br>└── 7005<br>    └── redis.conf.7005</p>
<p>6 directories, 6 files<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>2.2 redis-trib管理器</p>
<p>Redis作者应该是个Ruby爱好者，Ruby客户端就是他开发的。这次集群的管理功能没有嵌入到Redis代码中，于是作者又顺手写了个叫做redis-trib的管理脚本。redis-trib依赖Ruby和RubyGems，以及redis扩展。可以先用which命令查看是否已安装ruby和rubygems，用gem list –local查看本地是否已安装redis扩展。</p>
<p>最简便的方法就是用apt或yum包管理器安装RubyGems后执行gem install redis。如果网络或环境受限的话，可以手动安装RubyGems和redis扩展（国外链接可能无法下载，可以从CSDN下载）：</p>
<p>[root@8gVm Software]# wget <a href="https://github.com/rubygems/rubygems/releases/download/v2.2.3/rubygems-2.2.3.tgz" target="_blank" rel="external">https://github.com/rubygems/rubygems/releases/download/v2.2.3/rubygems-2.2.3.tgz</a><br>[root@8gVm Software]# tar xzvf rubygems-2.2.3.tgz<br>[root@8gVm Software]# cd rubygems-2.2.3<br>[root@8gVm rubygems-2.2.3]# ruby setup.rb –no-rdoc –no-ri</p>
<p>[root@8gVm Software]# wget <a href="https://rubygems.org/downloads/redis-3.2.1.gem" target="_blank" rel="external">https://rubygems.org/downloads/redis-3.2.1.gem</a><br>[root@8gVm Software]# gem install redis-3.2.1.gem –local –no-rdoc –no-ri<br>Successfully installed redis-3.2.1<br>1 gem installed<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>2.3 集群建立</p>
<p>首先，启动我们配置好的6个Redis实例。</p>
<p>[root@8gVm redis-3.0.4]# for ((i=0; i&lt;6; ++i))</p>
<blockquote>
<p>do<br>cd cfg-cluster/700$i &amp;&amp; ../../src/redis-server redis.conf.700$i &amp;&amp; cd -<br>done<br>1<br>2<br>3<br>4<br>1<br>2<br>3<br>4<br>此时6个实例还没有形成集群，现在用redis-trb.rb管理脚本建立起集群。可以看到，redis-trib默认用前3个实例作为Master，后3个作为Slave。因为Redis基于Master-Slave做数据备份，而非像Cassandra或Hazelcast一样不区分结点角色，自动复制并分配Slot的位置到各个结点。</p>
</blockquote>
<p>[root@8gVm redis-3.0.4]# src/redis-trib.rb create –replicas 1 192.168.1.100:7000 192.168.1.100:7001 192.168.1.100:7002 192.168.1.100:7003 192.168.1.100:7004 192.168.1.100:7005</p>
<blockquote>
<blockquote>
<blockquote>
<p>Creating cluster<br>Connecting to node 192.168.1.100:7000: OK<br>Connecting to node 192.168.1.100:7001: OK<br>Connecting to node 192.168.1.100:7002: OK<br>Connecting to node 192.168.1.100:7003: OK<br>Connecting to node 192.168.1.100:7004: OK<br>Connecting to node 192.168.1.100:7005: OK<br>Performing hash slots allocation on 6 nodes…<br>Using 3 masters:<br>192.168.1.100:7000<br>192.168.1.100:7001<br>192.168.1.100:7002<br>Adding replica 192.168.1.100:7003 to 192.168.1.100:7000<br>Adding replica 192.168.1.100:7004 to 192.168.1.100:7001<br>Adding replica 192.168.1.100:7005 to 192.168.1.100:7002<br>    …<br>Can I set the above configuration? (type ‘yes’ to accept): yes<br>Nodes configuration updated<br>Assign a different config epoch to each node<br>Sending CLUSTER MEET messages to join the cluster<br>Waiting for the cluster to join….<br>Performing Cluster Check (using node 192.168.1.100:7000)<br>    …<br>[OK] All nodes agree about slots configuration.<br>Check for open slots…<br>Check slots coverage…<br>[OK] All 16384 slots covered.<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>至此，集群就已经建立成功了！“贴心”的Redis还在utils/create-cluster下提供了一个create-cluster脚本，能够创建出一个集群，类似我们上面建立起的3主3从的集群。</p>
</blockquote>
</blockquote>
</blockquote>
<p>2.4 简单测试</p>
<p>我们连接到集群中的任意一个结点，启动redis-cli时要加-c选项，存取两个Key-Value感受一下Redis久违的集群功能。</p>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000<br>192.168.1.100:7000&gt; set foo bar<br>-&gt; Redirected to slot [12182] located at 192.168.1.100:7002<br>OK<br>192.168.1.100:7002&gt; set hello world<br>-&gt; Redirected to slot [866] located at 192.168.1.100:7000<br>OK<br>192.168.1.100:7000&gt; get foo<br>-&gt; Redirected to slot [12182] located at 192.168.1.100:7002<br>“bar”<br>192.168.1.100:7002&gt; get hello<br>-&gt; Redirected to slot [866] located at 192.168.1.100:7000<br>“world”<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>仔细观察能够注意到，redis-cli根据指示，不断在7000和7002结点之前重定向跳转。如果启动时不加-c选项的话，就能看到以错误形式显示出的MOVED重定向消息。</p>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -h 192.168.1.100 -p 7000<br>192.168.1.100:7000&gt; get foo<br>(error) MOVED 12182 192.168.1.100:7002<br>1<br>2<br>3<br>1<br>2<br>3<br>2.5 集群重启</p>
<p>目前redis-trib的功能还比较弱，需要重启集群的话先手动kill掉各个进程，然后重新启动就可以了。这也有点太… 网上有人重启后会碰到问题，我还比较幸运，这种“土鳖”的方式重启试了两次还没发现问题。</p>
<p>[root@8gVm redis-3.0.4]# ps -ef | grep redis | awk ‘{print $2}’ | xargs kill<br>1<br>1<br>3.高级功能尝鲜</p>
<p>说是“高级功能”，其实在其他分布式系统中早就都有实现了，只不过在Redis世界里是比较新鲜的。本部分主要试验一下Redis Cluster中的数据迁移(Resharding)和故障转移功能。</p>
<p>3.1 数据迁移</p>
<p>本小节我们体验一下Redis集群的Resharding功能！</p>
<p>3.1.1 创建测试数据</p>
<p>首先保存foo1~10共10个Key-Value作为测试数据。</p>
<p>[root@8gVm redis-3.0.4]# for ((i=0; i&lt;10; ++i))</p>
<blockquote>
<p>do<br>src/redis-cli -c -h 192.168.1.100 -p 7000 set foo$i bar<br>done</p>
</blockquote>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000<br>192.168.1.100:7000&gt; keys <em><br>1) “foo6”<br>2) “foo7”<br>3) “foo3”<br>4) “foo2”<br>192.168.1.100:7000&gt; get foo4<br>-&gt; Redirected to slot [9426] located at 192.168.1.100:7001<br>“bar”<br>192.168.1.100:7001&gt; keys </em><br>1) “foo4”<br>2) “foo8”<br>192.168.1.100:7001&gt; get foo5<br>-&gt; Redirected to slot [13555] located at 192.168.1.100:7002<br>“bar”<br>192.168.1.100:7002&gt; keys *<br>1) “foo5”<br>2) “foo1”<br>3) “foo10”<br>4) “foo9”<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>3.1.2 启动新结点</p>
<p>参照之前的方法新拷贝出两份redis.conf配置文件redis.conf.7010和7011，与之前结点的配置文件做一下区分。启动新的两个Redis实例之后，通过redis-trib.rb脚本添加新的Master和Slave到集群中。</p>
<p>[root@8gVm redis-3.0.4]# cd cfg-cluster/7010 &amp;&amp; ../../src/redis-server redis.conf.7010 &amp;&amp; cd -<br>[root@8gVm redis-3.0.4]# cd cfg-cluster/7011 &amp;&amp; ../../src/redis-server redis.conf.7011 &amp;&amp; cd -<br>1<br>2<br>1<br>2<br>3.1.3 添加到集群</p>
<p>使用redis-trib.rb add-node分别将两个新结点添加到集群中，一个作为Master，一个作为其Slave。</p>
<p>[root@8gVm redis-3.0.4]# src/redis-trib.rb add-node 192.168.1.100:7010 192.168.1.100:7000</p>
<blockquote>
<blockquote>
<blockquote>
<p>Adding node 192.168.1.100:7010 to cluster 192.168.1.100:7000<br>Connecting to node 192.168.1.100:7000: OK<br>Connecting to node 192.168.1.100:7001: OK<br>Connecting to node 192.168.1.100:7002: OK<br>Connecting to node 192.168.1.100:7005: OK<br>Connecting to node 192.168.1.100:7003: OK<br>Connecting to node 192.168.1.100:7004: OK<br>Performing Cluster Check (using node 192.168.1.100:7000)<br>    …<br>[OK] All nodes agree about slots configuration.<br>Check for open slots…<br>Check slots coverage…<br>[OK] All 16384 slots covered.<br>Connecting to node 192.168.1.100:7010: OK<br>Send CLUSTER MEET to node 192.168.1.100:7010 to make it join the cluster.<br>[OK] New node added correctly.</p>
</blockquote>
</blockquote>
</blockquote>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000 cluster nodes<br>0d1f9c979684e0bffc8230c7bb6c7c0d37d8a5a9 192.168.1.100:7010 master - 0 1442452249525 0 connected<br>    …</p>
<p>[root@8gVm redis-3.0.4]# src/redis-trib.rb add-node –slave –master-id 0d1f9c979684e0bffc8230c7bb6c7c0d37d8a5a9 192.168.1.100:7011 192.168.1.100:7000</p>
<blockquote>
<blockquote>
<blockquote>
<p>Adding node 192.168.1.100:7011 to cluster 192.168.1.100:7000<br>Connecting to node 192.168.1.100:7000: OK<br>Connecting to node 192.168.1.100:7010: OK<br>Connecting to node 192.168.1.100:7001: OK<br>Connecting to node 192.168.1.100:7002: OK<br>Connecting to node 192.168.1.100:7005: OK<br>Connecting to node 192.168.1.100:7003: OK<br>Connecting to node 192.168.1.100:7004: OK<br>Performing Cluster Check (using node 192.168.1.100:7000)<br>    …<br>[OK] All nodes agree about slots configuration.<br>Check for open slots…<br>Check slots coverage…<br>[OK] All 16384 slots covered.<br>Connecting to node 192.168.1.100:7011: OK<br>Send CLUSTER MEET to node 192.168.1.100:7011 to make it join the cluster.<br>Waiting for the cluster to join.<br>Configure node as replica of 192.168.1.100:7010.<br>[OK] New node added correctly.<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>3.1.4 Resharding</p>
</blockquote>
</blockquote>
</blockquote>
<p>通过redis-trib.rb reshard可以交互式地迁移Slot。下面的例子将5000个Slot从7000~7002迁移到7010上。也可以通过./redis-trib.rb reshard <host>:<port> –from <node-id> –to <node-id> –slots –yes在程序中自动完成迁移。</node-id></node-id></port></host></p>
<p>[root@8gVm redis-3.0.4]# src/redis-trib.rb reshard 192.168.1.100:7000<br>Connecting to node 192.168.1.100:7000: OK<br>Connecting to node 192.168.1.100:7010: OK<br>Connecting to node 192.168.1.100:7001: OK<br>Connecting to node 192.168.1.100:7002: OK<br>Connecting to node 192.168.1.100:7005: OK<br>Connecting to node 192.168.1.100:7011: OK<br>Connecting to node 192.168.1.100:7003: OK<br>Connecting to node 192.168.1.100:7004: OK</p>
<blockquote>
<blockquote>
<blockquote>
<p>Performing Cluster Check (using node 192.168.1.100:7000)<br>M: b2036adda128b2eeffa36c3a2056444d23b548a8 192.168.1.100:7000<br>   slots:0-5460 (4128 slots) master<br>   1 additional replica(s)<br>M: 0d1f9c979684e0bffc8230c7bb6c7c0d37d8a5a9 192.168.1.100:7010<br>   slots:0 (4000 slots) master<br>   1 additional replica(s)<br>   …<br>[OK] All nodes agree about slots configuration.<br>Check for open slots…<br>Check slots coverage…<br>[OK] All 16384 slots covered.<br>How many slots do you want to move (from 1 to 16384)? 5000<br>What is the receiving node ID? 0d1f9c979684e0bffc8230c7bb6c7c0d37d8a5a9<br>Please enter all the source node IDs.<br>  Type ‘all’ to use all the nodes as source nodes for the hash slots.<br>  Type ‘done’ once you entered all the source nodes IDs.<br>Source node #1:all</p>
</blockquote>
</blockquote>
</blockquote>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000 cluster nodes<br>0d1f9c979684e0bffc8230c7bb6c7c0d37d8a5a9 192.168.1.100:7010 master - 0 1442455872019 7 connected 0-1332 5461-6794 10923-12255<br>b2036adda128b2eeffa36c3a2056444d23b548a8 192.168.1.100:7000 myself,master - 0 0 1 connected 1333-5460<br>b5ab302f5c2395e3c8194c354a85d02f89bace62 192.168.1.100:7001 master - 0 1442455875022 2 connected 6795-10922<br>0c565e207ce3118470fd5ed3c806eb78f1fdfc01 192.168.1.100:7002 master - 0 1442455874521 3 connected 12256-16383<br>    …<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>迁移完成后，查看之前保存的foo1~10的分布情况，可以看到部分Key已经迁移到了新的结点7010上。</p>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000 keys “<em>“<br>1) “foo3”<br>2) “foo7”<br>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7001 keys “</em>“<br>1) “foo4”<br>2) “foo8”<br>3) “foo0”<br>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7002 keys “<em>“<br>1) “foo1”<br>2) “foo9”<br>3) “foo5”<br>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7010 keys “</em>“<br>1) “foo6”<br>2) “foo2”<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>3.2 故障转移</p>
<p>在高可用性方面，Redis可算是能够”Auto”一把了！Redis Cluster重用了Sentinel的代码逻辑，不需要单独启动一个Sentinel集群，Redis Cluster本身就能自动进行Master选举和Failover切换。</p>
<p>下面我们故意kill掉7010结点，之后可以看到结点状态变成了fail，而Slave 7011被选举为新的Master。</p>
<p>[root@8gVm redis-3.0.4]# kill 43637</p>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000 cluster nodes<br>0d1f9c979684e0bffc8230c7bb6c7c0d37d8a5a9 192.168.1.100:7010 master,fail - 1442456829380 1442456825674 7 disconnected<br>b2036adda128b2eeffa36c3a2056444d23b548a8 192.168.1.100:7000 myself,master - 0 0 1 connected 1333-5460<br>b5ab302f5c2395e3c8194c354a85d02f89bace62 192.168.1.100:7001 master - 0 1442456848722 2 connected 6795-10922<br>0c565e207ce3118470fd5ed3c806eb78f1fdfc01 192.168.1.100:7002 master - 0 1442456846717 3 connected 12256-16383<br>5a3c67248b1df554fbf2c93112ba429f31b1d3d1 192.168.1.100:7005 slave 0c565e207ce3118470fd5ed3c806eb78f1fdfc01 0 1442456847720 6 connected<br>99bff22b97119cf158d225c2b450732a1c0d3c44 192.168.1.100:7011 master - 0 1442456849725 8 connected 0-1332 5461-6794 10923-12255<br>cd305d509c34842a8047e19239b64df94c13cb96 192.168.1.100:7003 slave b2036adda128b2eeffa36c3a2056444d23b548a8 0 1442456848220 4 connected<br>64b544cdd75c1ce395fb9d0af024b7f2b77213a3 192.168.1.100:7004 slave b5ab302f5c2395e3c8194c354a85d02f89bace62 0 1442456845715 5 connected<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>尝试查询之前保存在7010上的Key，可以看到7011顶替上来继续提供服务，整个集群没有受到影响。</p>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000 get foo6<br>“bar”<br>[root@8gVm redis-3.0.4]#<br>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000 get foo2<br>“bar”<br>1<br>2<br>3<br>4<br>5<br>1<br>2<br>3<br>4<br>5<br>4.内部原理剖析</p>
<p>前面我们已经学习过，用Redis提供的redis-trib或create-cluster脚本能几步甚至一步就建立起一个Redis集群。这一部分我们为了深入学习，所以要暂时抛开这些方便的工具，完全手动建立一遍上面的3主3从集群。</p>
<p>4.1 集群发现：MEET</p>
<p>最开始时，每个Redis实例自己是一个集群，我们通过cluster meet让各个结点互相“握手”。这也是Redis Cluster目前的一个欠缺之处：缺少结点的自动发现功能。</p>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000 cluster nodes<br>33c0bd93d7c7403ef0239ff01eb79bfa15d2a32c :7000 myself,master - 0 0 0 connected</p>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000 cluster meet 192.168.1.100 7001<br>OK<br>    …<br>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000 cluster meet 192.168.1.100 7005<br>OK</p>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000 cluster nodes<br>7b953ec26bbdbf67179e5d37e3cf91626774e96f 192.168.1.100:7003 master - 0 1442466369259 4 connected<br>5d9f14cec1f731b6477c1e1055cecd6eff3812d4 192.168.1.100:7005 master - 0 1442466368659 4 connected<br>33c0bd93d7c7403ef0239ff01eb79bfa15d2a32c 192.168.1.100:7000 myself,master - 0 0 1 connected<br>63162ed000db9d5309e622ec319a1dcb29a3304e 192.168.1.100:7001 master - 0 1442466371262 3 connected<br>45baa2cb45435398ba5d559cdb574cfae4083893 192.168.1.100:7002 master - 0 1442466372264 2 connected<br>cdd5b3a244761023f653e08cb14721f70c399b82 192.168.1.100:7004 master - 0 1442466370261 0 connecte<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>4.2 角色设置：REPLICATE</p>
<p>结点全部“握手”成功后，就可以用cluster replicate命令为结点指定角色了，默认每个结点都是Master。</p>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7003 cluster replicate 33c0bd93d7c7403ef0239ff01eb79bfa15d2a32c<br>OK<br>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7004 cluster replicate 63162ed000db9d5309e622ec319a1dcb29a3304e<br>OK<br>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7005 cluster replicate 45baa2cb45435398ba5d559cdb574cfae4083893<br>OK</p>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000 cluster nodes<br>7b953ec26bbdbf67179e5d37e3cf91626774e96f 192.168.1.100:7003 slave 33c0bd93d7c7403ef0239ff01eb79bfa15d2a32c 0 1442466812984 4 connected<br>5d9f14cec1f731b6477c1e1055cecd6eff3812d4 192.168.1.100:7005 slave 45baa2cb45435398ba5d559cdb574cfae4083893 0 1442466813986 5 connected<br>33c0bd93d7c7403ef0239ff01eb79bfa15d2a32c 192.168.1.100:7000 myself,master - 0 0 1 connected<br>63162ed000db9d5309e622ec319a1dcb29a3304e 192.168.1.100:7001 master - 0 1442466814987 3 connected<br>45baa2cb45435398ba5d559cdb574cfae4083893 192.168.1.100:7002 master - 0 1442466811982 2 connected<br>cdd5b3a244761023f653e08cb14721f70c399b82 192.168.1.100:7004 slave 63162ed000db9d5309e622ec319a1dcb29a3304e 0 1442466812483 3 connected<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>4.3 槽指派：ADDSLOTS</p>
<p>设置好主从关系之后，就可以用cluster addslots命令指派16384个槽的位置了。有点恶心的是，ADDSLOTS命令需要在参数中一个个指明槽的ID，而不能指定范围。这里用Bash 3.0的特性简化了，不然就得用Bash的循环来完成了：</p>
<p>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7000 cluster addslots {0..5000}<br>OK<br>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7001 cluster addslots {5001..10000}<br>OK<br>[root@8gVm redis-3.0.4]# src/redis-cli -c -h 192.168.1.100 -p 7001 cluster addslots {10001..16383}<br>OK</p>
<p>[root@8gVm redis-3.0.4]# src/redis-trib.rb check 192.168.1.100:7000<br>Connecting to node 192.168.1.100:7000: OK<br>  …</p>
<blockquote>
<blockquote>
<blockquote>
<p>Performing Cluster Check (using node 192.168.1.100:7000)<br>  …<br>[OK] All nodes agree about slots configuration.<br>Check for open slots…<br>Check slots coverage…<br>[OK] All 16384 slots covered.<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>这样我们就通过手动执行命令得到了与之前一样的集群。</p>
</blockquote>
</blockquote>
</blockquote>
<p>4.4 数据迁移：MIGRATE</p>
<p>真正开始Resharding之前，redis-trib会先在源结点和目的结点上执行cluster setslot <slot> importing和cluster setslot <slot> migrating命令，将要迁移的槽分别标记为迁出中和导入中的状态。然后，执行cluster getkeysinslot获得Slot中的所有Key。最后就可以对每个Key执行migrate命令进行迁移了。槽迁移完成后，执行cluster setslot命令通知整个集群槽的指派已经发生变化。</slot></slot></p>
<p>关于迁移过程中的数据访问，客户端访问源结点时，如果Key还在源结点上就直接操作。如果已经不在源结点了，就向客户端返回一个ASK错误，将客户端重定向到目的结点。</p>
<p>4.5 内部数据结构</p>
<p>Redis Cluster功能涉及三个核心的数据结构clusterState、clusterNode、clusterLink都在cluster.h中定义。这三个数据结构中最重要的属性就是：clusterState.slots、clusterState.slots_to_keys和clusterNode.slots了，它们保存了三种映射关系：</p>
<p>clusterState：集群状态<br>nodes：所有结点<br>migrating_slots_to：迁出中的槽<br>importing_slots_from：导入中的槽<br>slots_to_keys：槽中包含的所有Key，用于迁移Slot时获得其包含的Key<br>slots：Slot所属的结点，用于处理请求时判断Key所在Slot是否自己负责<br>clusterNode：结点信息<br>slots：结点负责的所有Slot，用于发送Gossip消息通知其他结点自己负责的Slot。通过位图方式保存节省空间，16384/8恰好是2048字节，所以槽总数16384不是随意定的。<br>clusterLink：与其他结点通信的连接<br>// 集群状态，每个节点都保存着一个这样的状态，记录了它们眼中的集群的样子。<br>// 另外，虽然这个结构主要用于记录集群的属性，但是为了节约资源，<br>// 有些与节点有关的属性，比如 slots_to_keys 、 failover_auth_count<br>// 也被放到了这个结构里面。<br>typedef struct clusterState {<br>    …<br>    // 指向当前节点的指针<br>    clusterNode <em>myself;  /</em> This node */</p>
<pre><code>// 集群当前的状态：是在线还是下线
int state;            /* REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ... */

// 集群节点名单（包括 myself 节点）
// 字典的键为节点的名字，字典的值为 clusterNode 结构
dict *nodes;          /* Hash table of name -&gt; clusterNode structures */

// 记录要从当前节点迁移到目标节点的槽，以及迁移的目标节点
// migrating_slots_to[i] = NULL 表示槽 i 未被迁移
// migrating_slots_to[i] = clusterNode_A 表示槽 i 要从本节点迁移至节点 A
clusterNode *migrating_slots_to[REDIS_CLUSTER_SLOTS];

// 记录要从源节点迁移到本节点的槽，以及进行迁移的源节点
// importing_slots_from[i] = NULL 表示槽 i 未进行导入
// importing_slots_from[i] = clusterNode_A 表示正从节点 A 中导入槽 i
clusterNode *importing_slots_from[REDIS_CLUSTER_SLOTS];

// 负责处理各个槽的节点
// 例如 slots[i] = clusterNode_A 表示槽 i 由节点 A 处理
clusterNode *slots[REDIS_CLUSTER_SLOTS];

// 跳跃表，表中以槽作为分值，键作为成员，对槽进行有序排序
// 当需要对某些槽进行区间（range）操作时，这个跳跃表可以提供方便
// 具体操作定义在 db.c 里面
zskiplist *slots_to_keys;
...
</code></pre><p>} clusterState;</p>
<p>// 节点状态<br>struct clusterNode {<br>    …<br>    // 节点标识<br>    // 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），<br>    // 以及节点目前所处的状态（比如在线或者下线）。<br>    int flags;      /<em> REDIS<em>NODE</em>… </em>/</p>
<pre><code>// 由这个节点负责处理的槽
// 一共有 REDIS_CLUSTER_SLOTS / 8 个字节长
// 每个字节的每个位记录了一个槽的保存状态
// 位的值为 1 表示槽正由本节点处理，值为 0 则表示槽并非本节点处理
// 比如 slots[0] 的第一个位保存了槽 0 的保存情况
// slots[0] 的第二个位保存了槽 1 的保存情况，以此类推
unsigned char slots[REDIS_CLUSTER_SLOTS/8]; /* slots handled by this node */

// 指针数组，指向各个从节点
struct clusterNode **slaves; /* pointers to slave nodes */

// 如果这是一个从节点，那么指向主节点
struct clusterNode *slaveof; /* pointer to the master node */
...
</code></pre><p>};</p>
<p>/<em> clusterLink encapsulates everything needed to talk with a remote node. </em>/<br>// clusterLink 包含了与其他节点进行通讯所需的全部信息<br>typedef struct clusterLink {<br>    …<br>    // TCP 套接字描述符<br>    int fd;                     /<em> TCP socket file descriptor </em>/</p>
<pre><code>// 与这个连接相关联的节点，如果没有的话就为 NULL
struct clusterNode *node;   /* Node related to this link if any, or NULL */
...
</code></pre><p>} clusterLink;<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>4.6 处理流程全梳理</p>
<p>在单机模式下，Redis对请求的处理很简单。Key存在的话，就执行请求中的操作；Key不存在的话，就告诉客户端Key不存在。然而在集群模式下，因为涉及到请求重定向和Slot迁移，所以对请求的处理变得很复杂，流程如下：</p>
<p>检查Key所在Slot是否属于当前Node？<br>2.1 计算crc16(key) % 16384得到Slot<br>2.2 查询clusterState.slots负责Slot的结点指针<br>2.3 与myself指针比较<br>若不属于，则响应MOVED错误重定向客户端<br>若属于且Key存在，则直接操作，返回结果给客户端<br>若Key不存在，检查该Slot是否迁出中？(clusterState.migrating_slots_to)<br>若Slot迁出中，返回ASK错误重定向客户端到迁移的目的服务器上<br>若Slot未迁出，检查Slot是否导入中？(clusterState.importing_slots_from)<br>若Slot导入中且有ASKING标记，则直接操作<br>否则响应MOVED错误重定向客户端<br>5.应用案例收集</p>
<p>5.1 有道：Redis Cluster使用经验</p>
<p>详情请参见原文，关键内容摘录如下：</p>
<p>5.1.1 两个缺点</p>
<p>“redis cluster的设计在这块有点奇葩，跟集群相关的操作需要一个外部的ruby脚本来协助（当然可能是为了让主程序的代码足够简洁？），然后那个脚本还只支持填实例的ip不支持host，还不告诉你不支持让你用host之后各种莫名其妙。”</p>
<p>“第一个缺点就是严格依赖客户端driver的成熟度。如果把redis cluster设计成类似Cassandra，请求集群中任何一个节点都可以负责转发请求，client会好写一些。”</p>
<p>“第二个缺点完全是设计问题了，就是一个redis进程既负责读写数据又负责集群交互，虽然设计者已经尽可能简化了代码和逻辑，但还是让redis从一个内存NoSQL变成了一个分布式NoSQL。分布式系统很容易有坑，一旦有坑必须升级redis。”</p>
<p>5.1.2 去中心化 vs. Proxy</p>
<p>“关于redis cluster的设计，Gossip/P2P的去中心化架构本身不是问题，但一旦有了中心节点，能做的事情就多了，比如sharding不均匀是很容易自动rebalance的，而无中心的只能靠外界来搞。然后redis cluster又是slot的形式而非C*式的一致性哈希，新节点分slot又不自动，依赖外界（ruby脚本）来分配显得不方便更不优美和谐。而且因为是master-slave的系统而非W+R&gt;N的那种，master挂掉之后尽快发现是比较重要的，gossip对于节点挂掉的发现终究没有中心节点/zookeeper方便快速。”</p>
<p>“基于proxy做转发意味着屏蔽了下层存储，完全可以根据前缀/tag/冷热程度，来把部分甚至大多数数据放在磁盘从而节约成本又保证一致性，这都是有中心节点所带来的好处。”</p>
<p>5.2 奇虎360：Redis Cluster浅析和Bada对比</p>
<p>详情请参见原文，关键内容摘录如下：</p>
<p>5.2.1 负载均衡问题</p>
<p>“redis cluster的主备是以节点为单位，而bada则是以partition为单位，这样，同样是3个节点，1024个partition的情况下，redis cluster的主节点负责整个1024个partition的服务，而两个从节点则只负责异步备份，导致集群负载不均，再看bada，将1024个partition的主均分到3个节点中，每个节点各有主备，主对外提供服务，这样均分了访问压力，有效的利用了资源。”</p>
<p>5.2.2 一致性的保证</p>
<p>“redis cluster与bada一样，最终一致性，读写都只请求主节点，当一条写请求在对应的主节点写成功后，会立刻返回给客户端成功，然后主节点通过异步的方式将新的数据同步到对应的从节点，这样的方式减少了客户端多个节点写成功等待的时间，不过在某些情况下会造成写丢失：</p>
<p>1）当主节点接受一条写请求，写入并返回给客户端成功后不幸宕掉，此时刚才的写还未同步给其对应的从节点，而从节点在发现主节点挂掉并重新选主后，新的主节点则永久丢失了之前老的主节点向用户确认的写</p>
<p>2）当网络发生割裂，将集群分裂成少数派与多数派，这样在客户端不知情的情况下，会将写继续写入到少数派中的某些主节点中，而当割裂超过一定时长后，集群感知到异常，此时少数派中的所有主节点会停止响应所有的写请求，多数派的其对应的从节点则会发起选举成为新的主节点，假设过了一会后割裂恢复，老的主节点发现有更新的主存在，自动变成其从节点，而新的主节点中则会永久丢失掉网络割裂至集群感知异常进行切主这个阶段老主节点确认的所有写</p>
<p>相对于redis cluster的永久丢失，bada通过binlog merge有效的解决了这一问题。所有partition的主节点在响应客户端的写请求时，都会在本地记录binlog，binlog实质就是带有时间戳的KV对。当老主以从节点的身份重新加入集群时，会触发binlog merge操作，新主会比较并且合并二者的binlog，这样就可以将之前丢失掉得写再补回来。”</p>
<p>5.2.3 请求重定向问题</p>
<p>“bada服务端节点在收到本不该由自己负责的Partition请求后，不会向客户端返回重定向信息，而是通过代理的方式，直接在集群内部向正确节点转发客户端的请求，并将结果同meta信息再转发回客户端。”</p>
<p>“再看multi key操作，redis cluster为了追求高性能，支持multi key的前提是所有的key必须在同一个节点中, 不过这样的处理需要交给用户，对需要进行multi key操作的所有key，在写入前人为的加上hash tags。当redis cluster进行resharding的时候，也就是将某些slot从一个节点迁移到另一个节点时，此时的multi key操作可能会失败，因为在迁移的slot中的key此时存在于两个节点。</p>
<p>bada怎么做呢？用户如果对multi key操作性能很在乎时，可以采用与redis cluster同样的方式，给这些key加上hash tags来让它们落在同一个节点，如果可以接受性能的稍微损耗而解放用户的处理逻辑，则可以像single key操作一样，请求任一bada节点，它会代理所有的key请求并将结果返回给用户。并且在multi key操作在任何时候都可以，即使在进行partition的迁移，bada也会提前进行切主，保证服务的正常提供。”</p>
<p>5.3 芒果TV：Redis服务解决方案</p>
<p>详情请参见原文，关键内容摘录如下：</p>
<p>芒果TV在Redis Cluster基础上进行开发，主要增加了两个组件：</p>
<p>监控管理：以Python为主要开发框架的Web应用程序Redis-ctl<br>请求代理：以C++11为开发语言的轻量数据代理程序cerberus。其作用和优点为：<br>集群代理程序的自动请求分发/重试机制使得应用不必修改自身代码或更新Redis库<br>代理节点为所有Redis节点加上统一管理和状态监测, 可以查阅历史数据, 或在发生任何问题之后快速响应修复<br>代理进程的无状态性使之可在故障后快速恢复, 不影响后端集群数据完整性<br>这两个组件都已开源到GitHub上，大家可以关注一下！</p>
<p>6.Pros &amp; Cons总结</p>
<p>关于Redis Cluster带来的种种优势就不说了，在这里主要是“鸡蛋里挑骨头”，总结一下现阶段集群功能的欠缺之处和可能的“坑”。</p>
<p>6.1 无中心化架构</p>
<p>6.1.1 Gossip消息</p>
<p>Gossip消息的网络开销和时延是决定Redis Cluster能够线性扩展的因素之一。关于这个问题，在《redis cluster百万QPS的挑战》一文中有所提及。</p>
<p>6.1.2 结点粒度备份</p>
<p>此外，Redis Cluster也许是为了简化设计采用了Master-Slave复制的数据备份方案，并没有采取如Cassandra或IMDG等对等分布式系统中常见的Slot粒度（或叫Partition/Bucket等）的自动冗余和指派。</p>
<p>这种设计虽然避免比较复杂的分布式技术，但也带来了一些问题：</p>
<p>Slave完全闲置：即便是读请求也不会被重定向到Slave结点上，Slave属于“冷备”<br>写压力无法分摊：Slave闲置导致的另一个问题就是写压力也都在Master上<br>6.2 客户端的挑战</p>
<p>由于Redis Cluster的设计，客户端要担负起一部分责任：</p>
<p>Cluster协议支持：不管Dummy还是Smart模式，都要具备解析Cluster协议的能力<br>网络开销：Dummy客户端不断重定向的网络开销<br>连接维护：Smart客户端对连接到集群中每个结点Socket的维护<br>缓存路由表：Smart客户端Slot路由表的缓存和更新<br>内存消耗：Smart客户端上述维护的信息都是有内存消耗的<br>MultiOp有限支持：对于MultiOp，由客户端通过KeyTag保证所有Key都在同一Slot。而即便如此，迁移时也会导致MultiOp失败。同理，对Pipeline和Transaction的支持也受限于必须操作同一Slot内的Key。<br>6.3 Redis实现问题</p>
<p>尽管属于无中心化架构一类的分布式系统，但不同产品的细节实现和代码质量还是有不少差异的，就比如Redis Cluster有些地方的设计看起来就有一些“奇葩”和简陋：</p>
<p>不能自动发现：无Auto Discovery功能。集群建立时以及运行中新增结点时，都要通过手动执行MEET命令或redis-trib.rb脚本添加到集群中<br>不能自动Resharding：不仅不自动，连Resharding算法都没有，要自己计算从哪些结点上迁移多少Slot，然后还是得通过redis-trib.rb操作<br>严重依赖外部redis-trib：如上所述，像集群健康状况检查、结点加入、Resharding等等功能全都抽离到一个Ruby脚本中了。还不清楚上面提到的缺失功能未来是要继续加到这个脚本里还是会集成到集群结点中？redis-trib也许要变成Codis中Dashboard的角色<br>无监控管理UI：即便未来加了UI，像迁移进度这种信息在无中心化设计中很难得到<br>只保证最终一致性：写Master成功后立即返回，如需强一致性，自行通过WAIT命令实现。但对于“脑裂”问题，目前Redis没提供网络恢复后的Merge功能，“脑裂”期间的更新可能丢失<br>6.4 性能损耗</p>
<p>由于之前手头没有空闲的物理机资源，所以只在虚拟机上做了简单的单机测试，在单独的一台压力机使用YCSB测试框架向虚拟机产生读写负载。虚拟机的配置为8核Intel Xeon CPU X5650@2.67GHz，16GB内存，分别搭建了4结点的单机版Redis和集群版Redis，测试一下Redis Cluster的性能损耗。由于不是最近做的测试，所以Jedis用的2.6.2版本。注：当然Redis Cluster可以通过多机部署获得水平扩展带来的性能提升，这里只是由于环境有限所以做的简单单机测试。</p>
<p>由于YCSB本身仅支持Redis单机版，所以需要我们自己增加扩展插件，具体方法请参照《YCSB性能测试工具使用》。通过YCSB产生2000w随机数据，Value大约100Byte左右。然后通过YCSB测试Read-Mostly(90% Read)和Read-Write-Mixed(50% Read)两种情况：</p>
<p>数据加载：吞吐量上有约18%的下降。<br>Read-Mostly：吞吐量上有约3.5%~7.9%的下降。<br>Read-Write-Mixed：吞吐量上有约3.3%~5.5%下降。<br>内存占用：Jedis客户端多占用380MB内存。<br>6.5 最后的总结</p>
<p>从现阶段看来，相比Sentinel或Codis等方案，Redis Cluster的优势还真是有限，个人觉得最大的优点有两个：</p>
<p>官方提供的Slot实现而不用像Codis那样去改源码了；<br>不用额外的Sentinel集群或类似的代码实现了。<br>同其他分布式系统，如Cassandra，或内存型的IMDG如Hazelcast和GridGain，除了性能方面外，从功能上Redis Cluster简直被爆得体无完肤… 看看我之前总结过的GridGain介绍《开源IMDG之GridGain》：</p>
<p>结点自动发现和Rebalance<br>分区粒度的备份<br>故障时分区角色自动调整<br>结果聚合（不会重定向客户端）<br>“脑裂”恢复后的Merge（Hazelcast支持多种合并策略）<br>多Primary分区写操作（见Replicated模式）<br>这些都是Redis Cluster没有或者要手动完成的。当然这也不足为奇，因为这与Redis的设计初衷有关，毕竟作者都已经说了，最核心的设计目标就是性能、水平伸缩和可用性。</p>
<p>从Redis Cluster的环境搭建使用到高级功能和内部原理剖析，再到应用案例收集和优缺点的分析罗列，讲了这么多，关于Redis集群到底如何，相信大家根据自己切身和项目的具体情况一定有了自己的结论。不管是评估测试也好，二次开发也好，还是直接上线使用也好，相信随着官方的不断迭代更新和大家的力量，Redis Cluster一定会逐渐完善成熟的！</p>
<p>顶<br>13</p>
<p>踩<br>0</p>
<p>上一篇操作系统内核Hack：(一)实验环境搭建<br>下一篇Redis Cluster架构优化<br>我的同类文章<br>Redis（13）<br>•Redis Cluster架构优化2015-09-25阅读11969<br>•Redis监控工具,命令和调优2015-08-16阅读15729<br>•豌豆夹Redis解决方案Codis安装使用2015-07-25阅读17653<br>•用Netty解析Redis网络协议2015-06-19阅读4886<br>•Redis源码学习：Lua脚本2015-05-22阅读2327<br>•Jedis分片Sentinel连接池实验2015-08-29阅读6353<br>•豌豆夹Redis解决方案Codis源码剖析：Dashboard2015-08-08阅读4675<br>•豌豆夹Redis解决方案Codis源码剖析：Proxy代理2015-07-03阅读8979<br>•Redis源码学习：字符串2015-05-30阅读1772<br>•Redis集群功能预览2015-02-28阅读4059<br>更多文章<br>参考知识库<br>img<br>Python知识库<br>22194关注|1364收录<br>img<br>C++知识库<br>9249关注|1393收录<br>img<br>Redis知识库<br>5139关注|738收录<br>img<br>软件测试知识库<br>4272关注|318收录<br>img<br>MySQL知识库<br>21472关注|1448收录<br>img<br>算法与数据结构知识库<br>15138关注|2320收录<br>img<br>大型网站架构知识库<br>8321关注|708收录<br>猜你在找</p>
]]></content>
    
    <summary type="html">
    
      全面剖析Redis Cluster原理和应用
    
    </summary>
    
      <category term="redis" scheme="http://jishusuishouji.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="http://jishusuishouji.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate缓存 查询缓存</title>
    <link href="http://jishusuishouji.github.io/2017/03/30/hibernate/Hibernate%E7%BC%93%E5%AD%98_%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/"/>
    <id>http://jishusuishouji.github.io/2017/03/30/hibernate/Hibernate缓存_查询缓存/</id>
    <published>2017-03-30T05:58:14.000Z</published>
    <updated>2017-03-30T05:59:23.196Z</updated>
    
    <content type="html"><![CDATA[<p>网上说<code>query.setCacheable(true)</code>或<code>criteria.setCacheable(true)`` 这两种方式的缓存命中率低，个人认为谈论这个“无卵用”；
我在测试的时候发现，上面的操作会受配置的限制，必须在配置文件中打开</code>hibernate.cache.use_query_cache=true<code>，之后</code>setCacheable`才起作用；</p>
<p>查询缓存可以解决二级缓存的不足；它的作用范围也是<code>SessionFactory</code>；</p>
<p>可以缓存hql语句查询，也可以缓存query和criteria查询；</p>
<p>下面针对query和criteria进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 对查询缓存测试 &lt;br&gt;</div><div class="line"> * 1. 只有B处起作用，作用于session; &lt;br&gt;</div><div class="line"> * 2. 配置文件中打开query_cache的前提下，setCacheable 是起作用的</div><div class="line"> */</div><div class="line">@Test</div><div class="line">public void testCriteriaInCache() &#123;</div><div class="line"> System.out.println(&quot;=============&quot;);</div><div class="line"> Session session = hibernateTemplate.getSessionFactory().openSession();</div><div class="line"> Criteria criteria = session.createCriteria(UserModel.class);</div><div class="line"> criteria.setCacheable(true); // 这里仅对B处起作用</div><div class="line"> criteria.add(Restrictions.eq(&quot;name&quot;, &quot;Sucre&quot;));</div><div class="line"> System.out.println(&quot;=============A&quot; + criteria.list());</div><div class="line"> System.out.println(&quot;=============B&quot; + criteria.list()); // B</div><div class="line"> criteria.add(Restrictions.eq(&quot;id&quot;, 1));</div><div class="line"> System.out.println(&quot;=============C&quot; + criteria.list());</div><div class="line"> criteria = session.createCriteria(UserModel.class);</div><div class="line"> criteria.setCacheable(true);</div><div class="line"> criteria.add(Restrictions.eq(&quot;id&quot;, 1));</div><div class="line"> System.out.println(&quot;=============D&quot; + criteria.list());</div><div class="line"> session = hibernateTemplate.getSessionFactory().openSession();</div><div class="line"> criteria = session.createCriteria(UserModel.class);</div><div class="line"> criteria.setCacheable(true);</div><div class="line"> criteria.add(Restrictions.eq(&quot;id&quot;, 1));</div><div class="line"> System.out.println(&quot;=============E&quot; + criteria.list());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * 测试查询缓存 &lt;br&gt;</div><div class="line"> * 1. BC两处都是使用的A产生的缓存，作用于SessionFactory &lt;br&gt;</div><div class="line"> * 2. 配置文件中打开query_cache的前提下，setCacheable 是起作用的</div><div class="line"> */</div><div class="line">@Test</div><div class="line">public void testQueryInCache() &#123;</div><div class="line"> System.out.println(&quot;=============&quot;);</div><div class="line"> Session session = hibernateTemplate.getSessionFactory().openSession();</div><div class="line"> Query query = session</div><div class="line">   .createQuery(&quot;select u.name from UserModel as u where u.id=?&quot;);</div><div class="line"> query.setParameter(0, 1);</div><div class="line"> query.setCacheable(true);</div><div class="line"> String name = (String) query.list().get(0);</div><div class="line"> System.out.println(&quot;=============A&quot; + name); // A</div><div class="line"> query = session</div><div class="line">   .createQuery(&quot;select u.name from UserModel as u where u.id=?&quot;);</div><div class="line"> query.setParameter(0, 1);</div><div class="line"> query.setCacheable(true);</div><div class="line"> name = (String) query.list().get(0);</div><div class="line"> System.out.println(&quot;=============B&quot; + name); // B</div><div class="line"> session = hibernateTemplate.getSessionFactory().openSession();</div><div class="line"> query = session</div><div class="line">   .createQuery(&quot;select u.name from UserModel as u where u.id=?&quot;);</div><div class="line"> query.setParameter(0, 1);</div><div class="line"> query.setCacheable(true);</div><div class="line"> name = (String) query.list().get(0);</div><div class="line"> System.out.println(&quot;=============C&quot; + name); // C</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      Hibernate缓存 查询缓存
    
    </summary>
    
      <category term="hibernate" scheme="http://jishusuishouji.github.io/categories/hibernate/"/>
    
    
      <category term="hibernate" scheme="http://jishusuishouji.github.io/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>hibernate的查询缓存</title>
    <link href="http://jishusuishouji.github.io/2017/03/30/hibernate/hibernate%E7%9A%84%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98/"/>
    <id>http://jishusuishouji.github.io/2017/03/30/hibernate/hibernate的查询缓存/</id>
    <published>2017-03-30T05:47:52.000Z</published>
    <updated>2017-03-30T05:56:50.612Z</updated>
    
    <content type="html"><![CDATA[<p>hibernate的查询缓存主要是针对普通属性结果集的缓存，而对于实体对象的结果集只缓存id。在一级缓存,二级缓存和查询缓存都打开的情况下做查询操作时这样的：查询普通属性，会先到查询缓存中取，如果没有，则查询数据库；查询实体，会先到查询缓存中取id，如果有，则根据id到缓存(一级/二级)中取实体，如果缓存中取不到实体，再查询数据库。<br> 和一级/二级缓存不同，查询缓存的生命周期是不确定的，当前关联的表发生改变时，查询缓存的生命周期结束。<br><a id="more"></a><br>查询缓存的配置和使用也是很简单的：<br>1&gt;查询缓存的启用不但要在配置文件中进行配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;property name=&quot;hibernate.cache.use_query_cache&quot;&gt;true&lt;/property&gt;</div></pre></td></tr></table></figure></p>
<p>2&gt;还要在程序中显示的进行启用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">query.setCacheable(true);</div></pre></td></tr></table></figure></p>
<p>1&gt;查询缓存的启用不但要在配置文件中进行配置 ——-换成spring配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;propertyConfigurer&quot; class=&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;&gt;</div><div class="line">    &lt;property name=&quot;locations&quot;&gt;</div><div class="line">        &lt;list&gt;</div><div class="line">            &lt;value&gt;/WEB-INF/config/jdbc.properties&lt;/value&gt;</div><div class="line">        &lt;/list&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;</div><div class="line">    &lt;property name=&quot;driverClass&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot; /&gt;</div><div class="line">    &lt;property name=&quot;jdbcUrl&quot; value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;</div><div class="line">    &lt;property name=&quot;user&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;</div><div class="line">    &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;</div><div class="line">    &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;true&quot;/&gt;</div><div class="line">    &lt;property name=&quot;checkoutTimeout&quot; value=&quot;$&#123;cpool.checkoutTimeout&#125;&quot;/&gt;</div><div class="line">    &lt;property name=&quot;initialPoolSize&quot; value=&quot;$&#123;cpool.minPoolSize&#125;&quot;/&gt;</div><div class="line">    &lt;property name=&quot;minPoolSize&quot; value=&quot;$&#123;cpool.minPoolSize&#125;&quot;/&gt;</div><div class="line">    &lt;property name=&quot;maxPoolSize&quot; value=&quot;$&#123;cpool.maxPoolSize&#125;&quot;/&gt;</div><div class="line">    &lt;property name=&quot;maxIdleTime&quot; value=&quot;$&#123;cpool.maxIdleTime&#125;&quot;/&gt;</div><div class="line">    &lt;property name=&quot;acquireIncrement&quot; value=&quot;$&#123;cpool.acquireIncrement&#125;&quot;/&gt;</div><div class="line">    &lt;property name=&quot;maxIdleTimeExcessConnections&quot; value=&quot;$&#123;cpool.maxIdleTimeExcessConnections&#125;&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div><div class="line">&lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;</div><div class="line">    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;    </div><div class="line">    &lt;property name=&quot;mappingLocations&quot;&gt;</div><div class="line">        &lt;list&gt;</div><div class="line">            &lt;value&gt;classpath*:/com/jeecms/core/entity/hbm/*.hbm.xml&lt;/value&gt;</div><div class="line">            &lt;value&gt;classpath*:/com/jeecms/cms/entity/main/hbm/*.hbm.xml&lt;/value&gt;</div><div class="line">            &lt;value&gt;classpath*:/com/jeecms/cms/entity/assist/hbm/*.hbm.xml&lt;/value&gt;</div><div class="line">        &lt;/list&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property name=&quot;hibernateProperties&quot;&gt;</div><div class="line">        &lt;value&gt;</div><div class="line">        hibernate.dialect=org.hibernate.dialect.MySQLInnoDBDialect</div><div class="line">        hibernate.show_sql=false</div><div class="line">        hibernate.format_sql=false</div><div class="line">        hibernate.query.substitutions=true 1, false 0</div><div class="line">        hibernate.jdbc.batch_size=20</div><div class="line">        //查询缓存配置</div><div class="line">        hibernate.cache.use_query_cache=true</div><div class="line">        &lt;/value&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property name=&quot;entityInterceptor&quot;&gt;   </div><div class="line">        &lt;ref local=&quot;treeInterceptor&quot;/&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property name=&quot;cacheProvider&quot;&gt;</div><div class="line">        &lt;ref local=&quot;cacheProvider&quot;/&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">    &lt;property name=&quot;lobHandler&quot;&gt;</div><div class="line">        &lt;ref bean=&quot;lobHandler&quot; /&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>2&gt;还要在程序中显示的进行启用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public List&lt;CmsSite&gt; getList(boolean cacheable) &#123;</div><div class="line">        String hql = &quot;from CmsSite bean order by bean.id asc&quot;;</div><div class="line">        return getSession().createQuery(hql).setCacheable(cacheable).list();</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<h2 id="1-实体类："><a href="#1-实体类：" class="headerlink" title="1.实体类："></a>1.实体类：</h2><pre><code>public class Student { 
  private Integer id; 
  private String name; 
  //一系列的setter.getter方法 
}
</code></pre><p>##2.映射文件</p>
<p>Student.hbm.xml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;class name=&quot;com.sxt.hibernate.cache.entity.Student&quot; table=&quot;sxt_hibernate_student&quot;&gt; </div><div class="line">       </div><div class="line">  &lt;!-- 指定本类的对象使用二级缓存(这也可以放在hibernate.cfg.xml中统一指定) --&gt; </div><div class="line">  &lt;!-- </div><div class="line">  &lt;cache usage=&quot;read-only&quot;/&gt; </div><div class="line">   --&gt; </div><div class="line">  &lt;id name=&quot;id&quot; length=&quot;4&quot;&gt; </div><div class="line">    &lt;generator class=&quot;native&quot;&gt;&lt;/generator&gt; </div><div class="line">  &lt;/id&gt; </div><div class="line">  &lt;property name=&quot;name&quot; length=&quot;10&quot;&gt;&lt;/property&gt; </div><div class="line">&lt;/class&gt;</div></pre></td></tr></table></figure></p>
<h2 id="3-hibernate配置文件："><a href="#3-hibernate配置文件：" class="headerlink" title="3.hibernate配置文件："></a>3.hibernate配置文件：</h2><p>hibernate.cfg.xml</p>
<pre><code>&lt;hibernate-configuration&gt; 
  &lt;session-factory&gt; 
    &lt;property name=&quot;hibernate.connection.url&quot;&gt;jdbc:oracle:thin:@localhost:1521:ORCL10&lt;/property&gt;
    &lt;property name=&quot;hibernate.connection.driver_class&quot;&gt;oracle.jdbc.driver.OracleDriver&lt;/property&gt; 
    &lt;property name=&quot;hibernate.connection.username&quot;&gt;scott&lt;/property&gt; 
    &lt;property name=&quot;hibernate.connection.password&quot;&gt;yf123&lt;/property&gt; 
    &lt;property name=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.Oracle9Dialect&lt;/property&gt; 
    &lt;property name=&quot;hibernate.show_sql&quot;&gt;true&lt;/property&gt; 

    &lt;!-- 开启二级缓存,其实hibernate默认就是开启的,这里显示的指定一下 --&gt; 
    &lt;property name=&quot;hibernate.cache.use_second_level_cache&quot;&gt;true&lt;/property&gt; 
    &lt;!-- 指定二级缓存产品的提供商 --&gt; 
    &lt;property name=&quot;hibernate.cache.provider_class&quot;&gt;org.hibernate.cache.EhCacheProvider&lt;/property&gt; 

    &lt;!-- 启用查询缓存 --&gt; 
    &lt;property name=&quot;hibernate.cache.use_query_cache&quot;&gt;true&lt;/property&gt; 

    &lt;mapping resource=&quot;com/sxt/hibernate/cache/entity/Student.hbm.xml&quot;/&gt; 

    &lt;!-- 指定那些类使用二级缓存 --&gt; 
    &lt;class-cache usage=&quot;read-only&quot; class=&quot;com.sxt.hibernate.cache.entity.Student&quot;/&gt; 
  &lt;/session-factory&gt; 
&lt;/hibernate-configuration&gt;
</code></pre><h2 id="4-测试方法："><a href="#4-测试方法：" class="headerlink" title="4.测试方法："></a>4.测试方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">public static void main(String[] args) &#123; </div><div class="line">  Session session = null; </div><div class="line">  Transaction t = null; </div><div class="line"></div><div class="line">  *//** </div><div class="line">   * 开启查询缓存,关闭二级缓存, 开启一个session,分别调用query.list </div><div class="line">   */ </div><div class="line">//如果不用查询缓存的话,那两个都发出查询语句,这也是默认的情况. </div><div class="line">/* </div><div class="line">  try &#123; </div><div class="line">    session = HibernateUtils.getSession(); </div><div class="line">    t = session.beginTransaction(); </div><div class="line">    Query query = session.createQuery(&quot;select s.name from Student s&quot;); </div><div class="line">    //启用查询缓存    </div><div class="line">    query.setCacheable(true); </div><div class="line">    List&lt;String&gt; names = query.list(); </div><div class="line">    for (Iterator&lt;String&gt; it = names.iterator(); it.hasNext();) &#123; </div><div class="line">      String name = it.next(); </div><div class="line">      System.out.println(name); </div><div class="line">    &#125; </div><div class="line">    System.out.println(&quot;================================&quot;); </div><div class="line">    query = session.createQuery(&quot;select s.name from Student s&quot;); </div><div class="line">    //启用查询缓存 </div><div class="line">    query.setCacheable(true); </div><div class="line">    //没有发出查询语句,因为这里使用的查询缓存 </div><div class="line">    names = query.list(); </div><div class="line">    for (Iterator&lt;String&gt; it = names.iterator(); it.hasNext();) &#123; </div><div class="line">      String name = it.next(); </div><div class="line">      System.out.println(name); </div><div class="line">    &#125; </div><div class="line">    t.commit(); </div><div class="line">  &#125; catch (Exception e) &#123; </div><div class="line">    e.printStackTrace(); </div><div class="line">    t.rollback(); </div><div class="line">  &#125; finally &#123; </div><div class="line">    HibernateUtils.closeSession(session); </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">@SuppressWarnings(&quot;unchecked&quot;) </div><div class="line">public static void main(String[] args) &#123; </div><div class="line">  Session session = null; </div><div class="line">  Transaction t = null; </div><div class="line"></div><div class="line">  *//** </div><div class="line">   * 开启查询缓存,关闭二级缓存, 开启两个session,分别调用query.list </div><div class="line">   *//* </div><div class="line">  //如果不用查询缓存的话,那两个都发出查询语句,这也是默认的情况. </div><div class="line">  try &#123; </div><div class="line">    session = HibernateUtils.getSession(); </div><div class="line">    t = session.beginTransaction(); </div><div class="line">    Query query = session.createQuery(&quot;select s.name from Student s&quot;); </div><div class="line">    //启用查询缓存    </div><div class="line">    //query.setCacheable(true); </div><div class="line">    List&lt;String&gt; names = query.list(); </div><div class="line">    for (Iterator&lt;String&gt; it = names.iterator(); it.hasNext();) &#123; </div><div class="line">      String name = it.next(); </div><div class="line">      System.out.println(name); </div><div class="line">    &#125; </div><div class="line"></div><div class="line">    t.commit(); </div><div class="line">  &#125; catch (Exception e) &#123; </div><div class="line">    e.printStackTrace(); </div><div class="line">    t.rollback(); </div><div class="line">  &#125; finally &#123; </div><div class="line">    HibernateUtils.closeSession(session); </div><div class="line">  &#125; </div><div class="line">   </div><div class="line">  System.out.println(&quot;================================&quot;); </div><div class="line">   </div><div class="line">  try &#123; </div><div class="line">    session = HibernateUtils.getSession(); </div><div class="line">    t = session.beginTransaction(); </div><div class="line">    Query query = session.createQuery(&quot;select s.name from Student s&quot;); </div><div class="line">    //启用查询缓存    </div><div class="line">    //query.setCacheable(true); </div><div class="line">    //不会发出查询语句,因为查询缓存和session无关. </div><div class="line">    List&lt;String&gt; names = query.list(); </div><div class="line">    for (Iterator&lt;String&gt; it = names.iterator(); it.hasNext();) &#123; </div><div class="line">      String name = it.next(); </div><div class="line">      System.out.println(name); </div><div class="line">    &#125; </div><div class="line">    t.commit(); </div><div class="line">  &#125; catch (Exception e) &#123; </div><div class="line">    e.printStackTrace(); </div><div class="line">    t.rollback(); </div><div class="line">  &#125; finally &#123; </div><div class="line">    HibernateUtils.closeSession(session); </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">@SuppressWarnings(&quot;unchecked&quot;) </div><div class="line">public static void main(String[] args) &#123; </div><div class="line">  Session session = null; </div><div class="line">  Transaction t = null; </div><div class="line"></div><div class="line">  *//** </div><div class="line">   * 开启查询缓存,关闭二级缓存, 开启两个session,分别调用query.iterate </div><div class="line">   *//* </div><div class="line">  //如果不用查询缓存的话,那两个都发出查询语句,这也是默认的情况. </div><div class="line">  try &#123; </div><div class="line">    session = HibernateUtils.getSession(); </div><div class="line">    t = session.beginTransaction(); </div><div class="line">    Query query = session.createQuery(&quot;select s.name from Student s&quot;); </div><div class="line">    //启用查询缓存    </div><div class="line">    query.setCacheable(true); </div><div class="line">    for (Iterator&lt;String&gt; it = query.iterate(); it.hasNext();) &#123; </div><div class="line">      String name = it.next(); </div><div class="line">      System.out.println(name); </div><div class="line">    &#125; </div><div class="line">    t.commit(); </div><div class="line">  &#125; catch (Exception e) &#123; </div><div class="line">    e.printStackTrace(); </div><div class="line">    t.rollback(); </div><div class="line">  &#125; finally &#123; </div><div class="line">    HibernateUtils.closeSession(session); </div><div class="line">  &#125; </div><div class="line">   </div><div class="line">  System.out.println(&quot;================================&quot;); </div><div class="line">   </div><div class="line">  try &#123; </div><div class="line">    session = HibernateUtils.getSession(); </div><div class="line">    t = session.beginTransaction(); </div><div class="line">    Query query = session.createQuery(&quot;select s.name from Student s&quot;); </div><div class="line">    //启用查询缓存    </div><div class="line">    query.setCacheable(true); </div><div class="line">    //会发出查询语句,因为query.iterate不使用查询缓存 </div><div class="line">    for (Iterator&lt;String&gt; it = query.iterate(); it.hasNext();) &#123; </div><div class="line">      String name = it.next(); </div><div class="line">      System.out.println(name); </div><div class="line">    &#125; </div><div class="line">    t.commit(); </div><div class="line">  &#125; catch (Exception e) &#123; </div><div class="line">    e.printStackTrace(); </div><div class="line">    t.rollback(); </div><div class="line">  &#125; finally &#123; </div><div class="line">    HibernateUtils.closeSession(session); </div><div class="line">  &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>```<br>  @SuppressWarnings(“unchecked”)<br>  public static void main(String[] args) {<br>    Session session = null;<br>    Transaction t = null; </p>
<pre><code>*//** 
 * 关闭查询缓存,关闭二级缓存, 开启两个session,分别调用query.list查询实体对象 
 *//* 
//如果不用查询缓存的话,那两个都发出查询语句,这也是默认的情况. 
try { 
  session = HibernateUtils.getSession(); 
  t = session.beginTransaction(); 
  Query query = session.createQuery(&quot;select s from Student s&quot;); 
  //启用查询缓存    
  //query.setCacheable(true); 
  List&lt;Student&gt; students = query.list(); 
  for (Iterator&lt;Student&gt; it = students.iterator(); it.hasNext();) { 
    Student s = it.next(); 
    System.out.println(s.getName()); 
  } 
  t.commit(); 
} catch (Exception e) { 
  e.printStackTrace(); 
  t.rollback(); 
} finally { 
  HibernateUtils.closeSession(session); 
} 

System.out.println(&quot;================================&quot;); 

try { 
  session = HibernateUtils.getSession(); 
  t = session.beginTransaction(); 
  Query query = session.createQuery(&quot;select s from Student s&quot;); 
  //启用查询缓存    
  //query.setCacheable(true); 
  //会发出查询语句,因为list默认每次都会发出sql语句 
  List&lt;Student&gt; students = query.list(); 
  for (Iterator&lt;Student&gt; it = students.iterator(); it.hasNext();) { 
    Student s = it.next(); 
    System.out.println(s.getName()); 
  } 
  t.commit(); 
} catch (Exception e) { 
  e.printStackTrace(); 
  t.rollback(); 
} finally { 
  HibernateUtils.closeSession(session); 
} 
</code></pre><p>  }*/ </p>
<p>/*  @SuppressWarnings(“unchecked”)<br>  public static void main(String[] args) {<br>    Session session = null;<br>    Transaction t = null; </p>
<pre><code>*//** 
 * 开启查询缓存,关闭二级缓存, 开启两个session,分别调用query.list查询实体对象 
 *//* 
//如果不用查询缓存的话,那两个都发出查询语句,这也是默认的情况. 
try { 
  session = HibernateUtils.getSession(); 
  t = session.beginTransaction(); 
  Query query = session.createQuery(&quot;select s from Student s&quot;); 
  //启用查询缓存    
  query.setCacheable(true); 
  List&lt;Student&gt; students = query.list(); 
  for (Iterator&lt;Student&gt; it = students.iterator(); it.hasNext();) { 
    Student s = it.next(); 
    System.out.println(s.getName()); 
  } 
  t.commit(); 
} catch (Exception e) { 
  e.printStackTrace(); 
  t.rollback(); 
} finally { 
  HibernateUtils.closeSession(session); 
} 

System.out.println(&quot;================================&quot;); 

try { 
  session = HibernateUtils.getSession(); 
  t = session.beginTransaction(); 
  Query query = session.createQuery(&quot;select s from Student s&quot;); 
  //启用查询缓存    
  query.setCacheable(true); 
  //会发出根据id查询实体的n条查询语句,因为这种情况下,查询过程是这样的： 
  // 在第一次执行list时,会把查询对象的id缓存到查询缓存里 
  // 第二次执行list时, 会遍历查询缓存里的id到缓存里去找实体对象,由于这里没找到实体对象, 
  //所以就发出n条查询语句到数据库中查询. 
  List&lt;Student&gt; students = query.list(); 
  for (Iterator&lt;Student&gt; it = students.iterator(); it.hasNext();) { 
    Student s = it.next(); 
    System.out.println(s.getName()); 
  } 
  t.commit(); 
} catch (Exception e) { 
  e.printStackTrace(); 
  t.rollback(); 
} finally { 
  HibernateUtils.closeSession(session); 
} 
</code></pre><p>  }*/ </p>
<p>  @SuppressWarnings(“unchecked”)<br>  public static void main(String[] args) {<br>    Session session = null;<br>    Transaction t = null; </p>
<pre><code>/** 
 * 开启查询缓存,开启二级缓存, 开启两个session,分别调用query.list查询实体对象 
 */ 
//如果不用查询缓存的话,那两个都发出查询语句,这也是默认的情况. 
try { 
  session = HibernateUtils.getSession(); 
  t = session.beginTransaction(); 
  Query query = session.createQuery(&quot;select s from Student s&quot;); 
  //启用查询缓存    
  query.setCacheable(true); 
  List&lt;Student&gt; students = query.list(); 
  for (Iterator&lt;Student&gt; it = students.iterator(); it.hasNext();) { 
    Student s = it.next(); 
    System.out.println(s.getName()); 
  } 
  t.commit(); 
} catch (Exception e) { 
  e.printStackTrace(); 
  t.rollback(); 
} finally { 
  HibernateUtils.closeSession(session); 
} 

System.out.println(&quot;================================&quot;); 

try { 
  session = HibernateUtils.getSession(); 
  t = session.beginTransaction(); 
  Query query = session.createQuery(&quot;select s from Student s&quot;); 
  //启用查询缓存    
  query.setCacheable(true); 
  //不会发出查询语句,因为这种情况下,查询过程是这样的： 
  // 在第一次执行list时,会把查询对象的id缓存到查询缓存里 
  // 第二次执行list时, 会遍历查询缓存里的id到缓存里去找实体对象,由于这里开启了二级缓存,可以找到目标实体对象, 
  //所以就不会再发出n条查询语句. 
  List&lt;Student&gt; students = query.list(); 
  for (Iterator&lt;Student&gt; it = students.iterator(); it.hasNext();) { 
    Student s = it.next(); 
    System.out.println(s.getName()); 
  } 
  t.commit(); 
} catch (Exception e) { 
  e.printStackTrace(); 
  t.rollback(); 
} finally { 
  HibernateUtils.closeSession(session); 
} 
</code></pre><p>  }</p>
]]></content>
    
    <summary type="html">
    
      hibernate的查询缓存
    
    </summary>
    
      <category term="hibernate" scheme="http://jishusuishouji.github.io/categories/hibernate/"/>
    
    
      <category term="hibernate" scheme="http://jishusuishouji.github.io/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Layout of Log4j</title>
    <link href="http://jishusuishouji.github.io/2017/03/28/Log4j/Layout_of_Log4j/"/>
    <id>http://jishusuishouji.github.io/2017/03/28/Log4j/Layout_of_Log4j/</id>
    <published>2017-03-28T07:02:00.000Z</published>
    <updated>2017-03-28T07:03:46.667Z</updated>
    
    <content type="html"><![CDATA[<p>本文档使用Log4j版本为1.2.17</p>
<h2 id="1-Layout介绍"><a href="#1-Layout介绍" class="headerlink" title="1. Layout介绍"></a>1. Layout介绍</h2><p>Log4j Layout主要用来控制日志的序列化格式，比如时间、线程号、日志消息对齐方式等，是log4j体系结构中的核心组成部分之一。</p>
<p>Layout抽象类声明为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public abstract class Layout implements OptionHandler</div></pre></td></tr></table></figure></p>
<p><code>Layout</code>实现了<code>OptionHandler</code>接口，<code>OptionHandler</code>仅包含一个方法<code>activateOptions()</code>。对实现了<code>OptionHandler</code>接口的模块，调用属性<code>setter</code>方法后，log4j的配置器类会调用此模块的<code>activateOptions</code>实现以激活配置。<code>OptionHandler</code>存在的原因是有些属性彼此依赖，在它们在全部加载完成之前是无法激活的，这个方法用于在模块变为激活和就绪之前用来执行任何必要任务的机制。比如：</p>
<p>某模块有字符串属性fileName属性，表示log4j用户配置的写出日志文件名，使用前需要创建File对象获取文件写出IO流，具体则是由activateOptions完成文件的打开等，具体可见log4j的FileAppender实现中对文件名和文件IO的操作。</p>
<p>Layout类的方法或接口如下，abstract修饰的需要具体子类实现:</p>
<p>//abstract修饰需要具体子类实现，将日志事件渲染为待打印的日志文本字符串，可写出到Appender<br>abstract  public  String format(LoggingEvent event )<br>//format函数返回的格式化文本类型，默认返回为”text/plain”<br>public String getContentType()<br>//针对HTMLLayout类的格式化输出，html字符串的头部，默认null<br>public String getHeader()<br>//针对HTMLLayout类的格式化输出，html字符串的尾部，默认null<br>public String getFooter()<br>//对于LayoutEvent中异常的处理模式，true表示忽略异常，异常会到达Appender，由Appender负责渲染为打印持久化字符串信息；false表示由Layout负责渲染异常信息。SimpleLayout、TTCCLayout、PatternLayout实现返回true;XMLLayout实现返回false，由Appender处理渲染异常消息。<br>abstract public boolean ignoresThrowable()<br>Layout是对序列化每一次LoggingEvent的抽象，核心是format方法，format作为抽象方法，由具体子类实现具体的序列化方式。具体子类有：</p>
<p>SimpleLayout<br>TTCCLayout<br>PatternLayout<br>XMLLayout<br>HTMLLayout<br>DateLayout<br>Layout继承体系</p>
<ol>
<li>XMLLayout</li>
</ol>
<p>XMLLayout实现了根据log4j.dtd序列化输出xml格式的日志文本，默认的log4j.dtd文件在/org/apache/log4j/xml/log4j.dtd目录下，注意，XMLLayout打印输出的并非完整XML文件，并不包括&lt;?xml version=”1.0” ?&gt;等XML头部，XMLLayout的目的是输出XML的部分片段，应用可将此片段整合嵌入到其它XML文件中。XMLLayout有成员属性：<br>locationInfo表示是否打印位置信息，即日志事件发生的代码文件名、日志记录点代码行号等信息，log4j配置文件中需要配置为LocationInfo<br>properties表示是否打印MDC中的Key-Value信息，默认为false，log4j配置文件中需要配置为Properties</p>
<p>注意：log4j的各个模块涉及的成员属性时，如果属性有set方法，一般表示此属性可通过log4j.properties进行配置，具体配置属性值为属性的setXXX方法去掉set前缀。</p>
<p>示例如上面的locationInfo和properties配置:</p>
<p>log4j.appender.Console.layout.LocationInfo=true<br>log4j.appender.Console.layout.Properties=true</p>
<p>XMLLayout继承自Layout的方法实现有：</p>
<p>//配置激活的接口实现，来自于OptionHandler interface，方法体为空<br>public void activateOptions()<br>//返回false，表示XMLLayout自己处理异常信息<br>public boolean ignoresThrowable()<br>public String format( final LoggingEvent event)<br>2.1 format实现</p>
<p>format按照日志message、NDC、getThrowableStrRep、日志位置信息、MDC的顺序，并按照XML格式序列化LoggingEvent。log4j实现时使用StringBuffer避免字符串拼接的开销（JAVA中String是不可变类），具体使用时设置了StringBuffer的默认长度即DEFAULT_SIZE = 256，最大长度UPPER_LIMIT = 2048。每次format函数调用时，如果当前StringBuffer容量未超过上限，则复用已有的StringBuffer并清空已有内容；如果当前StringBuffer容量超过UPPER_LIMIT上限，则创建一个新的StringBuffer将当前LoggingEvent 序列化到其中，目的是尽量减少内存的占用量。</p>
<p>if(buf.capacity() &gt; UPPER_LIMIT) {<br>  buf = new StringBuffer(DEFAULT_SIZE);<br>} else {<br>  buf.setLength(0);<br>}<br>xml序列化中，对于属性如 timestamp=”1452874282177” level=“INFO”，为了保持生成的文本符合XML语法，需要对特殊字符进行转义处理。对于属性使用org.apache.log4j.helpers.Transform.escapeTags做转义。对于文本子元素如 <log4j:message>&lt;![CDATA[123]]&gt;</log4j:message>，使用org.apache.log4j.helpers.Transform.appendEscapingCDATA做转义，将message放在 &lt;![CDATA[ 和 ]] 之间，避免文本破坏XML语法。</p>
<p>处理的XML特殊字符有（简单字符串替换）:</p>
<blockquote>
<p>-&gt; &gt;<br>&lt; -&gt; &lt;<br>&amp; -&gt; &amp;<br>“ -&gt; &quot;<br>2.2 demo</p>
</blockquote>
<p>demo java code:</p>
<p>Logger logger = Logger.getLogger(LayoutTest.class);<br>NDC.push(“ndc message”);<br>logger.info(“info:123”);<br>logger.warn(“warn:abc”);<br>logger.info(“exception”, new RuntimeException(“run time exception”));<br>demo log4j config:</p>
<p>log4j.rootLogger=INFO,Console<br>log4j.appender.Console=org.apache.log4j.ConsoleAppender<br>log4j.appender.Console.target=System.out<br>log4j.appender.Console.layout=org.apache.log4j.xml.XMLLayout<br>log4j.appender.Console.layout.LocationInfo=true<br>log4j.appender.Console.layout.Properties=true</p>
<p>demo 日志输出:</p>
<p><log4j:event logger="com.luohw.log4j.LayoutTest" timestamp="1459227960659" level="INFO" thread="main"></log4j:event></p>
<p><log4j:message>&lt;![CDATA[info:123]]&gt;</log4j:message></p>
<p><log4j:ndc>&lt;![CDATA[ndc message]]&gt;</log4j:ndc></p>
<p><log4j:locationinfo class="com.luohw.log4j.LayoutTest" method="test" file="LayoutTest.java" line="13"><br></log4j:locationinfo></p>
<p><log4j:event logger="com.luohw.log4j.LayoutTest" timestamp="1459227960670" level="WARN" thread="main"></log4j:event></p>
<p><log4j:message>&lt;![CDATA[warn:abc]]&gt;</log4j:message></p>
<p><log4j:ndc>&lt;![CDATA[ndc message]]&gt;</log4j:ndc></p>
<p><log4j:locationinfo class="com.luohw.log4j.LayoutTest" method="test" file="LayoutTest.java" line="14"><br></log4j:locationinfo></p>
<p><log4j:event logger="com.luohw.log4j.LayoutTest" timestamp="1459227960670" level="ERROR" thread="main"></log4j:event></p>
<p><log4j:message>&lt;![CDATA[error:xyz]]&gt;</log4j:message></p>
<p><log4j:ndc>&lt;![CDATA[ndc message]]&gt;</log4j:ndc></p>
<p><log4j:locationinfo class="com.luohw.log4j.LayoutTest" method="test" file="LayoutTest.java" line="15"><br></log4j:locationinfo></p>
<p><log4j:event logger="com.luohw.log4j.LayoutTest" timestamp="1459227960671" level="INFO" thread="main"></log4j:event></p>
<p><log4j:message>&lt;![CDATA[exception]]&gt;</log4j:message></p>
<p><log4j:ndc>&lt;![CDATA[ndc message]]&gt;</log4j:ndc></p>
<p><log4j:throwable>&lt;![CDATA[java.lang.RuntimeException: run time exception<br>at com.luohw.log4j.LayoutTest.test(LayoutTest.java:16)<br>at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)<br>at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)<br>… …<br>at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)<br>at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)<br>]]&gt;</log4j:throwable></p>
<p><log4j:locationinfo class="com.luohw.log4j.LayoutTest" method="test" file="LayoutTest.java" line="16"><br></log4j:locationinfo></p>
<ol>
<li>HTMLLayout</li>
</ol>
<p>HTMLLayout用于将每次的LoggingEvent序列化为HTML格式字符串，具体的内容组织为html的表格。生成的HTML文本为完整的一份HTML格式代码（不同于XMLLayout的部分片段），包含html、head、body、具体table信息等。一份HTML日志文档可以包含多条LoggingEvent序列化输出，但header和footer只会输出一次（具体是有Appender打开和关闭相关流时输出）。</p>
<p>注意：如果有Appender使用HTMLLayout，需要设置Appender的字符编码为UTF-8 或者 UTF-16，否则非ASCII字符会产生乱码。</p>
<p>locationInfo表示是否打印位置信息，即日志事件发生的代码文件名、代码行号，log4j配置文件中需要配置为LocationInfo</p>
<p>title输出html文档head的title部分，默认为Log4J Log Messages，log4j配置文件中需要配置为Title</p>
<p>XMLLayout继承自Layout的方法实现有：</p>
<p>//默认返回”text/html”<br>public String getContentType()<br>//配置加载完成后操作，实现为空<br>public void activateOptions()<br>//返回相应HTML头部部分，具体是html、head、title以及body、table的开始部分<br>public String getHeader()<br>//返回相应html尾部，具体是table、body、html的html闭合标签<br>public String getFooter()<br>//返回false，即由HTMLLayout本身处理异常信息格式化，HTMLLayout有成员函数appendThrowableAsHTML，具体是将Throwable对应的字符串做相关转移和替换处理，以符合html语法<br>public boolean ignoresThrowable()<br>//具体序列化LoggingEvent为字符串<br>public String format(LoggingEvent event)<br>3.1 format实现</p>
<p>a.  缓冲StringBuffer更新，判断容量是否超过HTMLLayout的MAX_CAPACITY(1024)，如果超过则创建新的StringBuffer，否则复用原有的StringBuffer，避免内存浪费，具体和XMLLayout原理一致。<br>b.  输出时间、线程、Level等上下文信息，根据locationInfo（如果locationInfo为true）、Level等具体字符串拼接和格式化</p>
<tr><br><td>0</td><br><td title="main thread">main</td><br><td title="Level">INFO</td><br><td title="com.luohw.log4j.LayoutTest category">com.luohw.log4j.LayoutTest</td><br><td>LayoutTest.java:12</td><br><td title="Message">info:123</td><br></tr>

<p>c. 输出NDC信息</p>
<tr><td bgcolor="#EEEEEE" style="font-size : xx-small;" colspan="6" title="Nested Diagnostic Context">NDC: ndc message</td></tr>

<p>d. 如果有则输出异常栈信息，一般Logger的日志函数info、warn、error等都有带Throwable型参的重载<br>e. 没有MDC相关信息的格式化输出</p>
<p>3.2 demo</p>
<p>demo java code:</p>
<p>Logger logger = Logger.getLogger(LayoutTest.class);<br>NDC.push(“ndc message”);<br>logger.info(“info:123”);<br>logger.warn(“warn:abc”);<br>logger.error(“error:xyz”);<br>logger.info(“exception”, new RuntimeException(“run time exception”));<br>demo log4j config:</p>
<p>log4j.rootLogger=INFO,Console<br>log4j.appender.Console=org.apache.log4j.ConsoleAppender<br>log4j.appender.Console.target=System.out<br>log4j.appender.Console.layout=org.apache.log4j.HTMLLayout<br>log4j.appender.Console.layout.LocationInfo=true<br>log4j.appender.Console.layout.Title=luohw@log4j</p>
<p>demo浏览器打开日志输出html:</p>
<p>html</p>
<p>see more …</p>
]]></content>
    
    <summary type="html">
    
      Layout of Log4j
    
    </summary>
    
      <category term="Log4j" scheme="http://jishusuishouji.github.io/categories/Log4j/"/>
    
    
      <category term="Log4j" scheme="http://jishusuishouji.github.io/tags/Log4j/"/>
    
  </entry>
  
</feed>
