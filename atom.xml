<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术随手记</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jishusuishouji.github.io/"/>
  <updated>2017-05-09T16:52:44.634Z</updated>
  <id>http://jishusuishouji.github.io/</id>
  
  <author>
    <name>技术随手记</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java的类加载机制</title>
    <link href="http://jishusuishouji.github.io/2017/05/10/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.md/Java%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://jishusuishouji.github.io/2017/05/10/Java的类加载机制.md/Java的类加载机制/</id>
    <published>2017-05-09T16:52:35.000Z</published>
    <updated>2017-05-09T16:52:44.634Z</updated>
    
    <summary type="html">
    
      Java的类加载机制
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机：Java类加载机制</title>
    <link href="http://jishusuishouji.github.io/2017/05/09/java/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9AJava%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://jishusuishouji.github.io/2017/05/09/java/Java虚拟机：Java类加载机制/</id>
    <published>2017-05-09T14:57:56.000Z</published>
    <updated>2017-05-09T16:03:43.800Z</updated>
    
    <content type="html"><![CDATA[<p>源代码(<code>.java</code>)会被编译为class文件(<code>.class</code>文件)，<code>.class</code>文件描述了类的各种信息，<code>.class</code>文件需要加载到虚拟机之后才能运行和使用。</p>
<h2 id="类加载使用的7个阶段"><a href="#类加载使用的7个阶段" class="headerlink" title="类加载使用的7个阶段"></a>类加载使用的7个阶段</h2><p>类从加载到虚拟机到到卸载出内存，整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initiallization）、使用（Using）和卸载（Unloading）这7个阶段。<br><img src="/img/类加载使用的7个阶段.png" alt="类加载使用的7个阶段"><br>其中验证、准备、解析这个三个阶段统称为连接（Linking）<br>加载、验证、准备、初始化、卸载这五个阶段的顺序是确定的，而解析阶段不一定：它在某些情况下可以初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定）。<br>加载、验证、准备、解析、初始化五个阶段组成了一个完整的类加载过程。<br>卸载属于GC的工作。</p>
<h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><h4 id="有两种时机会触发类加载："><a href="#有两种时机会触发类加载：" class="headerlink" title="有两种时机会触发类加载："></a>有两种时机会触发类加载：</h4><p>1、预加载。虚拟机启动时加载，加载的是<code>JAVA_HOME/lib/</code>下的<code>rt.jar</code>中的<code>.class</code>文件，由于<code>rt.jar</code>包中的类经常被使用，因此随着虚拟机启动一起被加载。</p>
<h5 id="验证rt-java包中的类是否在虚拟器启动的时候被加载"><a href="#验证rt-java包中的类是否在虚拟器启动的时候被加载" class="headerlink" title="验证rt.java包中的类是否在虚拟器启动的时候被加载"></a>验证<code>rt.java</code>包中的类是否在虚拟器启动的时候被加载</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;</div><div class="line">    public static void main(String[] args) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译运行该类:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&gt;javac Test.java</div><div class="line">&gt;java -XX:+TraceClassLoading Test</div><div class="line">[Opened C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.Object from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.io.Serializable from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.Comparable from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.CharSequence from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.String from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.reflect.AnnotatedElement from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.reflect.GenericDeclaration from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.reflect.Type from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.Class from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.Cloneable from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">[Loaded java.lang.ClassLoader from C:\Program Files\Java\jdk1.8.0_111\jre\lib\rt.jar]</div><div class="line">...</div></pre></td></tr></table></figure></p>
<p>2、运行时加载。虚拟机在用到一个<code>.class</code>文件的时会先去内存中查看一下这个<code>.class</code>文件有没有被加载，如果没有就会按照类的全限定名来加载这个类。</p>
<h4 id="加载阶段做的事情"><a href="#加载阶段做的事情" class="headerlink" title="加载阶段做的事情"></a>加载阶段做的事情</h4><p>1、获取.class文件的二进制流<br>2、将<code>.class</code>文件中包含的类信息、静态变量、字节码、常量等内容放入方法区中<br>3、在内存中生成一个代表这个<code>.class</code>文件的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口。一般这个Class是在堆里的，不过HotSpot虚拟机是放在方法区中的。</p>
<p>虚拟机规范对这三点并没有做详细的规定，因此虚拟机实现的灵活度是相当大的。<br>加载阶段对于开发者来说是可控性最强的一个阶段。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>连接阶段的第一步，主要是为了确保<code>.class</code>文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p>
<p><code>.class</code>文件不一定要从Java源码编译而来，可以使用任何途径产生，甚至包括用十六进制编辑器直接编写来产生<code>.class</code>文件。虚拟机如果不检查输入的字节流，对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。</p>
<h4 id="验证阶段主要包含以下几个工作："><a href="#验证阶段主要包含以下几个工作：" class="headerlink" title="验证阶段主要包含以下几个工作："></a>验证阶段主要包含以下几个工作：</h4><p>1、文件格式验证<br><code>.class</code>文件的第5~第8个字节表示的是该<code>.class</code>文件的主次版本号，验证的时候会对这4个字节做一个验证，高版本的JDK能向下兼容以前版本的<code>.class</code>文件，但不能运行以后的class文件，即使文件格式未发生任何变化，虚拟机也必须拒绝执行超过其版本号的<code>.class</code>文件。例如有一段java代码是JDK1.6编译的，那么JDK1.6、JDK1.7能运行编译出来<code>.class</code>文件，而JDK1.5、JDK1.4以及更低的JDK版本是无法运行这个<code>.class</code>文件的。如果运行，会抛出<code>java.lang.UnsupportedClassVersionError</code>。</p>
<p>2、元数据验证</p>
<p>3、字节码验证</p>
<p>4、符号引用验证</p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置其初始值的阶段，这些变量所使用的内存都将在方法区中分配。<br>1、这时候进行内存分配的仅仅是类变量（被<code>static</code>修饰的变量），而不是实例变量，实例变量将会在对象实例化的时候随着对象一起分配在Java堆中<br>2、这个阶段赋初始值的变量指的是那些不被<code>final</code>修饰的<code>static</code>变量，比如<code>public static int value = 123;</code>，<code>value</code>在准备阶段过后是<code>0</code>而不是<code>123</code>，给<code>value</code>赋值为<code>123</code>的动作是在初始化阶段才进行的；而<code>public static final int value = 123;</code>,在准备阶段，虚拟机就会给<code>value</code>赋值为<code>123</code>。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段是类加载过程的最后一步，初始化阶段是真正执行类中定义的Java字节码的过程。初始化过程是一个执行类构造器<code>&lt;clinit&gt;()</code>方法的过程，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。初始化阶段做的事就是给<code>static</code>变量赋予用户指定的值以及执行静态代码块。</p>
<p>注意一下，虚拟机会保证类的初始化在多线程环境中被正确地加锁、同步，即如果多个线程同时去初始化一个类，那么只会有一个类去执行这个类的<code>&lt;clinit&gt;()</code>方法，其他线程都要阻塞等待，直至活动线程执行<code>&lt;clinit&gt;()</code>方法完毕。因此如果在一个类的<code>&lt;clinit&gt;()</code>方法中有耗时很长的操作，就可能造成多个进程阻塞。不过其他线程虽然会阻塞，但是执行<code>&lt;clinit&gt;()</code>方法的那条线程退出<code>&lt;clinit&gt;()</code>方法后，其他线程不会再次进入<code>&lt;clinit&gt;()</code>方法了，因为同一个类加载器下，一个类只会初始化一次。实际应用中这种阻塞往往是比较隐蔽的，要小心。</p>
<p>Java虚拟机规范严格规定了有且只有5种场景必须立即对类进行初始化，这4种场景也称为对一个类进行主动引用：</p>
<p>1、使用<code>new</code>关键字实例化对象、读取或者设置一个类的静态字段（被<code>final</code>修饰的静态字段除外）、调用一个类的静态方法的时候<br>2、使用<code>java.lang.reflect</code>包中的方法对类进行反射调用的时候<br>3、初始化一个类，发现其父类还没有初始化过的时候<br>4、虚拟机启动的时候，虚拟机会先初始化用户指定的包含<code>main()</code>方法的那个类</p>
<p>除了上面4种场景外，所有引用类的方式都不会触发类的初始化，称为被动引用：</p>
<p>1、子类引用父类静态字段，不会导致子类初始化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class SuperClass &#123;</div><div class="line">    public static String value = &quot;value&quot;;</div><div class="line">    static &#123;</div><div class="line">        System.out.println(&quot;SuperClass init&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class SubClass extends SuperClass &#123;</div><div class="line">    static &#123;</div><div class="line">        System.out.println(&quot;SubClass init&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class TestMain &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(SubClass.value);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SuperClass init</div><div class="line">value</div></pre></td></tr></table></figure></p>
<p>2、通过数组定义引用类，不会触发此类的初始化<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class TestMain &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        SuperClass[] scs = new SuperClass[10];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行之后没有任何输出</p>
<p>3、引用静态常量时，常量在编译阶段会存入类的常量池中，本质上并没有直接引用到定义常量的类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Constant &#123;</div><div class="line">    public static final String CONSTANT = &quot;CONSTANT&quot;;</div><div class="line"></div><div class="line">    static &#123;</div><div class="line">        System.out.println(&quot;Constant init&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class TestMain &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        System.out.println(Constant.CONSTANT);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">CONSTANT</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      Java虚拟机：Java类加载机制
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>如何配置Policy文件进行Java安全策略的设置</title>
    <link href="http://jishusuishouji.github.io/2017/05/09/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEPolicy%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8CJava%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BE%E7%BD%AE.md/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEPolicy%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8CJava%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BE%E7%BD%AE/"/>
    <id>http://jishusuishouji.github.io/2017/05/09/如何配置Policy文件进行Java安全策略的设置.md/如何配置Policy文件进行Java安全策略的设置/</id>
    <published>2017-05-08T19:08:09.000Z</published>
    <updated>2017-05-08T19:52:26.021Z</updated>
    
    <content type="html"><![CDATA[<p>Java语言具有完善的安全框架，从编程语言、编译器、解释程序到Java虚拟机，都能确保Java系统不被恶意的代码或敌对的编译器暗中破坏，它们能够保证Java代码按预定的规则运作。但是如果需要逾越这些限制时，比如读写文件，监听和读写Socket，退出Java系统，就必须使用数字签名或安全策略文件（<code>*.Policy</code>）。 </p>
<p> 在企业内部网中，推荐使用安全策略文件来设置java程序权限。企业内部网中各台计算机的位置、用途和安全性明确，更适于使用安全策略文件来设置java的权限，软件的安装、设置、升级和迁移都非常的方便，并且还可以和数字签名配合使用，更重要的是可以细分每个java程序的权限，使用起来灵活方便。 </p>
<h2 id="Java中安全策略的概念"><a href="#Java中安全策略的概念" class="headerlink" title="Java中安全策略的概念"></a>Java中安全策略的概念</h2><p> Java安全策略详细说明了不同的代码所拥有的不同资源的许可，由一个<code>Policy</code>对象来表达。比如为了让applet（或者运行在<code>SecurityManager</code>下的应用程序）能够执行受保护的行为，例如读写文件，applet（或Java应用程序）必须获得那项操作的许可,安全策略文件可以配置这些许可。<br>在程序中可以通过调用<code>getPolicy</code>方法得到当前安装的<code>Policy</code>对象，也可以通过调用<code>setPolicy</code>方法改变。<code>Policy</code>对象评估整个策略，返回一个适当的<code>Permissions</code>对象，详细说明那些代码可以访问那些资源。 </p>
<p>策略文件可以储存在无格式的ASCII文件，或<code>Policy</code>类的二进制文件，或数据库中。本文仅讨论无格式的ASCII文件的形式。 </p>
<h2 id="Policy文件的格式"><a href="#Policy文件的格式" class="headerlink" title="Policy文件的格式"></a><code>Policy</code>文件的格式</h2><p>\jdk1.8.0_111\jre\lib\security\java.policy<br>\jdk1.8.0_111\jre\lib\security\java.security</p>
<h3 id="Policy文件的语法格式与说明"><a href="#Policy文件的语法格式与说明" class="headerlink" title="Policy文件的语法格式与说明"></a><code>Policy</code>文件的语法格式与说明</h3><p><code>Policy</code>文件实质上是一个记录列表，它可能含有一个“keystore”记录，以及含有零个或多个“<code>grant</code>”记录。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">keystore &quot;some_keystore_url&quot;, &quot;keystore_type&quot;;</div><div class="line"></div><div class="line">grant [SignedBy &quot;signer_names&quot;] [, CodeBase &quot;URL&quot;] &#123;</div><div class="line">    Permission permission_class_name [ &quot;target_name&quot; ] [, &quot;action&quot;] [, SignedBy &quot;signer_names&quot;];</div><div class="line">    Permission ...</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="keystore记录"><a href="#keystore记录" class="headerlink" title="keystore记录"></a><code>keystore</code>记录</h4><p><code>keystore</code>是一个私有密钥（private keys）数据库和相应的数字签名，例如X.509证书。Policy文件中可能只有一条keystore记录（也可能不含有该记录），它可以出现在文件中<code>grant</code>记录以外的任何地方。Policy配置文件中指定的keystores用于寻找grant记录中指定的、签名者的公共密钥（public keys），如果任何grant记录指定签名者（signer_names），那么，keystore记录必须出现在policy配置文件中。 </p>
<p>—- “some_keystore_url”是指keystore的URL位置，”keystore_type”是指keystore的类型。第二个选项是可选项，如果没有指定，该类型则假定由安全属性文件（java.security）中的”keystore.type”属性来确定。keystore类型定义了keystore信息的存储和数据格式，用于保护keystore中的私有密钥和keystore完整性的算法。Sun Microsystems支持的缺省类型为“JKS”。 </p>
<h4 id="grant记录"><a href="#grant记录" class="headerlink" title="grant记录"></a><code>grant</code>记录</h4><p>在`Policy文件中的每一个grant记录含有一个CodeSource（一个指定的代码）及其permission(许可)。 </p>
<p>Policy文件中的每一条grant记录遵循下面的格式，以保留字“grant”开头，表示一条新的记录的开始，“Permission”是另一个保留字，在记录中用来标记一个新的许可的开始。每一个grant记录授予一个指定的代码（CodeBase）一套许可（Permissions）。 </p>
<p><code>permission_class_name</code>必须是一个合格并存在的类名，例如<code>java.io.FilePermission</code>，不能使用缩写（例如<code>FilePermission</code>）。<br>target_name用来指定目标类的位置，action用于指定目标类拥有的权限。<br>target_name可以直接指定类名（可以是绝对或相对路径），目录名，也可以是下面的通配符： </p>
<p>directory/<em> 目录下的所有文件
</em>当前目录的所有文件<br>directory/-目录下的所有文件，包括子目录</p>
<ul>
<li>当前目录下的所有文件，包括子目录<br>《ALL FILES》文件系统中的所有文件<br>对于java.io.FilePermission，action可以是：<br>read, write, delete和execute。<br>对于java.net.SocketPermission，action可以是：<br>listen，accept，connect，read，write。</li>
</ul>
<p>—- 1.3 Policy文件中的属性扩展（Property Expansion）<br>—- 属性扩展与shell中使用的变量扩展类似，它的格式为： </p>
<p>“${some.property}”<br>实际使用的例子为：<br>permission java.io.FilePermission<br>“${user.home}”, “read”;<br>“${user.home}”的值为”d:\Project”，<br>因此，下面的语句和上面的语句是一样的：<br>permission java.io.FilePermission “<br>d:\Project “, “read”;</p>
<p>三. 实例<br>—- 当初始化Policy时，首先装载系统Policy，然后再增加用户Policy，如果两者都不存在，则使用缺省的Policy，即原始的沙箱模型。<br>—- 系统Policy文件的缺省位置为： </p>
<p>{java.home}/lib/security/java.policy (Solaris)<br>{java.home}\lib\security\java.policy (Windows)<br>用户Policy文件的缺省位置为：<br>{user.home}/.java.policy (Solaris)<br>{user.home}.java.policy (Windows)</p>
<p>—- 其实，在实际使用中，我们可能不会象上面介绍的那么复杂，特别是在不使用数字签名时。这时，我们完全可以借鉴JDK 1.2提供给我们的现成的\jdk1.2\jre\lib\security\java.policy文件，根据我们的需要作相应的修改，本文就针对不使用数字签名情况详细说明安全策略文件的用法。<br>—- 下面，是一个完整的在Windows 95/98/NT下使用的.java.policy文件。在文件中，分别使用注释的形式说明了每个“permission”记录的用途。 </p>
<p>// For LanServerTalk.java and LanClientTalk.java</p>
<p>grant {<br>//对系统和用户目录“读”的权限<br>permission java.util.PropertyPermission<br>“user.dir”, “read”;<br>permission java.util.PropertyPermission<br>“user.home”, “read”;<br>permission java.util.PropertyPermission<br>“java.home”, “read”;<br>permission java.util.PropertyPermission<br>“java.class.path”, “read”;<br>permission java.util.PropertyPermission<br>“user.name”, “read”; </p>
<p>//对线程和线程组的操作权限<br>permission java.lang.RuntimePermission<br>“modifyThread”;<br>permission java.lang.RuntimePermission<br>“modifyThreadGroup”;</p>
<p>//操作Socket端口的各种权限<br>permission java.net.SocketPermission<br>“-“, “listen”;<br>permission java.net.SocketPermission<br>“-“, “accept”;<br>permission java.net.SocketPermission<br>“-“, “connect”;<br>permission java.net.SocketPermission “-“, “read”;<br>permission java.net.SocketPermission “-“, “write”;</p>
<p>//读写文件的权限<br>permission java.io.FilePermission “-“, “read”;<br>permission java.io.FilePermission “-“, “write”;</p>
<p>//退出系统的权限，例如System.exit(0)<br>permission java.lang.RuntimePermission “exitVM”;<br>};</p>
<p>四. java.policy文件的使用<br>—- 对于windows 95/98/NT，使用.java.policy文件的方法主要有下面两种。<br>—- 1． 使用缺省目录 </p>
<p>—- 我们可以简单地将编辑好的.java.policy文件拷贝到windows 95/98/NT的HOME目录，这时，所有的applet(或Java应用程序)可能都拥有某些相同的权限，使用起来简单，但不灵活（例如：对于java.io.FilePermission ，其目标类的target_name必须使用绝对路径），如果不是在企业内部网中使用，还可能存在一定安全隐患。 </p>
<p>—- 2． 在命令行中指定 </p>
<p>—- 在命令行，如果我们希望传递一个Policy文件给appletviewer，还可以使用”-J-Djava.security.policy”参数来指定policy的位置： </p>
<p>appletviewer -J-Djava.security.<br>policy=pURL myApplet</p>
<p>—- pURL为Policy文件的位置。下面，是一个实际的例子，以当前目录的.java.policy文件所指定的安全策略运行当前目录的LanServerTalk.html（文件中装载并运行LanServerTalk.java）：<br>appletviewer -J-Djava.security.policy<br>=.java.policy LanServerTalk.html </p>
<p>—- 这种方法使用灵活，特别是作为一个软件包在企业内部网中发布时，安装、设置和迁移软件，基本无须修改Policy文件的内容，使用起来相当简单，而且，安全许可的范围控制较精细。</p>
<hr>
<p>缺省策略实现和策略文件语法<br>上次修改时间： 1998 年 10 月 30 日</p>
<p>Java 应用程序环境的策略（对不同来源的代码指定权限）由 Policy 对象来表示。更明确地说，就是由 Policy 类（包含在 java.security 包中）的实现抽象方法的 Policy 子类来表示。</p>
<p>Policy 对象所用策略信息的源位置由 Policy 实现决定。缺省 Policy 实现从静态策略配置文件获得自己的信息。本文档的其余部分叙述了缺省 Policy 实现及其所读取的策略文件中必须使用的语法。有关使用 Policy Tool 来创建策略文件（不必知道所需语法）的详细信息，请参阅《策略工具文档》 (for Solaris) (for Windows)。</p>
<p>以下是本文档其余部分的概要：</p>
<p>缺省 Policy 实现<br>缺省策略文件位置<br>更改 Policy 实现<br>策略文件语法<br>策略文件示例<br>策略文件中的属性扩展<br>相关文档</p>
<p>缺省 Policy 实现<br>在缺省 Policy 实现中，可在一个或多个策略配置文件中指定策略。配置文件的作用是指定特定代码源的代码所能获得的权限。</p>
<p>可利用简单的文本编辑器或 Policy Tool 实用程序来编写策略文件。</p>
<p>缺省情况下，系统上只有单个全系统策略文件和唯一的（可选）用户策略文件。</p>
<p>首次调用缺省 Policy 对象的 getPermissions 方法或在任何时候调用 Policy 对象 refresh 方法时，即对其进行初始化。初始化包括分析策略配置文件（请参阅策略文件语法）及组装 Policy 对象。</p>
<p>缺省策略文件位置<br>如前所述，系统在缺省情况下具有单个全系统策略文件和唯一的用户策略文件。</p>
<p>系统策略文件的缺省位置为：</p>
<p>java.home/lib/security/java.policy  (Solaris)<br>java.home\lib\security\java.policy  (Windows)<br>注意： java.home 指的是名为“java.home”的系统属性的值，它指定 JDK 的安装目录。</p>
<p>系统策略文件可用于授予全系统代码权限。与 JDK 一起安装的 java.policy 文件可向标准扩展 (Java standard extensions) 授予全部权限，允许任何用户在无特权要求的端口进行监听，同时允许任何代码读取某些对安全不敏感的“标准”属性（例如“os.name”和“file.separator”属性）。</p>
<p>用户策略文件的缺省位置为：</p>
<p>user.home/.java.policy  (Solaris)<br>user.home.java.policy  (Windows)<br>注意： user.home 指的是名为“user.home”的系统属性的值，它指定用户的主目录。在 Windows 系统中，假定用户名是 uName，“user.home”属性的缺省值为：</p>
<p>C:\Winnt\Profiles\uName（多用户 Windows NT 系统中）<br>C:\Windows\Profiles\uName（多用户 Windows 95 系统中）<br>C:\Windows（单用户 Windows 95 系统中）<br>初始化 Policy 时，将首先加载系统策略，然后在 Policy 中添加用户策略。如果两种策略均不存在，则采用内置策略。该内置策略与原始的沙箱策略相同。</p>
<p>策略文件的位置在安全属性文件中指定。安全属性文件的位置为：</p>
<p>java.home/lib/security/java.security  (Solaris)<br>java.home\lib\security\java.security  (Windows)<br>如上所述，java.home 指示 JDK 的安装目录。策略文件的位置被指定为其名称具有以下形式的属性的值：</p>
<p>policy.url.n<br>其中 n 为数字。应采用以下形式的语句行来指定每个属性值：</p>
<p>policy.url.n=URL<br>其中，URL 为 URL 规范。</p>
<p>例如，安全属性文件中将把缺省系统和用户策略文件定义为：</p>
<p>policy.url.1=file:${java.home}/lib/security/java.policy<br>policy.url.2=file:${user.home}/.java.policy<br>有关利用特殊语法（例如利用 ${java.home} 来指定 java.home 属性值）来指定属性值的详细信息，请参阅属性扩展。</p>
<p>实际上，用户可以指定多个 URL（包括“<a href="http://”形式的" target="_blank" rel="external">http://”形式的</a> URL）,从而加载所有指定的策略文件。也可注释掉或更改第二个 URL，从而禁止读取缺省用户策略文件。</p>
<p>该算法自 policy.url.1 开始，然后不断递增直到查不到 URL 为止。因此，如果有了 policy.url.1 和 policy.url.3，就不会读取 policy.url.3。</p>
<p>运行时指定其它策略文件</p>
<p>在执行应用程序时也可以指定附加的或不同的策略文件，方法是用“-Djava.security.policy”命令行参数来指定（该命令行参数设置 java.security.policy 属性值）。例如，如果使用</p>
<pre><code>java -Djava.security.manager -Djava.security.policy=someURL SomeApp
</code></pre><p>这里 someURL 是指定策略文件位置的 URL，则除了加载安全属性文件中指定的所有策略文件外，还会加载本方法所指定的策略文件。</p>
<p>注意：</p>
<p>URL 可以是任何标准 URL，也可以只是当前目录下策略文件的文件名，如下例所示：<br>    java -Djava.security.manager -Djava.security.policy=mypolicy WriteFile<br>“-Djava.security.manager”参数可确保缺省安全管理器已被安装，这样就容易对应用程序进行策略检查。如果应用程序 SomeApp 安装有安全管理器，则不需要该参数。<br>如果使用</p>
<pre><code>java -Djava.security.manager -Djava.security.policy==someURL SomeApp
</code></pre><p>（请注意双等号），就会仅使用指定的策略文件，而安全属性文件中指出的策略文件将被忽略。</p>
<p>如果要将策略文件传递给 appletviewer，就应使用参数“-J-Djava.security.policy”，如下所示：</p>
<pre><code>appletviewer -J-Djava.security.policy=someURL myApplet
</code></pre><p>请注意：如果将安全属性文件中的“policy.allowSystemProperty”属性设置为“false”，就会忽略“-Djava.security.policy”策略文件值（对于 java 和 appletviewer 命令）。缺省值为“true”。</p>
<p>更改 Policy 实现<br>可以用其它 policy 类来代替缺省 Policy 实现类，前提是前者属于抽象 Policy 类的子类并可实现 getPermissions 方法（及其它必要的方法）。</p>
<p>缺省 Policy 实现的更改可通过编辑安全属性文件来完成，其中安全属性文件指 JDK lib/security 目录中的 java.security 文件。</p>
<p>下面给出一种可在 java.security 中设置的属性类型的形式：</p>
<pre><code>policy.provider=PolicyClassName
</code></pre><p>PolicyClassName 必须指定所需 Policy 实现类的完整名称。该属性的缺省安全属性文件项如下所示：</p>
<pre><code>policy.provider=sun.security.provider.PolicyFile
</code></pre><p>要想自定义安全属性文件项，可通过更改属性值来指定另一个类，如下例所示：</p>
<p>   policy.provider=com.mycom.MyPolicy<br>策略文件语法<br>JDK 的策略配置文件可用于指定来自特定代码源的代码所能获得的权限（何种系统资源访问类型）。</p>
<p>为了使 applet（或在安全管理器下运行的应用程序）能够执行受保护的动作（例如读写文件），必须向 applet（或应用程序）授予进行该动作的权限。在缺省 Policy 实现中，必须由策略配置文件中的 grant 项授予该权限。有关详细信息，请参阅以下内容及 “Java 安全体系结构规范”（唯一的例外是：代码对位于与它自身同一 (URL) 位置并且对那一位置子目录下的文件总是自动拥有读权限，而无需授予明确的权限）。</p>
<p>策略配置文件主要包含授权项列表。其中可能包含“keystore”（密钥仓库）项及零个或多个“grant”（授权）项。</p>
<p>Keystore 项</p>
<p>keystore 是存放私钥及相关数字证书（例如验证对应的公钥的 X.509 证书链）的数据库。keytool 实用程序 (for Solaris) (for Windows) 用于创建和管理密钥仓库。策略配置文件中所指定的 keystore 用于查找在该文件的授权项中所指定的签名人公钥。如果某一授权项指定了签名人别名（请参阅以下内容），则在策略配置文件中必须含有 keystore 项。</p>
<p>目前，在策略文件中只能有一个 keystore 项（第一项后的其它 keystore 项将被忽略），且该项可位于文件授权项以外的任何位置。其语法如下所示：</p>
<pre><code>keystore &quot;some_keystore_url&quot;, &quot;keystore_type&quot;;
</code></pre><p>其中“some_keystore_url”指定密钥仓库的 URL 位置，而“keystore_type”指定密钥仓库的类型。</p>
<p>URL 是相对于策略文件位置而言。因此，如果在安全属性文件中按以下方式指定策略文件：</p>
<pre><code>policy.url.1=http://foo.bar.com/fum/some.policy
</code></pre><p>而且策略文件中含有以下项：</p>
<pre><code>keystore &quot;.keystore&quot;;
</code></pre><p>就会从下列位置加载密钥仓库：</p>
<pre><code>http://foo.bar.com/fum/.keystore
</code></pre><p>URL 也可以是绝对 URL。</p>
<p>keystore type 定义密钥仓库信息的存储和数据格式，同时也定义用于保护密钥仓库中私钥及密钥仓库自身完整性的算法。Sun Microsystems 所支持的缺省类型是名为“JKS”的专用密钥仓库类型。因此，如果密钥仓库类型属于“JKS”，就无需在 keystore 项中加以指定。</p>
<p>授权项</p>
<p>通常认为执行代码来自于某“代码源”（由 CodeSource 类型的对象表示）。代码源不仅包含代码的源位置 (URL)，而且还包括对包含与签写代码的私钥相对应的公钥的证书之引用。代码源中的证书通过用户密钥仓库中的符号别名引用。</p>
<p>每个授权项包括一个或多个“权限项”，前面为可选 codeBase 和 signedBy 名字/值对，用于指定要授予权限的代码。授权项的基本格式如下所示：</p>
<p>  grant signedBy “signer_names”, codeBase “URL” {<br>    permission permission_class_name “target_name”, “action”,<br>        signedBy “signer_names”;<br>    ….<br>    permission permission_class_name “target_name”, “action”,<br>        signedBy “signer_names”;<br>  };</p>
<p>以上所有非斜体的项必须按原样出现（尽管大小写无关紧要且部分为可选项，如下所示）。 斜体项代表变量值。</p>
<p>授权项必须以 grant 开头。</p>
<p>SignedBy 和 CodeBase 域</p>
<p>signedBy 和 codeBase 名字/值对为可选域，其间的顺序无关紧要。</p>
<p>signedBy 值表示存储在密钥仓库中的证书别名。该证书内的公钥用于验证代码上的数字签名；用户可以向由私钥（私钥对应于该别名所指定的 keystore 项中的公钥）签名的代码授予权限。</p>
<p>signedBy 的值可以是由逗号分隔的多个别名。 例如“Adam,Eve,Charles”，其含义为“Adam，Eve 和 Charles 签名”；它们之间的关系是 AND（与）而非 OR（或）。更确切地说，“Adam 签名的代码”语句的含义是“JAR 文件中有含类文件的代码，这个 JAR 文件已用密钥仓库中别名为 Adam 的项中与公钥所对应的私钥签名”。</p>
<p>signedBy 域可选，这是因为如果省略该域，则表示“任何签名人”。代码是否有签名或由谁签名都没有关系。</p>
<p>codeBase 值表示的是代码源位置；用户可向来自该位置的代码授权。空 codeBase 项表示“任何代码”；代码来源于何处没有关系。</p>
<p>注意： codeBase 值是 URL，因此应该始终用正斜杠（而不要用反斜杠）作为目录分隔符，即使代码源实际在 Windows 系统上。这样，如果 Windows 系统上代码的源位置实际上是 C:\somepath\api\，则 codeBase 策略项的外观将如下所示：</p>
<pre><code>grant codeBase &quot;file:/C:/somepath/api/&quot; {
  ...
}
</code></pre><p>codeBase</p>
<p>值的准确含义要取决于最后的字符。后面跟着“/”的 codeBase 将匹配指定目录下的所有类文件（非 JAR 文件）。后面跟着“/*”的 codeBase 将匹配该目录下的所有文件（类文件和 JAR 文件）。后面跟着“/-”的 codeBase 将匹配该目录下的所有文件（类文件和 JAR 文件）及该目录下子目录中的所有文件。下表说明了各种不同的情况。<br>下载代码的 Codebase URL  策略中的 Codebase URL   是否匹配?<br>java.sun.com/people/gong/   java.sun.com/people/gong<br>是</p>
<p>java.sun.com/people/gong/   java.sun.com/people/gong/<br>是</p>
<p>java.sun.com/people/gong/   java.sun.com/people/gong/*<br>是</p>
<p>java.sun.com/people/gong/   java.sun.com/people/gong/-<br>是</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/gong/<br>否</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/gong/-<br>是</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/gong/*<br>是</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/-<br>是</p>
<p>java.sun.com/people/gong/appl.jar   java.sun.com/people/*<br>否</p>
<p>java.sun.com/people/gong/   java.sun.com/people/-<br>是</p>
<p>java.sun.com/people/gong/   java.sun.com/people/*<br>否</p>
<p>权限项</p>
<p>权限项必须以 permission 开头。上述模板中的字 permission_class_name 的实际值可以是特定的权限类型（例如 java.io.FilePermission 或 java.lang.RuntimePermission）。</p>
<p>“action” 对于许多权限类型而言都是必需的，例如 java.io.FilePermission（指定允许何种类型的文件访问权限）。 对于诸如 java.lang.RuntimePermission 等权限类型则为可选项：既可以在 permission_class_name 之后的 “target_name” 值中指定权限，也可以不指定权限。</p>
<p>权限项的 signedBy 名字/值对为可选项。如果有名字/值对，则表示为已签名权限。意即必须由给定的别名对权限类签名，方可授予权限。例如，假定有以下授权项：</p>
<p>  grant {<br>    permission Foo “foobar”, signedBy “FooSoft”;<br>  }<br>如果将 Foo.class 权限放到 JAR 文件中，且该 JAR 文件已由与 “FooSoft” 别名所指定的证书中的公钥相对应的私钥签名，或在 Foo.class 是系统类（因为系统类不受策略限制）的情况下，即可授予 Foo 权限类型。</p>
<p>权限项中出现的项目必须按指定顺序出现（permission，permission_class_name，”target_name”，”action” 和 signedBy “signer_names”）。分号表示项终止。</p>
<p>大小写对于标识符（permission、signedBy、codeBase 等）来说并不重要，但对于 permission_class_name 或作为值传递过来的字符串而言就很重要了。</p>
<p>有关 Windows 系统上文件路径规范的注意事项</p>
<p>请注意：在指定 java.io.FilePermission 时，”target_name” 是文件路径。在 Windows 系统上，无论何时在字符串中（而不是在 codeBase URL 中）直接指定文件路径，路径中都需要两个反斜杠来代表一个实际的反斜杠，如下例所示：</p>
<p>  grant {<br>      permission java.io.FilePermission “C:\users\cathy\foo.bat”, “read”;<br>  };<br>原因在于：字符串是由符号处理器 (java.io.StreamTokenizer) 来处理的。符号处理器允许将“\”用作转义字符串（例如，“\n”表示换行），因此需要用两个反斜杠来表示一个反斜杠。符号处理器处理完以上文件路径字符串后，将把双反斜杠转换成单个反斜杠，其最终结果为：</p>
<pre><code>&quot;C:\users\cathy\foo.bat&quot;
</code></pre><p>策略文件示例<br>策略配置文件中两项的示例如下所示：</p>
<p>  // 如果代码由 “Duke” 签字，则向 /tmp 中的所有文件<br>  // 授予读/写访问权限：</p>
<p>  grant signedBy “Duke” {<br>    permission java.io.FilePermission “/tmp/*”, “read,write”;<br>  };<br>// 授予所有用户以下权限：</p>
<p>grant { permission java.util.PropertyPermission “java.vendor”; };</p>
<p>另一个示例策略配置文件如下所示。</p>
<p>  grant signedBy “sysadmin”, codeBase “file:/home/sysadmin/<em>“ {<br>    permission java.security.SecurityPermission “Security.insertProvider.</em>“;<br>    permission java.security.SecurityPermission “Security.removeProvider.<em>“;<br>    permission java.security.SecurityPermission “Security.setProperty.</em>“;<br>  };<br>本示例规定：只有满足以下条件的代码才能调用 Security 类中的方法以添加或删除提供者或者设置 Security 属性：</p>
<p>代码将从位于本地文件系统上“/home/sysadmin/”目录下的签名 JAR 文件中加载。<br>可以用密钥仓库中别名“sysadmin”所引用的公钥来校验签名。<br>可以忽略代码源中两个组件的任何一个（或两者）。下面是忽略 codeBase 的示例：</p>
<p>  grant signedBy “sysadmin” {<br>    permission java.security.SecurityPermission “Security.insertProvider.<em>“;<br>    permission java.security.SecurityPermission “Security.removeProvider.</em>“;<br>  };<br>如果该策略生效，则来自 JAR 文件（由 “sysadmin” 签名）的代码可以添加/删除提供者，而不管 JAR 文件来源于何处。</p>
<p>下面是没有签名人的示例：</p>
<p>  grant codeBase “file:/home/sysadmin/-“ {<br>    permission java.security.SecurityPermission “Security.insertProvider.<em>“;<br>    permission java.security.SecurityPermission “Security.removeProvider.</em>“;<br>  };<br>这里，来自本地文件系统“/home/sysadmin/”目录下任意位置的代码都可以添加/删除提供者。 该代码不必签名。</p>
<p>下面是既不含 codeBase 也不含 signedBy 的示例：</p>
<p>  grant {<br>    permission java.security.SecurityPermission “Security.insertProvider.<em>“;<br>    permission java.security.SecurityPermission “Security.removeProvider.</em>“;<br>  };<br>此处，由于两个代码源组件均被忽略，因此任何代码（不管来自于何处，是否已签名或由何人签名）都可添加/删除提供者。</p>
<p>策略文件中的属性扩展<br>策略文件和安全属性文件中可以进行属性扩展。</p>
<p>属性扩展类似于扩展 shell 中的变量。也就是说，当类似</p>
<pre><code>${some.property}
</code></pre><p>的字符串出现在策略文件或安全属性文件中时，它将被扩展为系统属性的值。 例如，</p>
<pre><code>permission java.io.FilePermission &quot;${user.home}&quot;, &quot;read&quot;;
</code></pre><p>将把 “${user.home}” 扩展为使用 “user.home” 系统属性的值。如果该属性的值是 “/home/cathy”，则以上示例等价于：</p>
<pre><code>permission java.io.FilePermission &quot;/home/cathy&quot;, &quot;read&quot;;
</code></pre><p>为了能在与平台无关的策略文件中使用，也可采用特殊记号 “${/}”。该记号是 “${file.separator}” 的简化表示。这种方式允许使用下列字符串：</p>
<pre><code>permission java.io.FilePermission &quot;${user.home}${/}*&quot;, &quot;read&quot;;
</code></pre><p>如果 “user.home” 属性的值是 /home/cathy，而且是在 Solaris 系统上，则以上字符串将转换为：</p>
<pre><code>permission java.io.FilePermission &quot;/home/cathy/*&quot;, &quot;read&quot;;
</code></pre><p>如果 “user.home” 值是 C:\users\cathy，而且是在 Windows 系统上，则以上字符串将转换为：</p>
<pre><code>permission java.io.FilePermission &quot;C:\users\cathy\*&quot;, &quot;read&quot;;
</code></pre><p>同样，作为一种特例，如果扩展 codebase 中的属性，例如</p>
<pre><code>grant codeBase &quot;file:${java.home}/lib/ext/&quot;
</code></pre><p>则任何文件分隔符都将自动转换为“/”。这样，在 Windows 系统上，以上字符串将转换为：</p>
<pre><code>grant codeBase &quot;file:C:/jdk1.2/lib/ext/&quot;
</code></pre><p>即使 “java.home” 被设置为 C:\jdk1.2。因此，用户就不必也不应该在 codeBase 字符串中使用 ${/}。</p>
<p>策略文件中允许使用双引号字符串的地方都可进行属性扩展。其中包括 “signer_names”、”URL”、”target_name” 和 “action” 域。</p>
<p>是否允许属性扩展由安全属性文件中的“policy.expandProperties”属性控制。如果该属性为真（缺省值），则允许扩展。</p>
<p>请注意：不能使用嵌套属性；嵌套属性将无效。 例如，</p>
<pre><code>&quot;${user.${foo}}&quot;
</code></pre><p>是无效的，即使将“foo”属性设置为“home”。原因在于属性解析程序不能识别嵌套属性；解析程序只是简单地搜索第一个“${”，然后继续搜索直到找到第一个“}”为止，同时试图将搜索结果（这里是 “${user.$foo}”）解释为属性。如果没有这种属性，则解析程序就会发生解释失败。</p>
<p>也请注意：如果在 grant 项、permission 项或 keystore 项中无法扩展某个属性，则该项将被忽略。例如，如果在没有定义系统属性“foo”的情况下使用语句：</p>
<pre><code>grant codeBase &quot;${foo}&quot; {
  permission ...;
  permission ...;
};
</code></pre><p>则该 grant 项中的所有权限都将被忽略。如果使用语句：</p>
<pre><code>grant {
  permission Foo &quot;${foo}&quot;;
  permission Bar;
};
</code></pre><p>则将仅忽略“permission Foo…”项。最后，如果使用语句：</p>
<pre><code>keystore &quot;${foo}&quot;;
</code></pre><p>则将忽略 keystore 项。</p>
<p>Windows 系统、文件路径和属性的扩展</p>
<p>如上所述，在 Windows 系统上，当直接在字符串中（而不是在 codeBase URL 中）指定文件路径时，用户需要用两个反斜杠来代表文件路径中一个实际的反斜杠，如下例所示：</p>
<pre><code>grant {
    permission java.io.FilePermission &quot;C:\\users\\cathy\\foo.bat&quot;, &quot;read&quot;;
};
</code></pre><p>原因在于：字符串是由符号处理器 (java.io.StreamTokenizer) 来处理的。符号处理器允许将“\”用作转义字符串（例如，“\n”表示换行），因此需要用两个反斜杠来表示一个反斜杠。符号处理器处理完以上文件路径字符串后，将把双反斜杠转换成单个反斜杠，其最终结果为：</p>
<pre><code>&quot;C:\users\cathy\foo.bat&quot;
</code></pre><p>符号处理器处理完字符串后，即进行字符串中的属性扩展。因此，如果使用字符串：</p>
<pre><code>&quot;${user.home}\\foo.bat&quot;
</code></pre><p>则符号处理器首先处理字符串，即将双反斜杠转换成单个反斜杠，其结果为：</p>
<pre><code>&quot;${user.home}\foo.bat&quot;
</code></pre><p>随即扩展 ${user.home} 属性，其最终结果为：</p>
<pre><code>&quot;C:\users\cathy\foo.bat&quot;
</code></pre><p>以上假定 “user.home” 的值是 C:\users\cathy。当然，为实现与平台无关，最好在开始指定字符串时不要显式带上斜杠，即可以用 ${/} 属性来代替，如下例所示：</p>
<pre><code>&quot;${user.home}${/}foo.bat&quot;
</code></pre>]]></content>
    
    <summary type="html">
    
      如何配置Policy文件进行Java安全策略的设置
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java安全管理器SecurityManager</title>
    <link href="http://jishusuishouji.github.io/2017/05/09/java%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E5%99%A8SecurityManager.md/java%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E5%99%A8SecurityManager/"/>
    <id>http://jishusuishouji.github.io/2017/05/09/java安全管理器SecurityManager.md/java安全管理器SecurityManager/</id>
    <published>2017-05-08T16:33:39.000Z</published>
    <updated>2017-05-08T19:53:02.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h2><h3 id="阅读源码中关于SecurityManager的代码"><a href="#阅读源码中关于SecurityManager的代码" class="headerlink" title="阅读源码中关于SecurityManager的代码"></a>阅读源码中关于<code>SecurityManager</code>的代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SecurityManager security = System.getSecurityManager();</div><div class="line">if (security != null) &#123;</div><div class="line">    security.checkWrite(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="在本机运行正常，在服务器运行报错权限错误："><a href="#在本机运行正常，在服务器运行报错权限错误：" class="headerlink" title="在本机运行正常，在服务器运行报错权限错误："></a>在本机运行正常，在服务器运行报错权限错误：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.security.AccessControlException: access denied (java.lang.RuntimePermission createSecurityManager)</div><div class="line">    at java.security.AccessControlContext.checkPermission(AccessControlContext.java:374)</div><div class="line">    at java.security.AccessController.checkPermission(AccessController.java:549)</div><div class="line">    at java.lang.SecurityManager.checkPermission(SecurityManager.java:532)</div><div class="line">    at java.lang.SecurityManager.&lt;init&gt;(SecurityManager.java:282)</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>为了彻底明白这些情况，需要研究一下<code>SecurityManager</code>。</p>
<h2 id="SecurityManager应用场景"><a href="#SecurityManager应用场景" class="headerlink" title="SecurityManager应用场景"></a><code>SecurityManager</code>应用场景</h2><p>当运行未知的Java程序(可能有恶意代码（删除系统文件、重启系统等）)时，为了防止恶意代码对系统产生影响，需要对运行的代码的权限进行控制，这时就需要启用Java安全管理器。</p>
<h2 id="管理器配置文件"><a href="#管理器配置文件" class="headerlink" title="管理器配置文件"></a>管理器配置文件</h2><h3 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h3><p>默认的安全管理器配置文件位于<code>$JAVA_HOME/jre/lib/security/java.policy</code>，当未指定配置文件时，将会使用该默认配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">// Standard extensions get all permissions by default</div><div class="line"></div><div class="line">grant codeBase &quot;file:$&#123;&#123;java.ext.dirs&#125;&#125;/*&quot; &#123;</div><div class="line">        permission java.security.AllPermission;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">// default permissions granted to all domains</div><div class="line"></div><div class="line">grant &#123;</div><div class="line">        // Allows any thread to stop itself using the java.lang.Thread.stop()</div><div class="line">        // method that takes no argument.</div><div class="line">        // Note that this permission is granted by default only to remain</div><div class="line">        // backwards compatible.</div><div class="line">        // It is strongly recommended that you either remove this permission</div><div class="line">        // from this policy file or further restrict it to code sources</div><div class="line">        // that you specify, because Thread.stop() is potentially unsafe.</div><div class="line">        // See the API specification of java.lang.Thread.stop() for more</div><div class="line">        // information.</div><div class="line">        permission java.lang.RuntimePermission &quot;stopThread&quot;;</div><div class="line"></div><div class="line">        // allows anyone to listen on dynamic ports</div><div class="line">        permission java.net.SocketPermission &quot;localhost:0&quot;, &quot;listen&quot;;</div><div class="line"></div><div class="line">        // &quot;standard&quot; properies that can be read by anyone</div><div class="line"></div><div class="line">        permission java.util.PropertyPermission &quot;java.version&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vendor&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vendor.url&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.class.version&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;os.name&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;os.version&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;os.arch&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;file.separator&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;path.separator&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;line.separator&quot;, &quot;read&quot;;</div><div class="line"></div><div class="line">        permission java.util.PropertyPermission &quot;java.specification.version&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.specification.vendor&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.specification.name&quot;, &quot;read&quot;;</div><div class="line"></div><div class="line">        permission java.util.PropertyPermission &quot;java.vm.specification.version&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vm.specification.vendor&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vm.specification.name&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vm.version&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vm.vendor&quot;, &quot;read&quot;;</div><div class="line">        permission java.util.PropertyPermission &quot;java.vm.name&quot;, &quot;read&quot;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="启用安全管理器"><a href="#启用安全管理器" class="headerlink" title="启用安全管理器"></a>启用安全管理器</h2><p>　　<br>有两种方式，建议采用参数启用方式。</p>
<h3 id="参数启用方式"><a href="#参数启用方式" class="headerlink" title="参数启用方式"></a>参数启用方式</h3><p>运行程序的时候附加参数启用安全管理器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Djava.security.manager</div></pre></td></tr></table></figure></p>
<p>指定配置文件的位置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">-Djava.security.manager -Djava.security.policy=&quot;E:/java.policy&quot;</div></pre></td></tr></table></figure></p>
<h3 id="编码方式启用"><a href="#编码方式启用" class="headerlink" title="编码方式启用"></a>编码方式启用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">System.setSecurityManager(new SecurityManager());</div></pre></td></tr></table></figure>
<p>参数启用本质上也是通过编码启用，不过参数启用灵活（<code>sun.misc.Launcher</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">String str = System.getProperty(&quot;java.security.manager&quot;);</div><div class="line">if (str != null)</div><div class="line">&#123;</div><div class="line">  SecurityManager localSecurityManager = null;</div><div class="line">  if ((&quot;&quot;.equals(str)) || (&quot;default&quot;.equals(str))) &#123;</div><div class="line">    localSecurityManager = new SecurityManager();</div><div class="line">  &#125; else &#123;</div><div class="line">    try</div><div class="line">    &#123;</div><div class="line">      localSecurityManager = (SecurityManager)this.loader.loadClass(str).newInstance();</div><div class="line">    &#125;</div><div class="line">    catch (IllegalAccessException localIllegalAccessException) &#123;&#125;catch (InstantiationException localInstantiationException) &#123;&#125;catch (ClassNotFoundException localClassNotFoundException) &#123;&#125;catch (ClassCastException localClassCastException) &#123;&#125;</div><div class="line">  &#125;</div><div class="line">  if (localSecurityManager != null) &#123;</div><div class="line">    System.setSecurityManager(localSecurityManager);</div><div class="line">  &#125; else &#123;</div><div class="line">    throw new InternalError(&quot;Could not create SecurityManager: &quot; + str);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会创建一个默认的<code>SecurityManager</code></p>
<h2 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h2><h3 id="配置基本原则"><a href="#配置基本原则" class="headerlink" title="配置基本原则"></a>配置基本原则</h3><p>在启用安全管理器的时候，配置遵循以下基本原则：</p>
<ul>
<li>没有配置的权限表示没有</li>
<li>只能配置有什么权限，不能配置禁止做什么</li>
<li>同一种权限可多次配置，取并集。</li>
<li>统一资源的多种权限可用逗号分割。</li>
</ul>
<h3 id="默认配置文件解释"><a href="#默认配置文件解释" class="headerlink" title="默认配置文件解释"></a>默认配置文件解释</h3><h4 id="第一部分授权："><a href="#第一部分授权：" class="headerlink" title="第一部分授权："></a>第一部分授权：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grant codeBase &quot;file:$&#123;&#123;java.ext.dirs&#125;&#125;/*&quot; &#123;</div><div class="line">    permission java.security.AllPermission;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>授权位于”<code>file:$/</code>*”下的class和jar包所有权限。</p>
<h4 id="第二部分授权："><a href="#第二部分授权：" class="headerlink" title="第二部分授权："></a>第二部分授权：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">grant &#123; </div><div class="line">    permission java.lang.RuntimePermission &quot;stopThread&quot;;</div><div class="line">    ……   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是细粒度的授权，对某些资源进行授权。<code>RuntimePermission</code>的可授权操作(<code>stopThread</code>仅仅是其中的一个)如下(可查看javadoc)：</p>
<table>
<thead>
<tr>
<th>权限目标名称</th>
<th style="text-align:center">权限所允许的操作</th>
<th style="text-align:right">允许此权限所带来的风险</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>createClassLoader</code></td>
<td style="text-align:center">创建类加载器</td>
<td style="text-align:right">授予该权限极其危险。能够实例化自己的类加载器的恶意应用程序可能会在系统中装载自己的恶意类。这些新加载的类可能被类加载器置于任意保护域中，从而自动将该域的权限授予这些类。</td>
</tr>
<tr>
<td><code>getClassLoader</code></td>
<td style="text-align:center">类加载器的获取（即调用类的类加载器）</td>
<td style="text-align:right">这将授予攻击者得到具体类的加载器的权限。这很危险，由于攻击者能够访问类的类加载器，所以攻击者能够加载其他可用于该类加载器的类。通常攻击者不具备这些类的访问权限。</td>
</tr>
<tr>
<td><code>setContextClassLoader</code></td>
<td style="text-align:center">线程使用的上下文类加载器的设置</td>
<td style="text-align:right">在需要查找可能不存在于系统类加载器中的资源时，系统代码和扩展部分会使用上下文类加载器。授予 <code>setContextClassLoader</code> 权限将允许代码改变特定线程（包括系统线程）使用的上下文类加载器。</td>
</tr>
<tr>
<td><code>enableContextClassLoaderOverride</code></td>
<td style="text-align:center">线程上下文类加载器方法的子类实现</td>
<td style="text-align:right">在需要查找可能不存在于系统类加载器中的资源时，系统代码和扩展部分会使用上下文类加载器。授予<code>enableContextClassLoaderOverride</code>权限将允许线程的子类重写某些方法，这些方法用于得到或设置特定线程的上下文类加载器。</td>
</tr>
<tr>
<td><code>setSecurityManager</code></td>
<td style="text-align:center">设置安全管理器（可能会替换现有的）</td>
<td style="text-align:right">安全管理器是允许应用程序实现安全策略的类。授予<code>setSecurityManager</code>权限将通过安装一个不同的、可能限制更少的安全管理器，来允许代码改变所用的安全管理器，因此可跳过原有安全管理器所强制执行的某些检查。</td>
</tr>
<tr>
<td><code>createSecurityManager</code></td>
<td style="text-align:center">创建新的安全管理器</td>
<td style="text-align:right">授予代码对受保护的、敏感方法的访问权，可能会泄露有关其他类或执行堆栈的信息。</td>
</tr>
<tr>
<td><code>getenv.{variable name}</code></td>
<td style="text-align:center">读取指定环境变量的值</td>
<td style="text-align:right">此权限允许代码读取特定环境变量的值或确定它是否存在。如果该变量含有机密数据，则这项授权是很危险的。</td>
</tr>
<tr>
<td><code>exitVM.{exit status}</code></td>
<td style="text-align:center">暂停带有指定退出状态的Java虚拟机</td>
<td style="text-align:right">此权限允许攻击者通过自动强制暂停虚拟机来发起一次拒绝服务攻击。注意：自动为那些从应用程序类路径加载的全部代码授予 “<code>exitVM.*</code>“权限，从而使这些应用程序能够自行中止。此外，”<code>exitVM</code>“权限等于”exitVM.*”。</td>
</tr>
<tr>
<td><code>shutdownHooks</code></td>
<td style="text-align:center">虚拟机关闭钩子 (hook) 的注册与取消</td>
<td style="text-align:right">此权限允许攻击者注册一个妨碍虚拟机正常关闭的恶意关闭钩子 (hook)。</td>
</tr>
<tr>
<td><code>setFactory</code></td>
<td style="text-align:center">设置由<code>ServerSocket</code>或<code>Socket</code>使用的套接字工厂，或<code>URL</code>使用的流处理程序工厂</td>
<td style="text-align:right">此权限允许代码设置套接字、服务器套接字、流处理程序或 RMI套接字工厂的实际实现。攻击者可能设置错误的实现，从而破坏数据流。</td>
</tr>
<tr>
<td><code>setIO</code></td>
<td style="text-align:center"><code>System.out</code>、<code>System.in</code>和<code>System.err</code>的设置</td>
<td style="text-align:right">此权限允许改变标准系统流的值。攻击者可以改变<code>System.in</code>来监视和窃取用户输入，或将<code>System.err</code>设置为”<code>null</code>“ <code>OutputStream</code>，从而隐藏发送到<code>System.err</code>的所有错误信息。</td>
</tr>
<tr>
<td><code>modifyThread</code></td>
<td style="text-align:center">修改线程，例如通过调用线程的<code>interrupt</code>、<code>stop</code>、<code>suspend</code>、<code>resume</code>、<code>setDaemon</code>、<code>setPriority</code>、<code>setName</code>和<code>setUncaughtExceptionHandler</code>方法</td>
<td style="text-align:right">此权限允许攻击者修改系统中任意线程的行为。</td>
</tr>
<tr>
<td><code>stopThread</code></td>
<td style="text-align:center">通过调用线程的<code>stop</code>方法停止线程</td>
<td style="text-align:right">如果系统已授予代码访问该线程的权限，则此权限允许代码停止系统中的任何线程。此权限会造成一定的危险，因为该代码可能通过中止现有的线程来破坏系统。</td>
</tr>
<tr>
<td><code>modifyThreadGroup</code></td>
<td style="text-align:center">修改线程组，例如通过调用<code>ThreadGroup</code>的<code>destroy</code>、<code>getParent</code>、<code>resume</code>、<code>setDaemon</code>、<code>setMaxPriority</code>、<code>stop</code>和<code>suspend</code>方法</td>
<td style="text-align:right">此权限允许攻击者创建线程组并设置它们的运行优先级。</td>
</tr>
<tr>
<td><code>getProtectionDomain</code></td>
<td style="text-align:center">获取类的<code>ProtectionDomain</code></td>
<td style="text-align:right">此权限允许代码获得特定代码源的安全策略信息。虽然获得安全策略信息并不足以危及系统安全，但这确实会给攻击者提供了能够更好地定位攻击目标的其他信息，例如本地文件名称等。</td>
</tr>
<tr>
<td><code>getFileSystemAttributes</code></td>
<td style="text-align:center">获取文件系统属性</td>
<td style="text-align:right">此权限允许代码获得文件系统信息（如调用者可用的磁盘使用量或磁盘空间）。这存在潜在危险，因为它泄露了关于系统硬件配置的信息以及一些关于调用者写入文件特权的信息。</td>
</tr>
<tr>
<td><code>readFileDescriptor</code></td>
<td style="text-align:center">读取文件描述符</td>
<td style="text-align:right">此权限允许代码读取与文件描述符读取相关的特定文件。如果该文件包含机密数据，则此操作非常危险。</td>
</tr>
<tr>
<td><code>writeFileDescriptor</code></td>
<td style="text-align:center">写入文件描述符</td>
<td style="text-align:right">此权限允许代码写入与描述符相关的特定文件。此权限很危险，因为它可能允许恶意代码传播病毒，或者至少也会填满整个磁盘。</td>
</tr>
<tr>
<td><code>loadLibrary.{库名}</code></td>
<td style="text-align:center">动态链接指定的库</td>
<td style="text-align:right">允许applet具有加载本机代码库的权限是危险的，因为Java安全架构并未设计成可以防止恶意行为，并且也无法在本机代码的级别上防止恶意行为。</td>
</tr>
<tr>
<td><code>accessClassInPackage.{包名}</code></td>
<td style="text-align:center">当类加载器调用<code>SecurityManager</code>的<code>checkPackageAccess</code>方法时，通过类加载器的<code>loadClass</code>方法访问指定的包</td>
<td style="text-align:right">此权限允许代码访问它们通常无法访问的那些包中的类。恶意代码可能利用这些类帮助它们实现破坏系统安全的企图。</td>
</tr>
<tr>
<td><code>defineClassInPackage.{包名}</code></td>
<td style="text-align:center">当类加载器调用<code>SecurityManager</code>的<code>checkPackageDefinition</code>方法时，通过类加载器的<code>defineClass</code> 方法定义指定的包中的类。</td>
<td style="text-align:right">此权限允许代码在特定包中定义类。这样做很危险，因为具有此权限的恶意代码可能在受信任的包中定义恶意类，比如<code>java.security</code>或<code>java.lang</code>。</td>
</tr>
<tr>
<td><code>accessDeclaredMembers</code></td>
<td style="text-align:center">访问类的已声明成员</td>
<td style="text-align:right">此权限允许代码查询类的公共、受保护、默认（包）访问和私有的字段和或方法。尽管代码可以访问私有和受保护字段和方法名称，但它不能访问私有/受保护字段数据并且不能调用任何私有方法。此外，恶意代码可能使用该信息来更好地定位攻击目标。而且，它可以调用类中的任意公共方法和/或访问公共字段。如果代码不能用这些方法和字段将对象强制转换为类/接口，那么它通常无法调用这些方法和/或访问该字段，而这可能很危险。</td>
</tr>
<tr>
<td><code>queuePrintJob</code></td>
<td style="text-align:center">打印作业请求的开始</td>
<td style="text-align:right">这可能向打印机输出敏感信息，或者只是浪费纸张。</td>
</tr>
<tr>
<td><code>getStackTrace</code></td>
<td style="text-align:center">获取另一个线程的堆栈追踪信息。</td>
<td style="text-align:right">此权限允许获取另一个线程的堆栈追踪信息。此操作可能允许执行恶意代码监视线程并发现应用程序中的弱点。</td>
</tr>
<tr>
<td><code>setDefaultUncaughtExceptionHandler</code></td>
<td style="text-align:center">在线程由于未捕获的异常而突然终止时，设置将要使用的默认处理程序</td>
<td style="text-align:right">此权限允许攻击者注册恶意的未捕获异常处理程序，可能会妨碍线程的终止</td>
</tr>
<tr>
<td><code>Preferences</code></td>
<td style="text-align:center">表示得到<code>java.util.prefs.Preferences</code>的访问权所需的权限。<code>java.util.prefs.Preferences</code>实现了用户或系统的根，这反过来又允许获取或更新<code>Preferences</code> 持久内部存储中的操作。</td>
<td style="text-align:right">如果运行此代码的用户具有足够的读/写内部存储的OS特权，则此权限就允许用户读/写优先级内部存储。实际的内部存储可能位于传统的文件系统目录中或注册表中，这取决于平台 OS。</td>
</tr>
</tbody>
</table>
<h3 id="可配置项详解"><a href="#可配置项详解" class="headerlink" title="可配置项详解"></a>可配置项详解</h3><p>当批量配置的时候，有三种模式：</p>
<p><code>directory/</code> 表示<code>directory</code>目录下的所有<code>.class</code>文件，不包括<code>.jar</code>文件<br><code>directory/*</code> 表示<code>directory</code>目录下的所有的<code>.class</code>及<code>.jar</code>文件<br><code>directory/-`` 表示directory目录下的所有的</code>.class<code>及</code>.jar`文件，包括子目录</p>
<p>可以通过<code>${}</code>来引用系统属性，如：</p>
<p><code>&quot;file:$/*&quot;</code></p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>　　</p>
<h3 id="取消安全管理器"><a href="#取消安全管理器" class="headerlink" title="取消安全管理器"></a>取消安全管理器</h3><p>　　</p>
<h3 id="增加相应权限"><a href="#增加相应权限" class="headerlink" title="增加相应权限"></a>增加相应权限</h3><p>如果没有某项权限则报错信息会提示是请求什么权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Exception in thread &quot;main&quot; java.security.AccessControlException: access denied (java.io.FilePermission c:\test.txt write)</div></pre></td></tr></table></figure>
<p>对<code>c:\test.txt</code>没有写权限。</p>
<p>最简单的事开放所有权限（不推荐）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">grant &#123; </div><div class="line">    permission java.security.AllPermission;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      java安全管理器SecurityManager
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>编写java的安全管理器</title>
    <link href="http://jishusuishouji.github.io/2017/05/09/java%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6.md/java%E7%9A%84%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/"/>
    <id>http://jishusuishouji.github.io/2017/05/09/java的安全机制.md/java的安全机制/</id>
    <published>2017-05-08T16:04:27.000Z</published>
    <updated>2017-05-08T19:52:17.964Z</updated>
    
    <content type="html"><![CDATA[<p>安全管理器<code>SecurityManager</code>核心方法<code>checkPerssiom</code>,而该方法又调用<code>AccessController</code>的<code>checkPerssiom</code>方法，访问控制器<code>AccessController</code>的栈检查机制会遍历整个<code>PerssiomCollection</code>来判断具体拥有什么权限,一旦发现栈中一个权限不允许会抛出异常，否则简单的返回。</p>
<h2 id="编写java的安全管理器"><a href="#编写java的安全管理器" class="headerlink" title="编写java的安全管理器"></a>编写java的安全管理器</h2><h3 id="定义一个类继承自SecurityManger并重写checkRead方法"><a href="#定义一个类继承自SecurityManger并重写checkRead方法" class="headerlink" title="定义一个类继承自SecurityManger并重写checkRead方法"></a>定义一个类继承自<code>SecurityManger</code>并重写<code>checkRead</code>方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">package com.test.security.manager;</div><div class="line"></div><div class="line">public class MySecurityManager extends SecurityManager &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void checkRead(String fileFullPath) &#123;</div><div class="line">        // super.checkRead(fileFullPath);</div><div class="line">        if (fileFullPath.endsWith(&quot;test&quot;)) &#123;</div><div class="line">            throw new SecurityException(&quot;你没有读取的本文件的权限&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package com.test.security.manager;</div><div class="line"></div><div class="line">import java.io.FileInputStream;</div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import org.junit.Test;</div><div class="line"></div><div class="line">public class MySecurityManagerTest &#123;</div><div class="line">    @Test</div><div class="line">    public void testCheckReadString() &#123;</div><div class="line">        System.setSecurityManager(new MySecurityManager());</div><div class="line">        try &#123;</div><div class="line">            FileInputStream fis = new FileInputStream(&quot;test&quot;);</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">java.lang.SecurityException: 你没有读取的本文件的权限</div><div class="line">    at com.test.security.manager.MySecurityManager.checkRead(MySecurityManager.java:9)</div><div class="line">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:127)</div><div class="line">    at java.io.FileInputStream.&lt;init&gt;(FileInputStream.java:93)</div><div class="line">    at com.test.security.manager.MySecurityManagerTest.testCheckReadString(MySecurityManagerTest.java:13)</div><div class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</div><div class="line">    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</div><div class="line">    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</div><div class="line">    at java.lang.reflect.Method.invoke(Method.java:498)</div><div class="line">    at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)</div><div class="line">    at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)</div><div class="line">    at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)</div><div class="line">    at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)</div><div class="line">    at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)</div><div class="line">    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)</div><div class="line">    at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)</div><div class="line">    at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)</div><div class="line">    at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)</div><div class="line">    at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)</div><div class="line">    at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)</div><div class="line">    at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)</div><div class="line">    at org.junit.runners.ParentRunner.run(ParentRunner.java:363)</div><div class="line">    at org.eclipse.jdt.internal.junit4.runner.JUnit4TestReference.run(JUnit4TestReference.java:86)</div><div class="line">    at org.eclipse.jdt.internal.junit.runner.TestExecution.run(TestExecution.java:38)</div><div class="line">    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:459)</div><div class="line">    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.runTests(RemoteTestRunner.java:678)</div><div class="line">    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.run(RemoteTestRunner.java:382)</div><div class="line">    at org.eclipse.jdt.internal.junit.runner.RemoteTestRunner.main(RemoteTestRunner.java:192)</div></pre></td></tr></table></figure>
<p><code>System.setSecurityManager(new MySecurityManager());</code>这是安装安全管理器的一种方法，也可以用<code>-Djava.security.manager</code>安装默认的安全管理器。</p>
<h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><p>进入<code>FileInputStream</code>的构造函数:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public FileInputStream(File file) throws FileNotFoundException &#123;</div><div class="line">    String name = (file != null ? file.getPath() : null);</div><div class="line">    SecurityManager security = System.getSecurityManager();</div><div class="line">    if (security != null) &#123;</div><div class="line">        security.checkRead(name);</div><div class="line">    &#125;</div><div class="line">    if (name == null) &#123;</div><div class="line">        throw new NullPointerException();</div><div class="line">    &#125;</div><div class="line">    if (file.isInvalid()) &#123;</div><div class="line">        throw new FileNotFoundException(&quot;Invalid file path&quot;);</div><div class="line">    &#125;</div><div class="line">    fd = new FileDescriptor();</div><div class="line">    fd.attach(this);</div><div class="line">    path = name;</div><div class="line">    open(name);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>先会执行<code>SecurityManager security = System.getSecurityManager();</code>，然后再调用<code>security</code>的<code>checkRead</code>方法。</p>
<p>联想一下，在使用java的<code>File</code>时会<code>new File(&quot;test&quot;).setWritable(Boolean.TRUE, Boolean.TRUE);</code>，这可以指定创建文件的权限，这里就是使用了安全管理器来设置权限。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public boolean setWritable(boolean writable, boolean ownerOnly) &#123;</div><div class="line">    SecurityManager security = System.getSecurityManager();</div><div class="line">    if (security != null) &#123;</div><div class="line">        security.checkWrite(path);</div><div class="line">    &#125;</div><div class="line">    if (isInvalid()) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    return fs.setPermission(this, FileSystem.ACCESS_WRITE, writable, ownerOnly);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      编写java的安全管理器
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Reflections中的getDeclared**与get**的区别 </title>
    <link href="http://jishusuishouji.github.io/2017/05/02/Reflections%E4%B8%AD%E7%9A%84getDeclared-%E4%B8%8Eget-%E7%9A%84%E5%8C%BA%E5%88%AB.md/Reflections%E4%B8%AD%E7%9A%84getDeclared__%E4%B8%8Eget__%E7%9A%84%E5%8C%BA%E5%88%AB_/"/>
    <id>http://jishusuishouji.github.io/2017/05/02/Reflections中的getDeclared-与get-的区别.md/Reflections中的getDeclared__与get__的区别_/</id>
    <published>2017-05-02T11:16:18.000Z</published>
    <updated>2017-05-02T11:27:08.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="getDeclaredMethod-s"><a href="#getDeclaredMethod-s" class="headerlink" title="getDeclaredMethod(s)"></a><code>getDeclaredMethod(s)</code></h2><p>返回该类本身的所有方法(包括私有方法)，但不包括继承的方法。<br>返回数组中的元素没有排序，也没有任何特定的顺序。如果该类或接口不声明任何方法，或此<code>Class</code>对象表示一个基本类型、数组类型或<code>void</code>，则此方法返回一个长度为0的数组。</p>
<p>类初始化方法不包含在返回数组中。</p>
<p>该方法返回所有重载的方法。</p>
<h2 id="getMethod-s"><a href="#getMethod-s" class="headerlink" title="getMethod(s)"></a><code>getMethod(s)</code></h2><p>返回某个类的所有<code>public</code>(包括继承来<code>public</code>方法)。</p>
<p>如果此<code>Class</code>对象表示基本类型或<code>void</code>，则此方法返回长度为0的数组。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>getDeclaredMethods</code>：自身，所有方法，不继承<br><code>getMethods</code>:<code>public</code> 继承</p>
<h2 id="getDeclaredField（s）和getField（s）同上"><a href="#getDeclaredField（s）和getField（s）同上" class="headerlink" title="getDeclaredField（s）和getField（s）同上"></a><code>getDeclaredField（s）</code>和<code>getField（s）</code>同上</h2><h2 id="getDeclaredAnnotation（s）"><a href="#getDeclaredAnnotation（s）" class="headerlink" title="getDeclaredAnnotation（s）"></a><code>getDeclaredAnnotation（s）</code></h2><p>返回直接存在于此元素上的所有注释。该方法将忽略继承的注释。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。<br>getAnnotation（s）：返回此元素上存在的所有注释。（如果此元素没有注释，则返回长度为零的数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。<br>getDeclaredAnnotations得到的是当前成员所有的注释，不包括继承的。而getAnnotations得到的是包括继承的所有注释。</p>
<p>关键在于继承的问题上，getDeclaredAnnotations和getAnnotations是否相同，就在于父类的注解是否可继承，这可以用sun.reflect.annotation.AnnotationType antype3=AnnotationType.getInstance(Class.forName(annotationtype_class(example:”javax.ejb.Stateful”)).isInherited())来判定，如果为true，说明可以被继承则存在与getAnnotations之中而不在getDeclaredAnnotations之中，否则，也不存在与getannnotations中，因为不能被继承。</p>
]]></content>
    
    <summary type="html">
    
      Reflections中的getDeclared**与get**的区别 
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="反射" scheme="http://jishusuishouji.github.io/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Spring 资源访问剖析和策略模式应用</title>
    <link href="http://jishusuishouji.github.io/2017/04/24/spring/Spring_%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%89%96%E6%9E%90%E5%92%8C%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8/"/>
    <id>http://jishusuishouji.github.io/2017/04/24/spring/Spring_资源访问剖析和策略模式应用/</id>
    <published>2017-04-24T14:45:24.000Z</published>
    <updated>2017-04-24T14:45:40.704Z</updated>
    
    <summary type="html">
    
      Spring 资源访问剖析和策略模式应用
    
    </summary>
    
      <category term="spring" scheme="http://jishusuishouji.github.io/categories/spring/"/>
    
    
      <category term="spring" scheme="http://jishusuishouji.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>java 类型信息 instanceof 和 isInstance区别</title>
    <link href="http://jishusuishouji.github.io/2017/04/20/java/java_%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF_instanceof_%E5%92%8C_isInstance%E5%8C%BA%E5%88%AB/"/>
    <id>http://jishusuishouji.github.io/2017/04/20/java/java_类型信息_instanceof_和_isInstance区别/</id>
    <published>2017-04-19T21:26:32.000Z</published>
    <updated>2017-04-19T21:39:01.480Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class A&#123;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class B extends A &#123;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">class C extends B &#123;  </div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">public class T &#123;  </div><div class="line">  </div><div class="line">   </div><div class="line">    public static void main(String[] args) &#123;  </div><div class="line">        C c = new C();  </div><div class="line">        B b = new B();  </div><div class="line">        A a = new A();  </div><div class="line">          </div><div class="line">        B bc = new C();  </div><div class="line">        A ac = new C();  </div><div class="line">          </div><div class="line">        System.out.println(c instanceof C);  </div><div class="line">        System.out.println(c instanceof B);  </div><div class="line">        System.out.println(c instanceof A);  </div><div class="line">          </div><div class="line">        System.out.println();  </div><div class="line">          </div><div class="line">        System.out.println(c.getClass().isInstance(c));  </div><div class="line">        System.out.println(c.getClass().isInstance(b));  </div><div class="line">        System.out.println(c.getClass().isInstance(a));  </div><div class="line">          </div><div class="line">        System.out.println();  </div><div class="line">          </div><div class="line">        System.out.println(c.getClass().isInstance(bc));  </div><div class="line">        System.out.println(c.getClass().isInstance(ac));  </div><div class="line">          </div><div class="line">        System.out.println();  </div><div class="line">          </div><div class="line">        System.out.println(A.class.isInstance(a));  </div><div class="line">        System.out.println(A.class.isInstance(b));  </div><div class="line">        System.out.println(A.class.isInstance(c));  </div><div class="line">        System.out.println(A.class.isInstance(ac));  </div><div class="line">        System.out.println(A.class.isInstance(bc));  </div><div class="line">          </div><div class="line">        System.out.println();  </div><div class="line">          </div><div class="line">        System.out.println(B.class.isInstance(a));  </div><div class="line">        System.out.println(B.class.isInstance(b));  </div><div class="line">        System.out.println(B.class.isInstance(c));  </div><div class="line">        System.out.println(B.class.isInstance(ac));  </div><div class="line">        System.out.println(B.class.isInstance(bc));  </div><div class="line">          </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line"></div><div class="line"></div><div class="line">true</div><div class="line">false</div><div class="line">false</div><div class="line"></div><div class="line"></div><div class="line">true</div><div class="line">true</div><div class="line"></div><div class="line"></div><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line"></div><div class="line"></div><div class="line">false</div><div class="line">true</div><div class="line">true</div><div class="line">true</div><div class="line">true</div></pre></td></tr></table></figure>
<h2 id="对象-instanceof-类"><a href="#对象-instanceof-类" class="headerlink" title="对象 instanceof 类"></a>对象 instanceof 类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">obj instanceof class</div></pre></td></tr></table></figure>
<p>如果<code>class obj1 = obj</code>成立的话，返回<code>true</code>，否则返回<code>false</code></p>
<h2 id="类-isInstance-对象"><a href="#类-isInstance-对象" class="headerlink" title="类.isInstance(对象)"></a><code>类.isInstance(对象)</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">class.isInstance(obj)</div></pre></td></tr></table></figure>
<p>如果<code>class obj1 = obj</code>成立的话，返回<code>true</code>，否则返回<code>false</code></p>
<p><code>instanceof</code>运算符只被用于对象引用变量，检查左边的被测试对象是不是 右边类或接口的实例化。如果被测对象是<code>null</code>值，则测试结果总是<code>false</code>。<br>形象地：自身实例或子类实例 <code>instanceof</code> 自身类   返回<code>true</code><br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String s=new String(&quot;javaisland&quot;);</div><div class="line">System.out.println(s instanceof String); //true</div></pre></td></tr></table></figure></p>
<p>Class类的isInstance(Object obj)方法，obj是被测试的对象，如果obj是调用这个方法的class或接口 的实例，则返回true。这个方法是instanceof运算符的动态等价。<br>形象地：自身类.class.isInstance(自身实例或子类实例)  返回true<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String s=new String(&quot;javaisland&quot;);</div><div class="line">System.out.println(String.class.isInstance(s)); //true</div></pre></td></tr></table></figure></p>
<p>Class类的isAssignableFrom(Class cls)方法，如果调用这个方法的class或接口与 参数cls表示的类或接口相同，或者是参数cls表示的类或接口的父类，则返回true。<br>形象地：自身类.class.isAssignableFrom(自身类或子类.class)  返回true<br>例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(ArrayList.class.isAssignableFrom(Object.class));  //false</div><div class="line">System.out.println(Object.class.isAssignableFrom(ArrayList.class));  //true</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      java 类型信息 instanceof 和 isInstance区别
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>spring 后置处理器BeanFactoryPostProcessor和BeanPostProcessor的用法和区别</title>
    <link href="http://jishusuishouji.github.io/2017/04/18/spring/spring_%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8BeanFactoryPostProcessor%E5%92%8CBeanPostProcessor%E7%9A%84%E7%94%A8%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>http://jishusuishouji.github.io/2017/04/18/spring/spring_后置处理器BeanFactoryPostProcessor和BeanPostProcessor的用法和区别/</id>
    <published>2017-04-18T15:48:50.000Z</published>
    <updated>2017-04-18T15:57:25.586Z</updated>
    
    <content type="html"><![CDATA[<p>主要区别就是：<code>BeanFactoryPostProcessor</code>(BeanFactory的后置处理器)可以修改BEAN的配置信息而<code>BeanPostProcessor</code>(Bean的后置处理器)不能:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package com.springdemo.postProcessor;  </div><div class="line">  </div><div class="line">public class PostProcessorBean &#123;  </div><div class="line">    private String username;  </div><div class="line">      </div><div class="line">    private String password;  </div><div class="line">  </div><div class="line">    public String getPassword() &#123;  </div><div class="line">        return password;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    public void setPassword(String password) &#123;  </div><div class="line">        this.password = password;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    public String getUsername() &#123;  </div><div class="line">        return username;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    public void setUsername(String username) &#123;  </div><div class="line">        this.username = username;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MyBeanPostProcessor</code>类，实现了<code>BeanPostProcessor</code>接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">package com.springdemo.postProcessor;  </div><div class="line">  </div><div class="line">import org.springframework.beans.BeansException;  </div><div class="line">import org.springframework.beans.factory.config.BeanPostProcessor;  </div><div class="line">  </div><div class="line">import com.springdemo.form.LoginForm;  </div><div class="line">  </div><div class="line">public class MyBeanPostProcessor implements BeanPostProcessor &#123;  </div><div class="line">  </div><div class="line">      </div><div class="line">      </div><div class="line">    public Object postProcessAfterInitialization(Object bean, String beanName)  </div><div class="line">            throws BeansException &#123;  </div><div class="line">        //如果是PostProcessorBean则username信息  </div><div class="line">        if(bean instanceof PostProcessorBean)  </div><div class="line">        &#123;  </div><div class="line">            System.out.println(&quot;PostProcessorBean Bean initialized&quot;);  </div><div class="line">            PostProcessorBean pb = (PostProcessorBean)bean;  </div><div class="line">              </div><div class="line">            System.out.println(&quot;username:&quot;+pb.getUsername());  </div><div class="line">        &#125;  </div><div class="line">        return bean;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    public Object postProcessBeforeInitialization(Object bean, String beanName)  </div><div class="line">            throws BeansException &#123;  </div><div class="line">         if(bean instanceof PostProcessorBean)  </div><div class="line">        &#123;  </div><div class="line">            System.out.println(&quot;PostProcessorBean Bean initializing&quot;);  </div><div class="line">            PostProcessorBean pb = (PostProcessorBean)bean;  </div><div class="line">              </div><div class="line">            System.out.println(&quot;username:&quot;+pb.getUsername());  </div><div class="line">        &#125;  </div><div class="line">        return bean;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>MyBeanFactoryPostProcessor</code>实现了<code>BeanFactoryPostProcessor</code>接口:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">package com.springdemo.postProcessor;  </div><div class="line">  </div><div class="line">import org.springframework.beans.BeansException;  </div><div class="line">import org.springframework.beans.MutablePropertyValues;  </div><div class="line">import org.springframework.beans.factory.config.BeanDefinition;  </div><div class="line">import org.springframework.beans.factory.config.BeanFactoryPostProcessor;  </div><div class="line">import org.springframework.beans.factory.config.ConfigurableListableBeanFactory;  </div><div class="line">  </div><div class="line">public class MyBeanFactoryPostProcessor implements BeanFactoryPostProcessor &#123;  </div><div class="line">  </div><div class="line">    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory)  </div><div class="line">            throws BeansException &#123;  </div><div class="line">        </div><div class="line">        //BeanFactoryPostProcessor可以修改BEAN的配置信息而BeanPostProcessor不能  </div><div class="line">        //在这里修改postProcessorBean的username注入属性  </div><div class="line">        BeanDefinition bd = beanFactory.getBeanDefinition(&quot;postProcessorBean&quot;);  </div><div class="line">        MutablePropertyValues pv =  bd.getPropertyValues();  </div><div class="line">        if(pv.contains(&quot;username&quot;))  </div><div class="line">        &#123;  </div><div class="line">            pv.addPropertyValue(&quot;username&quot;, &quot;xiaojun&quot;);  </div><div class="line">        &#125;  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编写测试用例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">package com.springdemo.test;  </div><div class="line">  </div><div class="line">  </div><div class="line">import org.springframework.context.ApplicationContext;  </div><div class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;  </div><div class="line">  </div><div class="line">import com.springdemo.factory.ApplicationContextFactory;  </div><div class="line">  </div><div class="line">import com.springdemo.postProcessor.PostProcessorBean;  </div><div class="line">  </div><div class="line">import junit.framework.TestCase;  </div><div class="line">  </div><div class="line">public class BeanPostPorcessorTest extends TestCase &#123;  </div><div class="line">    private ApplicationContext context;  </div><div class="line">    protected void setUp() throws Exception &#123;  </div><div class="line">        super.setUp();  </div><div class="line">        String[] paths = &#123;&quot;classpath*:/spring/applicationContext-*.xml&quot;&#125;;  </div><div class="line">  </div><div class="line">        context = new ClassPathXmlApplicationContext(paths);  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    protected void tearDown() throws Exception &#123;  </div><div class="line">        super.tearDown();  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">    public void testBeanPostProcessor()  </div><div class="line">    &#123;  </div><div class="line">          </div><div class="line">    &#125;  </div><div class="line">    public void testBeanFactoryPostProcessor()  </div><div class="line">    &#123;  </div><div class="line">        PostProcessorBean bean =(PostProcessorBean)context.getBean(&quot;postProcessorBean&quot;);  </div><div class="line">        System.out.println(&quot;---------------testBeanFactoryPostProcessor----------------&quot;);  </div><div class="line">        System.out.println(&quot;username:&quot;+bean.getUsername());  </div><div class="line">        System.out.println(&quot;password:&quot;+bean.getPassword());    </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>spring配置文件如下（先不启用<code>MyBeanFactoryPostProcessor</code>）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;  </div><div class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  </div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  </div><div class="line">    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd&quot;&gt;  </div><div class="line">      </div><div class="line">    &lt;bean class=&quot;com.springdemo.postProcessor.MyBeanPostProcessor&quot;&gt;&lt;/bean&gt;  </div><div class="line">    &lt;!--我们先把BeanFactoryPostProcessor注释掉，不启用,然后查看测试输出结果    </div><div class="line">    &lt;bean class=&quot;com.springdemo.postProcessor.MyBeanFactoryPostProcessor&quot;&gt;&lt;/bean&gt;  </div><div class="line">    --&gt;  </div><div class="line">    &lt;bean id=&quot;postProcessorBean&quot; class=&quot;com.springdemo.postProcessor.PostProcessorBean&quot; &gt;  </div><div class="line">        &lt;property name=&quot;username&quot; value=&quot;test&quot;&gt;&lt;/property&gt;  </div><div class="line">        &lt;property name=&quot;password&quot; value=&quot;test&quot;&gt;&lt;/property&gt;  </div><div class="line">    &lt;/bean&gt;  </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>测试输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PostProcessorBean Bean initializing</div><div class="line">username:test</div><div class="line">PostProcessorBean Bean initialized</div><div class="line">username:test</div><div class="line">---------------testBeanFactoryPostProcessor----------------</div><div class="line">username:test</div><div class="line">password:test</div></pre></td></tr></table></figure></p>
<p>然后我们取消注释启用<code>MyBeanFactoryPostProcessor</code>，测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">PostProcessorBean Bean initializing</div><div class="line">username:xiaojun</div><div class="line">PostProcessorBean Bean initialized</div><div class="line">username:xiaojun</div><div class="line">---------------testBeanFactoryPostProcessor----------------</div><div class="line">username:xiaojun</div><div class="line">password:test</div></pre></td></tr></table></figure></p>
<p>从结果可以看出：<code>BeanFactoryPostProcessor</code>的回调比<code>BeanPostProcessor</code>要早，因为<code>BeanPostProcess</code>中输出的<code>username</code>已经变成了<code>xiaojun</code>,而不是<code>test</code>.还有就是<code>BeanFactoryPostProcessor</code>确实有能力改变初始化BEAN的内容.</p>
<p><code>BeanPostProcessor</code>也能改变bean的值。但值得奇怪的是，如果在<code>BeanFactoryPostProcessor</code>里面调用<code>factory.getBean()</code>，则会对bean进行初始化，但是这个初始化过程不会回调<code>BeanPostProcessor</code>的两个回调方法。</p>
]]></content>
    
    <summary type="html">
    
      spring 后置处理器BeanFactoryPostProcessor和BeanPostProcessor的用法和区别
    
    </summary>
    
      <category term="spring" scheme="http://jishusuishouji.github.io/categories/spring/"/>
    
    
      <category term="spring" scheme="http://jishusuishouji.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>学习Spring必学的Java基础知识----PropertyEditor</title>
    <link href="http://jishusuishouji.github.io/2017/04/18/spring/%E5%AD%A6%E4%B9%A0Spring%E5%BF%85%E5%AD%A6%E7%9A%84Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86----PropertyEditor/"/>
    <id>http://jishusuishouji.github.io/2017/04/18/spring/学习Spring必学的Java基础知识----PropertyEditor/</id>
    <published>2017-04-18T15:41:21.000Z</published>
    <updated>2017-04-18T15:47:58.746Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring配置文件里是通过字面值为Bean各种类型的属性提供设置值：不管是double类型还是int类型，在配置文件中都对应字符串类型的字面值。<br><code>BeanWrapper</code>填充Bean属性时如何将这个字面值转换为对应的<code>double</code>或<code>int</code>等内部类型呢？</p>
<p>任何实现<code>java.beans.PropertyEditor</code>接口的类都是属性编辑器。属性编辑器是将外部的设置值转换为JVM内部的对应类型，属性编辑器就是一个类型转换器。 </p>
<p><code>PropertyEditor</code>是JavaBean规范定义的接口。 </p>
<h2 id="JavaBean的编辑器"><a href="#JavaBean的编辑器" class="headerlink" title="JavaBean的编辑器"></a>JavaBean的编辑器</h2><p>Sun所制定的JavaBean规范，很大程度上是为IDE准备的——它让IDE能够以可视化的方式设置JavaBean的属性。如果在IDE中开发一个可视化应用程序，我们需要通过属性设置的方式对组成应用的各种组件进行定制，IDE通过属性编辑器让开发人员使用可视化的方式设置组件的属性。 </p>
<p>一般的IDE都支持JavaBean规范所定义的属性编辑器，当组件开发商发布一个组件时，它往往将组件对应的属性编辑器捆绑发行，这样开发者就可以在IDE环境下方便地利用属性编辑器对组件进行定制工作。 </p>
<p>JavaBean规范通过<code>java.beans.PropertyEditor</code>定义了设置JavaBean属性的方法，通过<code>BeanInfo</code>描述了JavaBean哪些属性是可定制的，此外还描述了可定制属性与<code>PropertyEditor</code>的对应关系。 </p>
<p>BeanInfo与JavaBean之间的对应关系，通过两者之间规范的命名确立：对应JavaBean的BeanInfo采用如下的命名规范：<bean>BeanInfo。如<code>ChartBean</code>对应的<code>BeanInfo</code>为<code>ChartBeanBeanInfo</code>；<code>Car</code>对应的<code>BeanInfo</code>为<code>CarBeanInfo</code>。当JavaBean连同其属性编辑器相同的组件注册到IDE中后，当在开发界面中对JavaBean进行定制时，IDE就会根据JavaBean规范找到对应的BeanInfo，再根据BeanInfo中的描述信息找到JavaBean属性描述（是否开放、使用哪个属性编辑器），进而为JavaBean生成特定开发编辑界面。 </bean></p>
<p>JavaBean规范提供了一个管理默认属性编辑器的管理器：<code>PropertyEditorManager</code>，该管理器内保存着一些常见类型的属性编辑器，如果某个JavaBean的常见类型属性没有通过BeanInfo显式指定属性编辑器，IDE将自动使用PropertyEditorManager中注册的对应默认属性编辑器。 </p>
<p>由于JavaBean对应的属性编辑器等IDE环境相关的资源和组件需要动态加载，所以在纯Java的IDE中开发基于组件的应用时，总会感觉IDE反应很迟钝，不像Delphi、C++Builder一样灵敏快捷。但在Eclipse开发环境中，设计包括可视化组件的应用时却很快捷，原因是Eclipse没有使用Java的标准用户界面组件库，当然也就没有按照JavaBean的规范开发设计GUI组件了。 </p>
<h2 id="PropertyEditor"><a href="#PropertyEditor" class="headerlink" title="PropertyEditor"></a><code>PropertyEditor</code></h2><p><code>PropertyEditor</code>是属性编辑器的接口，它规定了将外部设置值转换为内部JavaBean属性值的转换接口方法。<code>PropertyEditor</code>主要的接口方法说明如下：<br>  Object getValue()：返回属性的当前值。基本类型被封装成对应的封装类实例；<br>  void setValue(Object newValue)：设置属性的值，基本类型以封装类传入；<br>  String getAsText()：将属性对象用一个字符串表示，以便外部的属性编辑器能以可视化的方式显示。缺省返回null，表示该属性不能以字符串表示；<br>  void setAsText(String text)：用一个字符串去更新属性的内部值，这个字符串一般从外部属性编辑器传入；<br>  String[] getTags()：返回表示有效属性值的字符串数组（如boolean属性对应的有效Tag为true和false），以便属性编辑器能以下拉框的方式显示出来。缺省返回null，表示属性没有匹配的字符值有限集合；<br>  String getJavaInitializationString()：为属性提供一个表示初始值的字符串，属性编辑器以此值作为属性的默认值。</p>
<p>可以看出PropertyEditor接口方法是内部属性值和外部设置值的沟通桥梁。此外，我们可以很容易地发现该接口的很多方法是专为IDE中的可视化属性编辑器提供的：如getTags()、getJavaInitializationString()以及另外一些我们未此介绍的接口方法。 </p>
<p>Java为PropertyEditor提供了一个方便类：PropertyEditorSupport，该类实现了PropertyEditor接口并提供默认实现，一般情况下，用户可以通过扩展这个方便类设计自己的属性编辑器。 </p>
<p>BeanInfo </p>
<p>BeanInfo主要描述了JavaBean哪些属性可以编辑以及对应的属性编辑器，每一个属性对应一个属性描述器PropertyDescriptor。PropertyDescriptor的构造函数有两个入参：<br>PropertyDescriptor(String propertyName, Class beanClass) ，其中propertyName为属性名；而beanClass为JavaBean对应的Class。 </p>
<p>此外PropertyDescriptor还有一个setPropertyEditorClass(Class propertyEditorClass)方法，为JavaBean属性指定编辑器。BeanInfo接口最重要的方法就是：PropertyDescriptor[] getPropertyDescriptors() ，该方法返回JavaBean的属性描述器数组。 </p>
<p>BeanInfo接口有一个常用的实现类：SimpleBeanInfo，一般情况下，可以通过扩展SimpleBeanInfo实现自己的功能。 </p>
<p>一个实例 </p>
<p>在本节中，我们来看一个具体属性编辑器的实例，该实例根据《Core Java Ⅱ》上的一个例子改编而成。 </p>
<p>ChartBean是一个可定制图表组件，允许通过属性的设置定制图表的样式以得到满足各种不同使用场合要求的图表。我们忽略ChartBean的其他属性，仅关注其中的两个属性： </p>
<p>代码清单5-2  CharBean<br>Java代码  收藏代码<br>public class ChartBean extends JPanel{<br>   private int titlePosition = CENTER;<br>   private boolean inverse;<br>   //省略get/setter方法<br>}  </p>
<p>下面，我们为titlePosition属性提供一个属性编辑器。我们不去直接实现PropertyEditor，而是通过扩展PropertyEditorSupport这个方便类来定义我们的属性编辑器： </p>
<p>代码清单5-3  TitlePositionEditor<br>Java代码  收藏代码<br>import java.beans.*;<br> public class TitlePositionEditor extends PropertyEditorSupport{<br>    private String[] options = { “Left”, “Center”, “Right” };   </p>
<pre><code>//①代表可选属性值的字符串标识数组  
public String[] getTags() { return options; }      

//②代表属性初始值的字符串  
public String getJavaInitializationString() { return &quot;&quot; + getValue(); }   

//③将内部属性值转换为对应的字符串表示形式，供属性编辑器显示之用  
public String getAsText(){  
   int value = (Integer) getValue();  
   return options[value];  
}  

//④将外部设置的字符串转换为内部属性的值  
public void setAsText(String s){   
   for (int i = 0; i &lt; options.length; i++){  
      if (options[i].equals(s)){  
         setValue(i);  
         return;  
      }  
   }  
}  
</code></pre><p> }  </p>
<p>①处通过getTags()方法返回一个字符串数组，因此在IDE中该属性对应的编辑器将自动提供一个下拉框，下拉框中包含3个可选项：“Left”、“Center”、“Right”。而③和④处的两个方法分别完成属性值到字符串的双向转换功能。CharBean的inverse属性也有一个相似的编辑器InverseEditor，我们忽略不讲。 </p>
<p>下面编写ChartBean对应的BeanInfo，根据JavaBean的命名规范，这个BeanInfo应该命名为ChartBeanBeanInfo，它负责将属性编辑器和ChartBean的属性挂钩起来： </p>
<p>代码清单5-4  ChartBeanBeanInfo<br>Java代码  收藏代码<br>import java.beans.*;<br> public class ChartBeanBeanInfo extends SimpleBeanInfo{<br>    public PropertyDescriptor[] getPropertyDescriptors() {<br>       try{  </p>
<p>//①将TitlePositionEditor绑定到ChartBean的titlePosition属性中<br>PropertyDescriptor titlePositionDescriptor<br>             = new PropertyDescriptor(“titlePosition”, ChartBean.class);<br>          titlePositionDescriptor.setPropertyEditorClass(TitlePositionEditor.class);  </p>
<p>//②将InverseEditor绑定到ChartBean的inverse属性中<br>PropertyDescriptor inverseDescriptor<br>             = new PropertyDescriptor(“inverse”, ChartBean.class);<br>          inverseDescriptor.setPropertyEditorClass(InverseEditor.class);<br>          return new PropertyDescriptor[]{titlePositionDescriptor, inverseDescriptor};<br>       }<br>       catch (IntrospectionException e){<br>          e.printStackTrace();<br>          return null;<br>       }<br>    }<br> }  </p>
<p>在ChartBeanBeanInfo中，我们分别为ChartBean和titlePosition和inverse属性指定对应的属性编辑器。将ChartBean连同属性编辑器以及ChartBeanBeanInfo打成JAR包，使用IDE组件扩展管理功能注册到IDE中。这样，我们就可以像使用TextField、Checkbox等这些组对ChartBean进行可视化的开发设计工作了。下面是ChartBean在NetBeans IDE中的属性编辑器效果图，如图5-5所示。 </p>
<p>ChartBean可设置的属性都列在属性查看器中，当单击titlePosition属性时，下拉框中列出了我们提供的3个选项。 </p>
<p>Spring默认属性编辑器 </p>
<p>Spring的属性编辑器和传统的用于IDE开发时的属性编辑器不同，它们没有UI界面，仅负责将配置文件中的文本配置值转换为Bean属性的对应值，所以Spring的属性编辑器并非传统意义上的JavaBean属性编辑器。 </p>
<p>Spring为常见的属性类型提供了默认的属性编辑器。从图5-4中，我们可以看出BeanWrapperImpl类扩展了PropertyEditorRegistrySupport类，Spring在PropertyEditor RegistrySupport中为常见属性类型提供了默认的属性编辑器，这些“常见的类型”共32个，可分为3大类，总结如下： </p>
<p>表5-1  Spring提供的默认属性编辑器<br>类    别  说    明<br>基础数据类型  分为几个小类： 1）基本数据类型，如：boolean、byte、short、int等； 2）基本数据类型封装类，如：Long、Character、Integer等；  3）两个基本数据类型的数组，char[]和byte[]；    4）大数类，BigDecimal和BigInteger<br>集合类 为5种类型的集合类Collection、Set、SortedSet、List和SortedMap提供了编辑器<br>资源类 用于访问外部资源的8个常见类Class、Class[]、File、InputStream、Locale、Properties、Resource[]和URL   </p>
<p>PropertyEditorRegistrySupport中有两个用于保存属性编辑器的Map类型变量：<br>  defaultEditors：用于保存默认属性类型的编辑器，元素的键为属性类型，值为对应的属性编辑器实例；<br>  customEditors：用于保存用户自定义的属性编辑器，元素的键值和defaultEditors相同。</p>
<p>PropertyEditorRegistrySupport通过类似以下的代码定义默认属性编辑器：<br>Java代码  收藏代码<br>this.defaultEditors.put(char.class, new CharacterEditor(false));<br>this.defaultEditors.put(Character.class, new CharacterEditor(true));<br>this.defaultEditors.put(Locale.class, new LocaleEditor());<br>this.defaultEditors.put(Properties.class, new PropertiesEditor());  </p>
<p>这些默认的属性编辑器解决常见属性类型的注册问题，如果用户的应用包括一些特殊类型的属性，且希望在配置文件中以字面值提供配置值，那么就需要编写自定义属性编辑器并注册到Spring容器中。这样，Spring才能将配置文件中的属性配置值转换为对应的属性类型值。 </p>
<p>自定义属性编辑器 </p>
<p>Spring大部分默认属性编辑器都直接扩展于java.beans.PropertyEditorSupport类，用户也可以通过扩展PropertyEditorSupport实现自己的属性编辑器。比起用于IDE环境的属性编辑器来说，Spring环境下使用的属性编辑器的功能非常单一：仅需要将配置文件中字面值转换为属性类型的对象即可，并不需要提供UI界面，因此仅需要简单覆盖PropertyEditorSupport的setAsText()方法就可以了。 </p>
<p>一个实例 </p>
<p>我们继续使用第4章中Boss和Car的例子，假设我们现在希望在配置Boss时，不通过引用Bean的方式注入Boss的car属性，而希望直接通过字符串字面值提供配置。为了方便阅读，这里再次列出Boss和Car类的简要代码： </p>
<p>代码清单5-5  Car<br>Java代码  收藏代码<br>package com.baobaotao.editor;<br>public class Car {<br>    private int maxSpeed;<br>    public String brand;<br>    private double price;<br>    //省略get/setter<br>}  </p>
<p>代码清单5-6  Boss<br>Java代码  收藏代码<br>package com.baobaotao.editor;<br>public class Boss {<br>    private String name;<br>    private Car car = new Car();<br>    //省略get/setter<br>}  </p>
<p>Boss有两个属性：name和car，分别对应String类型和Car类型。Spring拥有String类型的默认属性编辑器，因此对于String类型的属性我们不用操心。但Car类型是我们自定义的类型，要配置Boss的car属性，有两种方案：<br>1）在配置文件中为car专门配置一个<bean>，然后在boss的<bean>中通过ref引用car Bean，这正是我们上一章中所用的方法；<br>2）为Car类型提供一个自定义的属性编辑器，这样，我们就通过字面值为Boss的car属性提供配置值。</bean></bean></p>
<p>第一种方案是常用的方法，但是在有些情况下，这种方式需要将属性对象一步步肢解为最终可以用基本类型表示的Bean，使配置文件变得不够清晰，直接为属性类提供一个对应的自定义属性编辑器可能会是更好的替代方案。 </p>
<p>现在，我们来为Car编写一个自定义的属性编辑器，其代码如下所示： </p>
<p>代码清单5-7  CustomCarEditor<br>Java代码  收藏代码<br>package com.baobaotao.editor;<br>import java.beans.PropertyEditorSupport;  </p>
<p>public class CustomCarEditor extends PropertyEditorSupport {  </p>
<pre><code>//①将字面值转换为属性类型对象  
public void setAsText(String text){   
    if(text == null || text.indexOf(&quot;,&quot;) == -1){  
        throw new IllegalArgumentException(&quot;设置的字符串格式不正确&quot;);  
    }  
    String[] infos = text.split(&quot;,&quot;);  
    Car car = new Car();  
    car.setBrand(infos[0]);  
    car.setMaxSpeed(Integer.parseInt(infos[1]));  
    car.setPrice(Double.parseDouble(infos[2]));  

     //②调用父类的setValue()方法设置转换后的属性对象  
    setValue(car);   
}  
</code></pre><p>}  </p>
<p>CustomCarEditor很简单，它仅覆盖PropertyEditorSupport便利类的setAsText(String text)方法，该方法负责将配置文件以字符串提供的字面值转换为Car对象。字面值采用逗号分隔的格式同时为brand、maxSpeed和price属性值提供设置值，setAsText()方法解析这个字面值并生成对应的Car对象。由于我们并不需要将Boss内部的car属性反显到属性编辑器中，因此不需要覆盖getAsText()方法。 </p>
<p>注册自定义的属性编辑器 </p>
<p>在IDE环境下，自定义属性编辑器在使用之前必须通过扩展组件功能进行注册，在Spring环境中也需要通过一定的方法注册自定义的属性编辑器。 </p>
<p>如果使用BeanFactory，用户需要手工调用registerCustomEditor(Class requiredType, PropertyEditor propertyEditor)方法注册自定义属性编辑器；如果使用ApplicationContext，则只需要在配置文件通过CustomEditorConfigurer注册就可以了。CustomEditorConfigurer实现BeanFactoryPostProcessor接口，因此是一个Bean工厂后处理器。我们知道Bean工厂后处理器在Spring容器加载配置文件并生成BeanDefinition半成品后就会被自动执行。因此CustomEditorConfigurer有容器启动时有机会注入自定义的属性编辑器。下面的配置片断定义了一个CustomEditorConfigurer： </p>
<p>Xml代码  收藏代码<br><!--①配置自动注册属性编辑器的CustomEditorConfigurer -->  </p>
<bean class="org.springframework.beans.factory.config.CustomEditorConfigurer"><br>        <property name="customEditors"><br>            <map><br>                   <!--②-1属性编辑器对应的属性类型--><br>                   <entry key="com.baobaotao.editor.Car"><br><br>                         <!--②-2对应的属性编辑器Bean --><br>                    <bean class="com.baobaotao.editor.CustomCarEditor"><br>                </bean></entry><br>            </map><br>        </property><br>    </bean><br> <bean id="boss" class="com.baobaotao.editor.Boss"><br>       <property name="name" value="John"><br>       <!--③该属性将使用②处的属性编辑器完成属性填充操作--><br>       <property name="car" value="红旗CA72,200,20000.00"><br></property></property></bean>  


<p>在①处，我们定义了用于注册自定义属性编辑器的CustomEditorConfigurer，Spring容器将通过反射机制自动调用这个Bean。CustomEditorConfigurer通过一个Map属性定义需要自动注册的自定义属性编辑器。在②处，我们为Car类型指定了对应属性编辑器CustomCarEditor，注意键是属性类型，而值是对应的属性编辑器Bean，而不是属性编辑器的类名。 </p>
<p>最精彩的部分当然是③处的配置，我们原来通过一个<bean>元素标签配置好car Bean，然后在boss的<bean>中通过ref引用car Bean，但是现在我们直接通过value为car属性提供配置。BeanWrapper在设置boss的car属性时，它将检索自定义属性编辑器的注册表，当发现Car属性类型拥有对应的属性编辑器CustomCarEditor时，它就会利用CustomCarEditor将“红旗CA72,200,20000.00”转换为Car对象。 </bean></bean></p>
<p>引用<br>按照JavaBeans的规范，JavaBeans的基础设施会在JavaBean相同类包下查找是否存在<javabean>Editor的类，如果存在，自动使用<javabean>Editor作为该JavaBean的PropertyEditor。<br>如com.baobaotao.domain.UserEditor会自动成为com.baobaotao.domain.User对应的PropertyEditor。Spring也支持这个规范，也即如果采用这种规约命令PropertyEditor，就无须显式在CustomEditorConfigurer中注册了，Spring将自动查找并注册这个PropertyEditor。</javabean></javabean></p>
<p>另：Spring 3.0除支持PropertyEditor外，还在核心包中引入了自建的ConversionService,它提供了更为强大的类型转换的能力，可以完成任意类型之间的转换，还可以在转换过程中参考目标对象所在宿主类的上下文信息。Spring的类型转换同时支持PropertyEdito和ConversionService。 </p>
]]></content>
    
    <summary type="html">
    
      学习Spring必学的Java基础知识----PropertyEditor
    
    </summary>
    
      <category term="spring" scheme="http://jishusuishouji.github.io/categories/spring/"/>
    
    
      <category term="spring" scheme="http://jishusuishouji.github.io/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>探秘Spring的PropertyEditor</title>
    <link href="http://jishusuishouji.github.io/2017/04/18/spring/%E6%8E%A2%E7%A7%98Spring%E7%9A%84PropertyEditor/"/>
    <id>http://jishusuishouji.github.io/2017/04/18/spring/探秘Spring的PropertyEditor/</id>
    <published>2017-04-18T14:03:18.000Z</published>
    <updated>2017-04-18T15:27:13.808Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.beans.PropertyEditor</code>是JDK自带的类，是提供给AWT。</p>
<p>Spring利用该接口来实现Bean的属性转换器。</p>
<p>Spring xml配置的bean属性都是字符串类型的值，但是对应到的每个具体的属性是各种类型的，Spring通过各种<code>PropertyEditor</code>来对各个属性进行类型转换。</p>
<p>Spring并不是直接实现<code>PropertyEditor</code>接口，而是继承<code>PropertyEditorSupport</code>类。</p>
<h2 id="PropertyEditorRegistry"><a href="#PropertyEditorRegistry" class="headerlink" title="PropertyEditorRegistry"></a><code>PropertyEditorRegistry</code></h2><p><code>BeanWrapperImpl</code>是<code>PropertyEditorRegistrySupport</code>的子类。<br><code>PropertyEditorRegistry</code>是一个接口，<code>PropertyEditorRegistrySupport</code>是它的实现类。<br><code>PropertyEditorRegistrySupport</code>中的方法<code>createDefaultEditors</code>，该方法初始化Spring中默认<code>PropertyEditor</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Actually register the default editors for this registry instance.</div><div class="line"> */</div><div class="line">private void createDefaultEditors() &#123;</div><div class="line">    this.defaultEditors = new HashMap&lt;&gt;(64);</div><div class="line"></div><div class="line">    // Simple editors, without parameterization capabilities.</div><div class="line">    // The JDK does not contain a default editor for any of these target types.</div><div class="line">    this.defaultEditors.put(Charset.class, new CharsetEditor());</div><div class="line">    this.defaultEditors.put(Class.class, new ClassEditor());</div><div class="line">    this.defaultEditors.put(Class[].class, new ClassArrayEditor());</div><div class="line">    this.defaultEditors.put(Currency.class, new CurrencyEditor());</div><div class="line">    this.defaultEditors.put(File.class, new FileEditor());</div><div class="line">    this.defaultEditors.put(InputStream.class, new InputStreamEditor());</div><div class="line">    this.defaultEditors.put(InputSource.class, new InputSourceEditor());</div><div class="line">    this.defaultEditors.put(Locale.class, new LocaleEditor());</div><div class="line">    this.defaultEditors.put(Path.class, new PathEditor());</div><div class="line">    this.defaultEditors.put(Pattern.class, new PatternEditor());</div><div class="line">    this.defaultEditors.put(Properties.class, new PropertiesEditor());</div><div class="line">    this.defaultEditors.put(Reader.class, new ReaderEditor());</div><div class="line">    this.defaultEditors.put(Resource[].class, new ResourceArrayPropertyEditor());</div><div class="line">    this.defaultEditors.put(TimeZone.class, new TimeZoneEditor());</div><div class="line">    this.defaultEditors.put(URI.class, new URIEditor());</div><div class="line">    this.defaultEditors.put(URL.class, new URLEditor());</div><div class="line">    this.defaultEditors.put(UUID.class, new UUIDEditor());</div><div class="line">    this.defaultEditors.put(ZoneId.class, new ZoneIdEditor());</div><div class="line"></div><div class="line">    // Default instances of collection editors.</div><div class="line">    // Can be overridden by registering custom instances of those as custom editors.</div><div class="line">    this.defaultEditors.put(Collection.class, new CustomCollectionEditor(Collection.class));</div><div class="line">    this.defaultEditors.put(Set.class, new CustomCollectionEditor(Set.class));</div><div class="line">    this.defaultEditors.put(SortedSet.class, new CustomCollectionEditor(SortedSet.class));</div><div class="line">    this.defaultEditors.put(List.class, new CustomCollectionEditor(List.class));</div><div class="line">    this.defaultEditors.put(SortedMap.class, new CustomMapEditor(SortedMap.class));</div><div class="line"></div><div class="line">    // Default editors for primitive arrays.</div><div class="line">    this.defaultEditors.put(byte[].class, new ByteArrayPropertyEditor());</div><div class="line">    this.defaultEditors.put(char[].class, new CharArrayPropertyEditor());</div><div class="line"></div><div class="line">    // The JDK does not contain a default editor for char!</div><div class="line">    this.defaultEditors.put(char.class, new CharacterEditor(false));</div><div class="line">    this.defaultEditors.put(Character.class, new CharacterEditor(true));</div><div class="line"></div><div class="line">    // Spring&apos;s CustomBooleanEditor accepts more flag values than the JDK&apos;s default editor.</div><div class="line">    this.defaultEditors.put(boolean.class, new CustomBooleanEditor(false));</div><div class="line">    this.defaultEditors.put(Boolean.class, new CustomBooleanEditor(true));</div><div class="line"></div><div class="line">    // The JDK does not contain default editors for number wrapper types!</div><div class="line">    // Override JDK primitive number editors with our own CustomNumberEditor.</div><div class="line">    this.defaultEditors.put(byte.class, new CustomNumberEditor(Byte.class, false));</div><div class="line">    this.defaultEditors.put(Byte.class, new CustomNumberEditor(Byte.class, true));</div><div class="line">    this.defaultEditors.put(short.class, new CustomNumberEditor(Short.class, false));</div><div class="line">    this.defaultEditors.put(Short.class, new CustomNumberEditor(Short.class, true));</div><div class="line">    this.defaultEditors.put(int.class, new CustomNumberEditor(Integer.class, false));</div><div class="line">    this.defaultEditors.put(Integer.class, new CustomNumberEditor(Integer.class, true));</div><div class="line">    this.defaultEditors.put(long.class, new CustomNumberEditor(Long.class, false));</div><div class="line">    this.defaultEditors.put(Long.class, new CustomNumberEditor(Long.class, true));</div><div class="line">    this.defaultEditors.put(float.class, new CustomNumberEditor(Float.class, false));</div><div class="line">    this.defaultEditors.put(Float.class, new CustomNumberEditor(Float.class, true));</div><div class="line">    this.defaultEditors.put(double.class, new CustomNumberEditor(Double.class, false));</div><div class="line">    this.defaultEditors.put(Double.class, new CustomNumberEditor(Double.class, true));</div><div class="line">    this.defaultEditors.put(BigDecimal.class, new CustomNumberEditor(BigDecimal.class, true));</div><div class="line">    this.defaultEditors.put(BigInteger.class, new CustomNumberEditor(BigInteger.class, true));</div><div class="line"></div><div class="line">    // Only register config value editors if explicitly requested.</div><div class="line">    if (this.configValueEditorsActive) &#123;</div><div class="line">        StringArrayPropertyEditor sae = new StringArrayPropertyEditor();</div><div class="line">        this.defaultEditors.put(String[].class, sae);</div><div class="line">        this.defaultEditors.put(short[].class, sae);</div><div class="line">        this.defaultEditors.put(int[].class, sae);</div><div class="line">        this.defaultEditors.put(long[].class, sae);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能上面能够转换的类型还不能满足需求，那么可以通过另一种方式将<code>PropertyEditor</code>注入到Spring中。</p>
<h2 id="PropertyEditorRegistrar"><a href="#PropertyEditorRegistrar" class="headerlink" title="PropertyEditorRegistrar"></a><code>PropertyEditorRegistrar</code></h2><p>该接口只有一个方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void registerCustomEditors(PropertyEditorRegistry registry)</div></pre></td></tr></table></figure></p>
<p>实现该方法就可以往传入的registry添加自定义的<code>PropertyEditor</code>，一般情况下传入的registry是<code>BeanWrapperImpl</code>的实例，即将自定义的<code>PropertyEditor</code>注入到<code>BeanWrapperImpl</code>。</p>
<h2 id="CustomEditorConfigurer"><a href="#CustomEditorConfigurer" class="headerlink" title="CustomEditorConfigurer"></a><code>CustomEditorConfigurer</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</div><div class="line">    if (this.propertyEditorRegistrars != null) &#123;</div><div class="line">        for (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) &#123;</div><div class="line">            beanFactory.addPropertyEditorRegistrar(propertyEditorRegistrar);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把<code>PropertyEditorRegistrar</code>添加到<code>BeanFactory</code>。</p>
<p>它是实现了<code>BeanFactoryPostProcessor</code>接口，即在构造完<code>BeanDefinition</code>之后会调用方法<code>postProcessBeanFactory</code>。</p>
<p>注入一个<code>CustomEditorConfigurerBean</code>(设置<code>propertyEditorRegistrars</code>和<code>customEditors属性</code>)就可以将自定义的<code>PropertyEditor</code>注入到Spring中了。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="自定义PropertyEditor"><a href="#自定义PropertyEditor" class="headerlink" title="自定义PropertyEditor"></a>自定义<code>PropertyEditor</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class CustomPropertyEditor extends PropertyEditorSupport &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setAsText(String text) throws IllegalArgumentException &#123;</div><div class="line">        super.setAsText(text);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object getValue() &#123;</div><div class="line">        return super.getValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="将这个PropertyEditor注入到Spring里面中"><a href="#将这个PropertyEditor注入到Spring里面中" class="headerlink" title="将这个PropertyEditor注入到Spring里面中"></a>将这个<code>PropertyEditor</code>注入到Spring里面中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt;</div><div class="line">    &lt;property name=&quot;customEditors&quot;&gt;</div><div class="line">        &lt;map&gt;</div><div class="line">            &lt;entry key=&quot;com.xx.foo.FooPojo&quot; value=&quot;com.xx.foo.CustomPropertyEditor&quot;/&gt;</div><div class="line">        &lt;/map&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h2 id="ClassEditor的实现"><a href="#ClassEditor的实现" class="headerlink" title="ClassEditor的实现"></a><code>ClassEditor</code>的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class ClassEditor extends PropertyEditorSupport &#123;</div><div class="line"></div><div class="line">    private final ClassLoader classLoader;</div><div class="line">    public ClassEditor() &#123;</div><div class="line">        this(null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ClassEditor(ClassLoader classLoader) &#123;</div><div class="line">        this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAsText(String text) throws IllegalArgumentException &#123;</div><div class="line">        if (StringUtils.hasText(text)) &#123;</div><div class="line">            setValue(ClassUtils.resolveClassName(text.trim(), this.classLoader));</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            setValue(null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String getAsText() &#123;</div><div class="line">        Class clazz = (Class) getValue();</div><div class="line">        if (clazz != null) &#123;</div><div class="line">            return ClassUtils.getQualifiedName(clazz);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            return &quot;&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      探秘Spring的PropertyEditor
    
    </summary>
    
      <category term="Spring" scheme="http://jishusuishouji.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://jishusuishouji.github.io/tags/Spring/"/>
    
      <category term="PropertyEditor" scheme="http://jishusuishouji.github.io/tags/PropertyEditor/"/>
    
  </entry>
  
  <entry>
    <title>ServletContext总结</title>
    <link href="http://jishusuishouji.github.io/2017/04/17/ServletContext%E6%80%BB%E7%BB%93.md/ServletContext%E6%80%BB%E7%BB%93/"/>
    <id>http://jishusuishouji.github.io/2017/04/17/ServletContext总结.md/ServletContext总结/</id>
    <published>2017-04-17T14:23:11.000Z</published>
    <updated>2017-04-17T14:23:11.349Z</updated>
    
    <summary type="html">
    
      ServletContext总结
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于Keepalived+Haproxy搭建四层负载均衡器</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/jiqun/%E5%9F%BA%E4%BA%8EKeepalived_Haproxy%E6%90%AD%E5%BB%BA%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/jiqun/基于Keepalived_Haproxy搭建四层负载均衡器/</id>
    <published>2017-04-07T05:07:53.000Z</published>
    <updated>2017-04-07T05:13:34.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Haproxy是稳定、高性能、高可用性的负载均衡解决方案，支持HTTP及TCP代理后端服务器池，因支持强大灵活的7层acl规则，广泛作为HTTP反向代理。本文则详细介绍如何利用它的四层交换与Keepalived实现一个负载均衡器，适用于Socket、ICE、mail、mysql、私有通讯等任意TCP服务。系统架构图如下：</p>
<p>点击在新窗口中浏览此图片</p>
<p>二、平台环境</p>
<p>OS:Centos5.4(64X)<br>MASTER:192.168.0.20<br>BACKUP:192.168.0.21<br>VIP:192.168.0.100<br>Serivce Port:11231<br>三、平台安装配置</p>
<p>1、添加非本机ip邦定支持</p>
<p>#vi /etc/sysctl.conf<br>net.ipv4.ip_nonlocal_bind=1</p>
<p>#sysctl –p<br>2、配置平台日志支持</p>
<p>#vi /etc/syslog.conf<br>添加：<br>local3.<em>        /var/log/haproxy.log<br>local0.</em>        /var/log/haproxy.log</p>
<p>#vi /etc/sysconfig/syslog<br>修改：<br>SYSLOGD_OPTIONS=”-r -m 0”</p>
<p>#/etc/init.d/syslog restart<br>3、关闭SELINUX</p>
<p>vi /etc/sysconfig/selinux<br>修改：<br>SELINUX=disabled</p>
<p>#setenforce 0<br>4、配置iptables，添加VRRP通讯支持</p>
<p>iptables -A INPUT -d 224.0.0.18 -j accept<br>5、Keepalived的安装、配置</p>
<p>#mkdir -p /home/install/keepalivedha</p>
<p>#cd /home/install/keepalivedha</p>
<p>#wget <a href="http://www.keepalived.org/software/keepalived-1.2.2.tar.gz" target="_blank" rel="external">http://www.keepalived.org/software/keepalived-1.2.2.tar.gz</a></p>
<p>#tar zxvf keepalived-1.2.2.tar.gz</p>
<p>#cd keepalived-1.2.2</p>
<p>#./configure</p>
<p>#make &amp;&amp; make install</p>
<p>#cp /usr/local/etc/rc.d/init.d/keepalived /etc/rc.d/init.d/</p>
<p>#cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/</p>
<p>#mkdir /etc/keepalived</p>
<p>#cp /usr/local/etc/keepalived/keepalived.conf /etc/keepalived/</p>
<p>#cp /usr/local/sbin/keepalived /usr/sbin/</p>
<p>#vi /etc/keepalived/keepalived.conf</p>
<p>! Configuration file for keepalived  </p>
<p>global_defs {<br>   notification_email {<br>         liutiansi@gmail.com<br>   }<br>   notification_email_from liutiansi@gmail.com<br>   smtp_connect_timeout 3<br>   smtp_server 127.0.0.1<br>   router_id LVS_DEVEL<br>}<br>vrrp_script chk_haproxy {<br>    script “killall -0 haproxy”<br>    interval 2<br>    weight 2<br>}<br>vrrp_instance VI_1 {<br>    interface eth1<br>    state MASTER # 从为BACKUP<br>    priority 101 # 从为100<br>    virtual_router_id 50 #路由ID，可通过#tcpdump vrrp查看。<br>    garp_master_delay 1 #主从切换时间，单位为秒。  </p>
<pre><code>authentication {  
    auth_type PASS  
    auth_pass KJj23576hYgu23IP  
}  
track_interface {  
   eth0  
   eth1  
}  
virtual_ipaddress {  
    192.168.0.100  
}  
track_script {  
    chk_haproxy  
}  

#状态通知  
notify_master &quot;/etc/keepalived/Mailnotify.py master&quot;  
notify_backup &quot;/etc/keepalived/Mailnotify.py backup&quot;  
notify_fault &quot;/etc/keepalived/Mailnotify.py fault&quot;  
</code></pre><p>}<br>6、Haproxy的安装与配置</p>
<p>#cd /home/install/keepalivedha</p>
<p>#wget <a href="http://haproxy.1wt.eu/download/1.4/src/haproxy-1.4.11.tar.gz" target="_blank" rel="external">http://haproxy.1wt.eu/download/1.4/src/haproxy-1.4.11.tar.gz</a></p>
<p>#tar -zxvf haproxy-1.4.11.tar.gz</p>
<p>#cd haproxy-1.4.11</p>
<p>#make install</p>
<p>#mkdir -p /usr/local/haproxy/etc</p>
<p>#mkdir -p /usr/local/haproxy/sbin</p>
<p>#cp examples/haproxy.cfg /usr/local/haproxy/etc</p>
<p>#ln -s /usr/local/sbin/haproxy /usr/local/haproxy/sbin/haproxy </p>
<p>#vi /usr/local/haproxy/etc/haproxy.cfg</p>
<h1 id="this-config-needs-haproxy-1-1-28-or-haproxy-1-2-1"><a href="#this-config-needs-haproxy-1-1-28-or-haproxy-1-2-1" class="headerlink" title="this config needs haproxy-1.1.28 or haproxy-1.2.1"></a>this config needs haproxy-1.1.28 or haproxy-1.2.1</h1><p>global  </p>
<h1 id="log-127-0-0-1-local0"><a href="#log-127-0-0-1-local0" class="headerlink" title="log 127.0.0.1   local0"></a>log 127.0.0.1   local0</h1><pre><code>log 127.0.0.1   local1 notice  
maxconn 5000  
uid 99  
gid 99  

daemon  
pidfile /usr/local/haproxy/haproxy.pid  
</code></pre><p>defaults<br>        log     global<br>        mode    http  </p>
<pre><code>#option httplog  
 option  dontlognull  
 retries 3  
 option redispatch  
 maxconn 2000  
 contimeout      5000  
 clitimeout      50000  
 srvtimeout      50000  
</code></pre><p>listen  ICE01   192.168.0.100:11231<br>        mode tcp #配置TCP模式<br>        maxconn 2000<br>        balance roundrobin<br>        server  ice-192.168.0.128 192.168.0.128:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.129 192.168.0.129:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.130 192.168.0.130:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.131 192.168.0.131:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.132 192.168.0.132:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.34 192.168.0.34:11231 check inter 5000 fall 1 rise 2<br>        srvtimeout      20000  </p>
<p>listen stats_auth 192.168.0.20:80  </p>
<h1 id="listen-stats-auth-192-168-0-21-80-backup-config"><a href="#listen-stats-auth-192-168-0-21-80-backup-config" class="headerlink" title="listen stats_auth 192.168.0.21:80 # backup config"></a>listen stats_auth 192.168.0.21:80 # backup config</h1><pre><code>stats enable  
stats uri  /admin-status #管理地址  
stats auth  admin:123456 #管理帐号:管理密码  
stats admin if TRUE  
</code></pre><p>7、邮件通知程序(python实现)</p>
<p>#vi /etc/keepalived/Mailnotify.py</p>
<p>#!/usr/local/bin/python  </p>
<p>#coding: utf-8<br>from email.MIMEMultipart import MIMEMultipart<br>from email.MIMEText import MIMEText<br>from email.MIMEImage import MIMEImage<br>from email.header import Header<br>import sys<br>import smtplib  </p>
<p>#—————————————————————  </p>
<h1 id="Name-Mailnotify-py"><a href="#Name-Mailnotify-py" class="headerlink" title="Name:        Mailnotify.py"></a>Name:        Mailnotify.py</h1><h1 id="Purpose-Mail-notify-to-SA"><a href="#Purpose-Mail-notify-to-SA" class="headerlink" title="Purpose:     Mail notify to SA"></a>Purpose:     Mail notify to SA</h1><h1 id="Author-Liutiansi"><a href="#Author-Liutiansi" class="headerlink" title="Author:      Liutiansi"></a>Author:      Liutiansi</h1><h1 id="Email-liutiansi-gamil-com"><a href="#Email-liutiansi-gamil-com" class="headerlink" title="Email:       liutiansi@gamil.com"></a>Email:       liutiansi@gamil.com</h1><h1 id="Created-2011-03-09"><a href="#Created-2011-03-09" class="headerlink" title="Created:     2011/03/09"></a>Created:     2011/03/09</h1><h1 id="Copyright-c-2011"><a href="#Copyright-c-2011" class="headerlink" title="Copyright:   (c) 2011"></a>Copyright:   (c) 2011</h1><p>#————————————————————–<br>strFrom = ‘admin@domain.com’<br>strTo = ‘liutiansi@gmail.com’<br>smtp_server=’smtp.domain.com’<br>smtp_pass=’123456’  </p>
<p>if sys.argv[1]!=”master” and sys.argv[1]!=”backup”  and sys.argv[1]!=”fault”:<br>    sys.exit()<br>else:<br>    notify_type=sys.argv[1]  </p>
<p>mail_title=’[紧急]负载均衡器邮件通知’<br>mail_body_plain=notify_type+’被激活，请做好应急处理。’<br>mail_body_html=’<b><font color="red">‘+notify_type+’被激活，请做好应急处理。</font></b>‘  </p>
<p>msgRoot = MIMEMultipart(‘related’)<br>msgRoot[‘Subject’] =Header(mail_title,’utf-8’)<br>msgRoot[‘From’] = strFrom<br>msgRoot[‘To’] = strTo  </p>
<p>msgAlternative = MIMEMultipart(‘alternative’)<br>msgRoot.attach(msgAlternative)  </p>
<p>msgText = MIMEText(mail_body_plain, ‘plain’, ‘utf-8’)<br>msgAlternative.attach(msgText)  </p>
<p>msgText = MIMEText(mail_body_html, ‘html’,’utf-8’)<br>msgAlternative.attach(msgText)  </p>
<p>smtp = smtplib.SMTP()<br>smtp.connect(smtp_server)<br>smtp.login(smtp_user,smtp_pass)<br>smtp.sendmail(strFrom, strTo, msgRoot.as_string())<br>smtp.quit()<br>注：修改成系统python实际路径“#!/usr/local/bin/python”(第一行)</p>
<p>#chmod +x /etc/keepalived/Mailnotify.py</p>
<p>#/usr/local/haproxy/sbin/haproxy -f /usr/local/haproxy/etc/haproxy.cfg</p>
<p>#service keepalived start<br>8、查看VRRP通讯记录</p>
<p>#tcpdump vrrp<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes<br>15:49:05.270017 IP 192.168.0.20 &gt; VRRP.MCAST.NET: VRRPv2, Advertisement, vrid 50, prio 100, authtype simple, intvl 1s, length 20<br>四、Haproxy界面</p>
<p>访问<a href="http://192.168.0.20/admin-status，输入帐号admin密码123456进入管理监控平台。" target="_blank" rel="external">http://192.168.0.20/admin-status，输入帐号admin密码123456进入管理监控平台。</a></p>
<p>点击在新窗口中浏览此图片</p>
<p>haproxy-1.4.9以后版本最大的亮点是添加了手工启用/禁用功能，对升级变更应用时非常有用。</p>
<p>五、邮件通知</p>
<p>点击在新窗口中浏览此图片</p>
]]></content>
    
    <summary type="html">
    
      基于Keepalived+Haproxy搭建四层负载均衡器
    
    </summary>
    
      <category term="集群" scheme="http://jishusuishouji.github.io/categories/%E9%9B%86%E7%BE%A4/"/>
    
    
      <category term="集群" scheme="http://jishusuishouji.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>nginx+keepalive主从双机热备+自动切换解决方案</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/jiqun/nginx_keepalive%E4%B8%BB%E4%BB%8E%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87_%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/jiqun/nginx_keepalive主从双机热备_自动切换解决方案/</id>
    <published>2017-04-07T04:42:10.000Z</published>
    <updated>2017-04-07T04:50:23.322Z</updated>
    
    <content type="html"><![CDATA[<p>cenots 6.3 64位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y make wget</div></pre></td></tr></table></figure>
<h2 id="1-安装keepalive"><a href="#1-安装keepalive" class="headerlink" title="1.安装keepalive"></a>1.安装keepalive</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar zxvf keepalived-1.2.7.tar.gz</div><div class="line">cd keepalived-1.2.7</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">yum install -y gcc openssl-devel popt-devel</div><div class="line">./configure</div><div class="line">make &amp;&amp; make install </div><div class="line"></div><div class="line">cp /usr/local/etc/rc.d/init.d/keepalived /etc/init.d/</div><div class="line">cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/</div><div class="line">chmod +x /etc/init.d/keepalived</div><div class="line">chkconfig --add keepalived</div><div class="line">chkconfig keepalived on</div><div class="line">mkdir /etc/keepalived</div><div class="line">ln -s /usr/local/sbin/keepalived /usr/sbin/</div></pre></td></tr></table></figure>
<h2 id="2-安装Nginx"><a href="#2-安装Nginx" class="headerlink" title="2.安装Nginx"></a>2.安装Nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar zxvf  nginx-1.2.5.tar.gz</div><div class="line">cd nginx-1.2.5</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum install -y pcre-devel</div><div class="line">./configure --prefix=/usr/local/nginx --user=www --group=www  --with-http_stub_status_module --with-http_ssl_module</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h2 id="3-配置keepalive"><a href="#3-配置keepalive" class="headerlink" title="3.配置keepalive"></a>3.配置keepalive</h2><p>两台服务器端<code>keepalived.conf</code>内容如下，都设置为<code>backup</code>，不抢占，注意修改优先级不同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">! Configuration file for keepalived</div><div class="line">global_defs &#123;</div><div class="line">   notification_email &#123;</div><div class="line">    admin@lvtao.net</div><div class="line">   &#125;</div><div class="line">   notification_email_from admin@lvtao.net</div><div class="line">   smtp_server 127.0.0.1</div><div class="line">   smtp_connect_timeout 30</div><div class="line">   router_id LVS_DEVEL</div><div class="line">&#125;</div><div class="line">#监控服务.NGINX mysql等</div><div class="line">vrrp_script chk_nginx &#123;</div><div class="line">    script &quot;/home/check_nginx.sh&quot;</div><div class="line">    interval 2</div><div class="line">    weight 2</div><div class="line">&#125;</div><div class="line"></div><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    state BACKUP  #主从设置 MASTER</div><div class="line">    interface eth2  #网卡名</div><div class="line">    virtual_router_id 51</div><div class="line">    mcast_src_ip 10.0.1.133 #本机ip</div><div class="line">    priority 50  #从机小于主机</div><div class="line">    advert_int 1</div><div class="line">    authentication &#123;</div><div class="line">        auth_type PASS</div><div class="line">        auth_pass chtopnet</div><div class="line">    &#125;</div><div class="line">    virtual_ipaddress &#123;</div><div class="line">        10.0.1.2  #VIP 的IP</div><div class="line">    &#125;</div><div class="line">    track_script &#123;</div><div class="line">        chk_nginx  #检测脚本</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">virtual_server 10.0.1.2 80 &#123;</div><div class="line">    delay_loop 6</div><div class="line">    lb_algo rr</div><div class="line">    lb_kind DR</div><div class="line">    persistence_timeout 50</div><div class="line">    protocol TCP</div><div class="line"></div><div class="line">    real_server 10.0.1.132 80 &#123;</div><div class="line">        weight 3</div><div class="line">        TCP_CHECK &#123;</div><div class="line">            connect_timeout 10</div><div class="line">            nb_get_retry 3</div><div class="line">            delay_before_retry 3</div><div class="line">            connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    real_server 10.0.1.133 80 &#123;</div><div class="line">        weight 3</div><div class="line">        TCP_CHECK &#123;</div><div class="line">            connect_timeout 10</div><div class="line">            nb_get_retry 3</div><div class="line">            delay_before_retry 3</div><div class="line">            connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动相关服务。我在这儿使用的是nginx ，每个上面开了一个站点，通过IP可以直接访问的。启动keepalive后，就可以通过VIP的虚拟IP 10.0.1.2来访问站点了，测试方法就是 停止任何其中一个站点，看它是否能自动切换到从服务器上。</p>
<p>上面代码中nginx的检测脚本如下 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">if [ &quot;$(ps -ef | grep &quot;nginx: master process&quot;| grep -v grep )&quot; == &quot;&quot; ]</div><div class="line">then</div><div class="line"> /usr/local/nginx/sbin/nginx</div><div class="line"> sleep 5</div><div class="line"> if [ &quot;$(ps -ef | grep &quot;nginx: master process&quot;| grep -v grep )&quot; == &quot;&quot; ]</div><div class="line"> then</div><div class="line">     killall keepalived</div><div class="line"> fi</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<p>在两台Web Server上执行<code>realserver.sh</code>脚本，为lo:0绑定VIP地址10.0.1.2、抑制arp广播。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">#description: Config realserver</div><div class="line"></div><div class="line">VIP=10.0.1.2</div><div class="line"> </div><div class="line">/etc/rc.d/init.d/functions</div><div class="line"> </div><div class="line">case &quot;$1&quot; in</div><div class="line">start)</div><div class="line">       /sbin/ifconfig lo:0 $VIP netmask 255.255.255.255 broadcast $VIP</div><div class="line">       /sbin/route add -host $VIP dev lo:0</div><div class="line">       echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</div><div class="line">       echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</div><div class="line">       echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</div><div class="line">       echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce</div><div class="line">       sysctl -p &gt;/dev/null 2&gt;&amp;1</div><div class="line">       echo &quot;RealServer Start OK&quot;</div><div class="line">       ;;</div><div class="line">stop)</div><div class="line">       /sbin/ifconfig lo:0 down</div><div class="line">       /sbin/route del $VIP &gt;/dev/null 2&gt;&amp;1</div><div class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</div><div class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</div><div class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</div><div class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce</div><div class="line">       echo &quot;RealServer Stoped&quot;</div><div class="line">       ;;</div><div class="line">*)</div><div class="line">       echo &quot;Usage: $0 &#123;start|stop&#125;&quot;</div><div class="line">       exit 1</div><div class="line">esac</div><div class="line"> </div><div class="line">exit 0</div></pre></td></tr></table></figure></p>
<p>分别在主从机上执行<code>sh realserver.sh start</code>就可实现负载均衡及高可用集群了；</p>
<p>keepalive相关参数说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"> ! Configuration File for keepalived</div><div class="line"></div><div class="line">global_defs &#123;</div><div class="line">   notification_email &#123;</div><div class="line">     admin@lvtao.net             #设置报警邮件地址，可以设置多个，每行一个。 需开启本机的sendmail服务</div><div class="line">   &#125;</div><div class="line">   notification_email_from  admin@lvtao.net        #设置邮件的发送地址</div><div class="line">   smtp_server 127.0.0.1                                #设置smtp server地址</div><div class="line">   smtp_connect_timeout 30                              #设置连接smtp server的超时时间</div><div class="line">   router_id LVS_DEVEL                                  #表示运行keepalived服务器的一个标识。发邮件时显示在邮件主题的信息</div><div class="line">&#125;</div><div class="line"></div><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    state MASTER              #指定keepalived的角色，MASTER表示此主机是主服务器，BACKUP表示此主机是备用服务器</div><div class="line">    interface eth0            #指定HA监测网络的接口</div><div class="line">    virtual_router_id 51      #虚拟路由标识，这个标识是一个数字，同一个vrrp实例使用唯一的标识。即同一vrrp_instance下，MASTER和BACKUP必须是一致的</div><div class="line">    priority 100              #定义优先级，数字越大，优先级越高，在同一个vrrp_instance下，MASTER的优先级必须大于BACKUP的优先级</div><div class="line">    advert_int 1              #设定MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒</div><div class="line">    authentication &#123;          #设置验证类型和密码</div><div class="line">        auth_type PASS        #设置验证类型，主要有PASS和AH两种</div><div class="line">        auth_pass 1111        #设置验证密码，在同一个vrrp_instance下，MASTER与BACKUP必须使用相同的密码才能正常通信</div><div class="line">    &#125;</div><div class="line">    virtual_ipaddress &#123;       #设置虚拟IP地址，可以设置多个虚拟IP地址，每行一个</div><div class="line">        10.0.0.148</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">virtual_server 10.0.0.148 80 &#123;      #设置虚拟服务器，需要指定虚拟IP地址和服务端口，IP与端口之间用空格隔开</div><div class="line">    delay_loop 6                    #设置运行情况检查时间，单位是秒</div><div class="line">    lb_algo rr                      #设置负载调度算法，这里设置为rr，即轮询算法</div><div class="line">    lb_kind DR                      #设置LVS实现负载均衡的机制，有NAT、TUN、DR三个模式可选</div><div class="line">    persistence_timeout 50          #会话保持时间，单位是秒。这个选项对动态网页是非常有用的，为集群系统中的session共享提供了一个很好的解决方案。</div><div class="line">                                    #有了这个会话保持功能，用户的请求会被一直分发到某个服务节点，直到超过这个会话的保持时间。</div><div class="line">                                    #需要注意的是，这个会话保持时间是最大无响应超时时间，也就是说，用户在操作动态页面时，如果50秒内没有执行任何操作，</div><div class="line">                                    #那么接下来的操作会被分发到另外的节点，但是如果用户一直在操作动态页面，则不受50秒的时间限制</div><div class="line">    protocol TCP                    #指定转发协议类型，有TCP和UDP两种</div><div class="line"></div><div class="line">    real_server 10.0.0.137 80 &#123;     #配置服务节点1，需要指定real server的真实IP地址和端口，IP与端口之间用空格隔开</div><div class="line">        weight 3                    #配置服务节点的权值，权值大小用数字表示，数字越大，权值越高，设置权值大小可以为不同性能的服务器</div><div class="line">                                    #分配不同的负载，可以为性能高的服务器设置较高的权值，而为性能较低的服务器设置相对较低的权值，这样才能合理地利用和分配系统资源</div><div class="line">        TCP_CHECK &#123;                 #realserver的状态检测设置部分，单位是秒</div><div class="line">            connect_timeout 10      #表示3秒无响应超时</div><div class="line">            nb_get_retry 3          #表示重试次数</div><div class="line">            delay_before_retry 3    #表示重试间隔</div><div class="line">            connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    real_server 10.0.0.139 80 &#123;</div><div class="line">        weight 3</div><div class="line">        TCP_CHECK &#123;</div><div class="line">            connect_timeout 10</div><div class="line">            nb_get_retry 3</div><div class="line">            delay_before_retry 3</div><div class="line">            connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      nginx+keepalive主从双机热备+自动切换解决方案
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>反向代理为何叫反向代理？</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/fangxiangdaili/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%BA%E4%BD%95%E5%8F%AB%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9F/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/fangxiangdaili/反向代理为何叫反向代理？/</id>
    <published>2017-04-07T04:19:19.000Z</published>
    <updated>2017-04-07T04:29:06.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>A同学准备找马云借钱，但是马云不同意；于是他通过马云的亲戚向马云借钱，事情成了。这里马云并不知道钱是谁借的，马云借给了自己的亲戚，亲戚最后转交给A同学。亲戚在这个过程中扮演了代理的角色(正向代理)。如果马云是服务器，大家访问它(跟他借钱)，而马云又不可能随随便便借钱给别人，那么那些马云的亲戚就是正向代理，代理客户端(A同学们)向马云借钱。  </p>
<p>常说的代理也就是指正向代理，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端的都被代理服务器代替来请求。</p>
<p>科学上网工具扮演的就是正向代理角色。</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>拨打10086客服电话，一个地区的10086客服有几个或者几十个，你拨通了10086的总机号码，电话那头总会有人会回答你。这里的10086总机号码就是起了反向代理的作用。客户并不知道真正提供服务人的是谁。</p>
<p>反向代理隐藏了真实的服务端。</p>
<h2 id="正向代理和反向代理的区别"><a href="#正向代理和反向代理的区别" class="headerlink" title="正向代理和反向代理的区别"></a>正向代理和反向代理的区别</h2><p>正向代理代理的对象是客户端，反向代理代理的对象是服务端</p>
]]></content>
    
    <summary type="html">
    
      反向代理为何叫反向代理？
    
    </summary>
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/categories/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>反向代理</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/jiqun/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/jiqun/反向代理/</id>
    <published>2017-04-07T03:55:17.000Z</published>
    <updated>2017-04-07T04:18:22.553Z</updated>
    
    <content type="html"><![CDATA[<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><h3 id="通常的代理服务器-内部网络对Internet的连接请求"><a href="#通常的代理服务器-内部网络对Internet的连接请求" class="headerlink" title="通常的代理服务器(内部网络对Internet的连接请求)"></a>通常的代理服务器(内部网络对Internet的连接请求)</h3><p>通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>外部网络上的主机并不会配置并使用这个代理服务器，普通代理服务器也被设计为在Internet上搜寻多个不确定的服务器,而不是针对客户机的请求访问某一个固定的服务器，因此普通的Web代理服务器不支持外部对内部网络的访问请求。</p>
<h3 id="方向代理服务器"><a href="#方向代理服务器" class="headerlink" title="方向代理服务器"></a>方向代理服务器</h3><p>当一个代理服务器代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。此时代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个标准的Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者CGI程序，都保存在内部的Web服务器上。因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了Web服务器的安全性。</p>
<p>反向代理方式和包过滤方式或普通代理方式并无冲突，因此可以在防火墙设备中同时使用这两种方式，其中反向代理用于外部网络访问内部网络时使用，正向代理或包过滤方式用于拒绝其他外部访问方式并提供内部网络对外部网络的访问能力。因此可以结合这些方式提供最佳的安全访问方式。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输得更快、更稳定。通过在网络各处放置反向代理服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>如果您的内容服务器具有必须保持安全的敏感信息，如信用卡号数据库，可在防火墙外部设置一个代理服务器作为内容服务器的替身。当外部客户机尝试访问内容服务器时，会将其送到代理服务器。实际内容位于内容服务器上，在内部受到防火墙安全保护。代理服务器位于防火墙外部，在外部客户机看来就像是内容服务器。<br>当客户机向站点提出请求时，请求将转到代理服务器。然后，代理服务器通过防火墙中的特定通路，将客户机的请求发送到内容服务器。内容服务器再通过该通道将结果回传给代理服务器。代理服务器将检索到的信息发送给客户机，好像代理服务器就是实际的内容服务器。如果内容服务器返回错误消息，代理服务器会先行截取该消息并更改标头中列出的任何URL，然后再将消息发送给客户机。如此可防止外部客户机获取内部内容服务器的重定向URL。<br>这样，代理服务器就在安全数据库和可能的恶意攻击之间提供了又一道屏障。与有权访问整个数据库的情况相对比，就算是侥幸攻击成功，作恶者充其量也仅限于访问单个事务中所涉及的信息。未经授权的用户无法访问到真正的内容服务器，因为防火墙通路只允许代理服务器有权进行访问。<br><img src="/img/反向代理服务器就像是真正的内容服务器.jpg" alt="图1 反向代理服务器就像是真正的内容服务器"></p>
<p>可以配置防火墙路由器，使其只允许特定端口上的特定服务器有权通过防火墙进行访问，而不允许其他任何机器进出。</p>
<h2 id="安全反向代理"><a href="#安全反向代理" class="headerlink" title="安全反向代理"></a>安全反向代理</h2><p>当代理服务器与其他机器之间有一个或多个连接使用安全套接字层(SSL) 协议加密数据时，即会进行安全反向代理。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>可以提供从防火墙外部代理服务器到防火墙内部安全内容服务器的加密连接。<br>可以允许客户机安全地连接到代理服务器，从而有利于安全地传输信息（如信用卡号）。<br>安全反向代理会造成各安全连接因加密数据所涉及的系统开销而变慢。但是，由于 SSL 提供了高速缓存机制，所以连接双方可以重复使用先前协商的安全参数，从而大大降低后续连接的系统开销。</p>
<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>配置安全反向代理服务器的方法有三种：</p>
<h3 id="Secure-client-to-proxy"><a href="#Secure-client-to-proxy" class="headerlink" title="Secure client to proxy"></a>Secure client to proxy</h3><p>如果未经授权的用户很少或根本没有机会访问代理服务器与内容服务器之间交换的信息，则此方案很有效。<br><img src="/img/图 2 客户机安全连接到代理服务器.jpg" alt="图 2 客户机安全连接到代理服务器"></p>
<h3 id="Secure-proxy-to-content-server"><a href="#Secure-proxy-to-content-server" class="headerlink" title="Secure proxy to content server"></a>Secure proxy to content server</h3><p>如果客户机在防火墙外部而内容服务器在防火墙内部，则此方案很有效。在此方案中，代理服务器可以充当站点之间的安全通道<br><img src="/img/图 3 代理服务器安全连接到内容服务器.jpg" alt="图 3 代理服务器安全连接到内容服务器"></p>
<h3 id="Secure-client-to-proxy-and-secure-proxy-to-content-server"><a href="#Secure-client-to-proxy-and-secure-proxy-to-content-server" class="headerlink" title="Secure client to proxy and secure proxy to content server"></a>Secure client to proxy and secure proxy to content server</h3><p>如果需要保护服务器、代理服务器和客户机三者间所交换信息的安全，则此方案很有效。在此方案中，代理服务器既可起到站点间安全通道的作用，又可增加客户机验证的安全性。<br><img src="/img/Secure client to proxy and secure proxy to content server.jpg" alt="图 4 客户机安全连接到代理服务器并且代理服务器安全连接到内容服务器"></p>
<p>除了SSL之外，代理服务器还可以使用客户机验证，这种方法要求向代理服务器提出请求的计算机提供证书（或标识表单）以核实其身份。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="标准的代理缓冲服务器"><a href="#标准的代理缓冲服务器" class="headerlink" title="标准的代理缓冲服务器"></a>标准的代理缓冲服务器</h3><p>一个标准的代理缓冲服务被用于缓存静态的网页（例如：html文件和图片文件等）到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指明代理服务器的IP地址和端口号。客户端上网时，每次都把请求送给代理服务器处理，代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发给客户端浏览器。</p>
<h3 id="透明代理缓冲服务器"><a href="#透明代理缓冲服务器" class="headerlink" title="透明代理缓冲服务器"></a>透明代理缓冲服务器</h3><p>透明代理缓冲服务和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于Linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因为不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。</p>
<h3 id="反向代理缓冲服务器"><a href="#反向代理缓冲服务器" class="headerlink" title="反向代理缓冲服务器"></a>反向代理缓冲服务器</h3><p>反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于本地WEB服务器和Internet之间，处理所有对WEB服务器的请求，阻止了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发送给用户。这种方式通过降低了向WEB服务器的请求数从而降低了WEB服务器的负载。</p>
]]></content>
    
    <summary type="html">
    
      反向代理
    
    </summary>
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/categories/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Nginx/LVS/HAProxy负载均衡软件的优缺点详解</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/fuzaijunheng/Nginx_LVS_HAProxy%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/fuzaijunheng/Nginx_LVS_HAProxy负载均衡软件的优缺点详解/</id>
    <published>2017-04-07T03:42:08.000Z</published>
    <updated>2017-04-07T04:40:13.638Z</updated>
    
    <content type="html"><![CDATA[<p>根据网站规模不同使用不同的技术。中小型的Web应用(日PV小于1000万,平均下来一秒也就处理一百多个请求)用Nginx就可以了；如果机器不少，可以用DNS轮询，LVS需要的机器比较多；大型网站或重要的服务，且服务器比较多时，可以考虑用LVS。</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>F5和Array等商用的负载均衡器</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>有专业的维护团队进行维护</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>花销太大</p>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>Nginx/LVS/HAProxy等基于Linux的开源免费的负载均衡软件，通过软件级别来实现，费用非常低廉。</p>
<h2 id="合理流行的架构方案"><a href="#合理流行的架构方案" class="headerlink" title="合理流行的架构方案"></a>合理流行的架构方案</h2><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><p>Nginx/HAProxy+Keepalived作负载均衡器</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>MySQL数据库一主多从和读写分离，采用LVS+Keepalived的架构。</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>1、工作在网络协议的第7层，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。<br>2、Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大；<br>3、Nginx安装和配置比较简单，测试起来比较方便，日志功能很强大。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。<br>3、可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。<br>4、Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。<br>5、Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。<br>6、Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。<br>7、Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有lighttpd了，不过lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。<br>8、Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。</p>
<p>淘宝的前端使用的Tengine就是基于nginx做的二次开发定制版。</p>
<p>Nginx常规的HTTP请求和响应流程图：</p>
<p>nginx</p>
<h3 id="Nginx的缺点是："><a href="#Nginx的缺点是：" class="headerlink" title="Nginx的缺点是："></a>Nginx的缺点是：</h3><p>1、Nginx仅支持http、https和Email协议，适用范围比较小。<br>2、对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过<code>ip_hash</code>来解决。</p>
<h2 id="二、LVS"><a href="#二、LVS" class="headerlink" title="二、LVS"></a>二、LVS</h2><p>使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>1、抗负载能力强、工作在网络协议第四层，仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。<br>2、配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。<br>3、工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过在项目实施中用得最多的还是LVS/DR+Keepalived。<br>4、无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会收到大流量的影响。<br>5、应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。</p>
<p>LVS DR(Direct Routing)模式的网络流程图：</p>
<p>lvs_dr</p>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>1、软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。<br>2、如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有Windows Server的机器的话，实施、配置、维护比较复杂了，相对而言，Nginx/HAProxy+Keepalived简单多了。</p>
<h2 id="三、HAProxy"><a href="#三、HAProxy" class="headerlink" title="三、HAProxy"></a>三、HAProxy</h2><p>###特点</p>
<p>1、HAProxy也是支持虚拟主机的。<br>2、HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。<br>3、HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。<br>4、HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，可以用LVS+Keepalived对MySQL主从做负载均衡。<br>5、HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：<br>① roundrobin，表示轮询；<br>② static-rr，表示根据权重，建议关注；<br>③ leastconn，表示最少连接者先处理，建议关注；<br>④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；<br>⑤ ri，表示根据请求的URI；<br>⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parameter name；<br>⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；<br>⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="Nginx和LVS对比："><a href="#Nginx和LVS对比：" class="headerlink" title="Nginx和LVS对比："></a>Nginx和LVS对比：</h3><p>1、Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx配置灵活，配置人员易出错。<br>2、Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。<br>3、Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。<br>4、Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。<br>5、Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。<br>6、Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。<br>7、Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用会比Nginx多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。</p>
<p>现在对网络负载均衡的使用是随着网站规模的提升根据不同的阶段来使用不同的技术：</p>
<p>第一阶段：利用Nginx或HAProxy进行单点的负载均衡，这一阶段服务器规模刚脱离开单服务器、单数据库的模式，需要一定的负载均衡，但是仍然规模较小没有专业的维护团队来进行维护，也没有需要进行大规模的网站部署。这样利用Nginx或HAproxy就是第一选择，此时这些东西上手快， 配置容易，在七层之上利用HTTP协议就可以。这时是第一选择。</p>
<p>第二阶段：随着网络服务进一步扩大，这时单点的Nginx已经不能满足，这时使用LVS或者商用Array就是首要选择，Nginx此时就作为LVS或者Array的节点来使用，具体LVS或Array的是选择是根据公司规模和预算来选择，Array的应用交付功能非常强大，本人在某项目中使用过，性价比也远高于F5，商用首选！但是一般来说这阶段相关人才跟不上业务的提升，所以购买商业负载均衡已经成为了必经之路。</p>
<p>第三阶段：这时网络服务已经成为主流产品，此时随着公司知名度也进一步扩展，相关人才的能力以及数量也随之提升，这时无论从开发适合自身产品的定制，以及降低成本来讲开源的LVS，已经成为首选，这时LVS会成为主流。<br>最终形成比较理想的基本架构为：Array/LVS — Nginx/Haproxy — Squid/Varnish — AppServer。</p>
]]></content>
    
    <summary type="html">
    
      Nginx/LVS/HAProxy负载均衡软件的优缺点详解
    
    </summary>
    
      <category term="负载均衡" scheme="http://jishusuishouji.github.io/categories/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
      <category term="负载均衡" scheme="http://jishusuishouji.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java集群--大型网站是怎样解决多用户高并发访问的</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/jiqun/Java%E9%9B%86%E7%BE%A4--%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%98%AF%E6%80%8E%E6%A0%B7%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%94%A8%E6%88%B7%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%9A%84/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/jiqun/Java集群--大型网站是怎样解决多用户高并发访问的/</id>
    <published>2017-04-07T00:06:33.000Z</published>
    <updated>2017-04-07T00:13:07.645Z</updated>
    
    <content type="html"><![CDATA[<p>为了解决大型网站的访问量大、并发量高、海量数据的问题，一般会考虑业务拆分和分布式部署。可以把那些关联不太大的业务独立出来，部署到不同的机器上，从而实现大规模的分布式系统。但这之中也有一个问题，那就是用户如何选择相应的机器的问题，这也被称为访问统一入口问题，而解决的方法是我们可以在集群机器的前面增加负载均衡设备，实现流量分发。<br><img src="/img/负载均衡.png" alt="负载均衡"><br>负载均衡:将负载（工作任务、访问请求等）进行平衡、分摊到多个操作单元（服务器、组件等）上进行执行，是解决高性能，单点故障（高可用，如果你是单机版网络，一旦服务器挂掉了，那么用户就无法请求了，但对于集群来说，一台服务器挂掉了，负载均衡器会把用户的请求发送给其他的服务器进行处理），扩展性（这里主要是指水平伸缩）的终极解决方案。<br>负载均衡设备为Nginx(F5太贵了，不过比较稳定)，这是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，具有占用内存少、并发能力强等，中国大陆使用nginx网站用户有：百度、网易、新浪、腾讯等。<br>1.nginx的负载均衡配置中默认是采用轮询的方式，这种方式中，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除，但存在各个服务器的session共享问题。<br>2.另外一种方式是ip_hash:每个请求按访问的ip的hash结果分配，如果访问的IP是固定的，那么在正常情况下，该用户的请求都会分配到后台的同一台服务器去处理，但是如果用户每次请求的IP都不同呢？所以这种方式也同1的方式一样都存在这么一个问题：session在各个服务器上的共享问题。<br>3.如果集群中的服务器的性能不一，可以通过配置各个服务器的权值来实现资源利用率的最大化，即性能好的优先选择</p>
<p>也许你会问，既然IP可能变化，那么用户用页面请求时的cookie的ID应该是确定的吧！那么我们可以用cookie_id来进行hash，然后在通过负载均衡器分发到对应的服务器上，这样就可以解决session问题了，其实当初本人也有想到这个方案，但最后本人也放弃这个方案了，因为是根据cookid_id确实可以把该用户的请求唯一的分发到那台独一无二的服务器上，那如果这台服务器挂掉了，那么根据这种分发策略，岂不是在这服务器上请求资源的用户都不能访问了。<br>解决服务器共享session问题：使用redis来共享各个服务器的session，并同时通过redis来缓存一些常用的资源，加快用户获得请求资源的速度（memcache不能做到持久化，这样这台服务器一挂掉，那么所有的资源也都没有了）。</p>
<p>进行集群部署，最好配上数据库的主从部署，因为如果在集群中只分配一个数据库服务器，那么这个系统的瓶颈将会出现在数据库的操作上，虽然redis能减轻这种负担，但对于数据量大的还是有一定影响的，而且数据库的主从部署也可以防止因某个数据库服务器的挂掉而丢失用户的信息。</p>
]]></content>
    
    <summary type="html">
    
      Java集群--大型网站是怎样解决多用户高并发访问的
    
    </summary>
    
      <category term="集群" scheme="http://jishusuishouji.github.io/categories/%E9%9B%86%E7%BE%A4/"/>
    
    
      <category term="集群" scheme="http://jishusuishouji.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>浅谈web应用的负载均衡、集群、高可用(HA)解决方案</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/web/%E6%B5%85%E8%B0%88web%E5%BA%94%E7%94%A8%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E9%9B%86%E7%BE%A4%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8_HA_%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/web/浅谈web应用的负载均衡、集群、高可用_HA_解决方案/</id>
    <published>2017-04-06T23:31:58.000Z</published>
    <updated>2017-04-07T00:05:49.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、几个组件"><a href="#1、几个组件" class="headerlink" title="1、几个组件"></a>1、几个组件</h2><h3 id="1-1、apache"><a href="#1-1、apache" class="headerlink" title="1.1、apache"></a>1.1、apache</h3><p>Apache软件基金会开放源代码的跨平台网页服务器，属于老牌的web服务器了，支持基于Ip或者域名的虚拟主机，支持代理服务器，支持安全Socket层(SSL)等等，目前主要用它做静态资源服务器，也可以做代理服务器转发请求(如：图片链等)，结合tomcat等servlet容器。</p>
<h3 id="1-2、ngnix"><a href="#1-2、ngnix" class="headerlink" title="1.2、ngnix"></a>1.2、ngnix</h3><p>俄罗斯人开发的一个高性能的HTTP和反向代理服务器。由于Nginx超越Apache的高性能和稳定性，使得国内使用Nginx作为Web服务器的网站也越来越多，其中包括新浪博客、新浪播客、网易新闻、腾讯网、搜狐博客等门户网站频道等，在3w以上的高并发环境下，ngnix处理能力相当于apache的10倍。</p>
<h3 id="1-3、lvs"><a href="#1-3、lvs" class="headerlink" title="1.3、lvs"></a>1.3、lvs</h3><p>Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。由毕业于国防科技大学的章文嵩博士于1998年5月创立，可以实现LINUX平台下的简单负载均衡。</p>
<h3 id="1-4、HAProxy"><a href="#1-4、HAProxy" class="headerlink" title="1.4、HAProxy"></a>1.4、HAProxy</h3><p>HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。HAProxy特别适用于那些负载特大的web站点， 这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全地整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上.</p>
<h3 id="1-5、keepalived"><a href="#1-5、keepalived" class="headerlink" title="1.5、keepalived"></a>1.5、keepalived</h3><p>可以实现web服务器的高可用(HA high availably)。它可以检测web服务器的工作状态，如果该服务器出现故障被检测到，将其剔除服务器群中，直至正常工作后，keepalive会自动检测到并加入到服务器群里面。实现主备服务器发生故障时ip瞬时无缝交接。它是LVS集群节点健康检测的一个用户空间守护进程，也是LVS的引导故障转移模块（director failover）。Keepalived守护进程可以检查LVS池的状态。如果LVS服务器池当中的某一个服务器宕机了。keepalived会通过一个setsockopt呼叫通知内核将这个节点从LVS拓扑图中移除。</p>
<h3 id="1-6、memcached"><a href="#1-6、memcached" class="headerlink" title="1.6、memcached"></a>1.6、memcached</h3><p>一个高性能分布式内存对象缓存系统。当初是Danga Interactive为了LiveJournal快速发展开发的系统，用于对业务查询数据缓存，减轻数据库的负载。其守护进程(daemon)是用C写的，但是客户端支持几乎所有语言(客户端基本上有3种版本[memcache client for java;spymemcached;xMecache])，服务端和客户端通过简单的协议通信；在memcached里面缓存的数据必须序列化。</p>
<h3 id="1-7、terracotta"><a href="#1-7、terracotta" class="headerlink" title="1.7、terracotta"></a>1.7、terracotta</h3><p>是一款由美国Terracotta公司开发的著名开源Java集群平台。它在JVM与Java应用之间实现了一个专门处理集群功能的抽象层，允许用户在不改变系统代码的情况下实现java应用的集群。支持数据的持久化、session的复制以及高可用(HA)。</p>
<h2 id="2、关键术语"><a href="#2、关键术语" class="headerlink" title="2、关键术语"></a>2、关键术语</h2><h3 id="2-1、负载均衡（load-balance）"><a href="#2-1、负载均衡（load-balance）" class="headerlink" title="2.1、负载均衡（load balance）"></a>2.1、负载均衡（load balance）</h3><p>如何处理高并发带来的系统性能问题，最终大家都会使用负载均衡机制。它是根据某种负载策略把请求分发到集群中的每一台服务器上，让整个服务器群来处理网站的请求。<br>公司比较有钱的，可以购买专门负责负载均衡的硬件（如：F5）,效果肯定会很好。对于大部分公司，会选择廉价有效的方法扩展整个系统的架构，来增加服务器的吞吐量和处理能力，以及承载能力。</p>
<h3 id="2-2、集群（Cluster）"><a href="#2-2、集群（Cluster）" class="headerlink" title="2.2、集群（Cluster）"></a>2.2、集群（Cluster）</h3><p>用N台服务器构成一个松耦合的多处理器系统(对外来说，他们就是一个服务器)，它们之间通过网络实现通信。让N台服务器之间相互协作，共同承载一个网站的请求压力。</p>
<h3 id="2-3、高可用（HA）"><a href="#2-3、高可用（HA）" class="headerlink" title="2.3、高可用（HA）"></a>2.3、高可用（HA）</h3><p>在集群服务器架构中，当主服务器故障时，备份服务器能够自动接管主服务器的工作，并及时切换过去，以实现对用户的不间断服务。ps：这里我感觉它跟故障转移(failover)是一个意思。</p>
<h3 id="2-4、session复制-共享"><a href="#2-4、session复制-共享" class="headerlink" title="2.4、session复制/共享"></a>2.4、session复制/共享</h3><p>在访问系统的会话过程中，用户登录系统后，不管访问系统的任何资源地址都不需要重复登录，这里面servlet容易保存了该用户的会话(session)。如果两个tomcat(A、B)提供集群服务时候，用户在A-tomcat上登录，接下来的请求web服务器根据策略分发到B-tomcat，因为B-tomcat没有保存用户的会话(session)信息，不知道其登录，会跳转到登录界面。<br>这时候我们需要让B-tomcat也保存有A-tomcat的会话，我们可以使用tomcat的session复制实现或者通过其他手段让session共享。</p>
<h2 id="3、常用web集群"><a href="#3、常用web集群" class="headerlink" title="3、常用web集群"></a>3、常用web集群</h2><h3 id="3-1、tomcat集群方案"><a href="#3-1、tomcat集群方案" class="headerlink" title="3.1、tomcat集群方案"></a>3.1、tomcat集群方案</h3><p>apache+tomcat；ngnix+tomcat；lvs+ngnix+tomcat。(lvs负责集群调度，nginx负责静态文件处理，tomcat负责动态文件处理[最优选择])。 以apache+tomcat集群为例：<br>1、他们之间的通信有三种方式：ajp_proxy、mod_jk链接器、http_proxy。<br>2、apache的分发策略有4种。权重(默认)、流量(bytraffic)、请求次数(byRequests)、繁忙程度(byBusyness根据活跃请求数的多少)<br>3、apache支持stickysession(粘性session)，即为：访问用户访问了A-tomcat，那么他的所有请求都会转发到A-tomcat，而不会到B-tomcat。[这样的负载均衡效果不好，适用于小型网站，下面说非粘性session]<br>4、它们之间的架构如图1：<br><img src="/img/apache+tomcat.jpg" alt="apache+tomcat"></p>
<p>问题1：只有一个web服务器，明显的单点故障。如果该apache出现问题，整个网站就会瘫痪。</p>
<h3 id="3-2、session复制"><a href="#3-2、session复制" class="headerlink" title="3.2、session复制"></a>3.2、session复制</h3><p>如果不采用stickysession(粘性session)，那么我们可以采用tomcat的session复制使所有节点tomcat的会话相同，tomcat使用组播技术，只要集群中一个tomcat节点的session发生改变，会广播通知所有tomcat节点发生改变。</p>
<p>问题2：据网友测试，当tomcat节点数达到4个以上时候，集群性能呈线性下滑；另外当用户访问量大到一定程度，会话内容随之增多，tomcat节点相互之间通信产生大量的网络消耗，产生网络阻塞，整个集群的吞吐量不能再上升。</p>
<h2 id="4、高可用-HA-和session共享-解决上面提到的两个问题"><a href="#4、高可用-HA-和session共享-解决上面提到的两个问题" class="headerlink" title="4、高可用(HA)和session共享(解决上面提到的两个问题)"></a>4、高可用(HA)和session共享(解决上面提到的两个问题)</h2><h3 id="4-1、使用lvs-keepalive实现集群高可用，达到更健壮的LB"><a href="#4-1、使用lvs-keepalive实现集群高可用，达到更健壮的LB" class="headerlink" title="4.1、使用lvs+keepalive实现集群高可用，达到更健壮的LB"></a>4.1、使用lvs+keepalive实现集群高可用，达到更健壮的LB</h3><p>可以前端使用lvs来做负载均衡，根据lvs的8种调度算法(可设置)，分发请求到对应的web服务器集群上。lvs做双机热备，通过keepalived模块能够达到故障自动转移到备份服务器，不间断提供服务，结构如图2：</p>
<p> <img src="/img/使用lvs+keepalive实现集群高可用，达到更健壮的LB.jpg" alt="使用lvs+keepalive实现集群高可用，达到更健壮的LB"></p>
<p> 说明：据查询了解，一般在WEB端使用的负载均衡比较多的是HAProxy+keepalived+nginx；数据库mysql集群使用Lvs+keepalived+mysql实现。因为HAProxy和nginx一样是工作在网络7层之上，并且前者弥补了nginx的一些缺点如session的保持，cookie的引导等，且它本身是个负责均衡软件，处理负载均衡上面必然优于nginx；lvs比较笨重，对于比较庞大的网络应用实施比较复杂，虽然它运行在网络4层之上，仅做分发没有流量产生，但是它不能做正则处理也不能也不能做动静分离，所以一般用lvs+keepalived或heatbeat做数据库层的负载均衡。</p>
<h3 id="4-2、使用terracotta或者memcached使session共享"><a href="#4-2、使用terracotta或者memcached使session共享" class="headerlink" title="4.2、使用terracotta或者memcached使session共享"></a>4.2、使用terracotta或者memcached使session共享</h3><h4 id="4-2-1、terracotta是jvm级别的session共享"><a href="#4-2-1、terracotta是jvm级别的session共享" class="headerlink" title="4.2.1、terracotta是jvm级别的session共享"></a>4.2.1、terracotta是jvm级别的session共享</h4><p>它基本原理是对于集群间共享的数据，当在一个节点发生变化的时候，Terracotta只把变化的部分发送给Terracotta服务器，然后由服务器把它转发给真正需要这个数据的节点，并且共享的数据对象不需要序列化。</p>
<h3 id="4-2-2、通过memcached实现内存级session共享"><a href="#4-2-2、通过memcached实现内存级session共享" class="headerlink" title="4.2.2、通过memcached实现内存级session共享"></a>4.2.2、通过memcached实现内存级session共享</h3><p>通过memcached-session-manager（msm）插件，通过tomcat上一定的配置，即可实现把session存储到memcached服务器上。注意：tomcat支持tomcat6+，并且memcached可以支持分布式内存，msm同时支持黏性session（sticky sessions）或者非黏性session（non-sticky sessions）两种模式，在memcached内存中共享的对象需要序列化。结构如图3：<br><img src="/img/通过memcached实现内存级session共享.jpg" alt="通过memcached实现内存级session共享"></p>
<p>通过一定的配置，可以实现故障转移(只支持对非粘性session)。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;Context&gt;    </div><div class="line">      ...    </div><div class="line">      &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot;    </div><div class="line">        memcachedNodes=&quot;n1:host1.yourdomain.com:11211,n2:host2.yourdomain.com:11211&quot;    </div><div class="line">        failoverNodes=&quot;n1&quot;    </div><div class="line">        requestUriIgnorePattern=&quot;.*\.(ico|png|gif|jpg|css|js)$&quot;    </div><div class="line">        transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot;    </div><div class="line">        /&gt;    </div><div class="line">&lt;/Context&gt;</div></pre></td></tr></table></figure></p>
<p>说明：<code>failoverNodes</code>：故障转移节点，对非粘性session不可用。属性<code>failoverNodes=&quot;n1&quot;</code>的作用是告诉msm最好是把session保存在memcached “n2”节点上，只有在n2节点不可用的情况下才把session保存在n1节点。这样即使host2上的tomcat宕机，仍然可以通过host1上的tomcat访问存放在memcached “n1” 节点中的session。</p>
<h3 id="4-2-3、其他方案"><a href="#4-2-3、其他方案" class="headerlink" title="4.2.3、其他方案"></a>4.2.3、其他方案</h3><p>通过cookie保存用户信息(一般是登录信息)，每一个请求到达web应用的时候，web应用从cookie中取出数据进行处理（这里尽量对cookie做加密处理）；<br>另外一种是把用户信息的关键属性保存到数据库，这样就不需要session了。请求过来从数据库查询关键属性数据，做相应处理。缺点：加大了数据库的负载，使数据库成为集群的瓶颈。</p>
]]></content>
    
    <summary type="html">
    
      浅谈web应用的负载均衡、集群、高可用(HA)解决方案
    
    </summary>
    
      <category term="负载均衡" scheme="http://jishusuishouji.github.io/categories/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
      <category term="负载均衡" scheme="http://jishusuishouji.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="集群" scheme="http://jishusuishouji.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="高可用" scheme="http://jishusuishouji.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>js如何把相对路基的url转换为绝对路径</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/js/js%E5%A6%82%E4%BD%95%E6%8A%8A%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%9F%BA%E7%9A%84url%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/js/js如何把相对路基的url转换为绝对路径/</id>
    <published>2017-04-06T13:50:53.000Z</published>
    <updated>2017-04-06T13:52:11.631Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var absolutePath = function(href) &#123;</div><div class="line">    var link = document.createElement(&quot;a&quot;);</div><div class="line">    link.href = href;</div><div class="line">    return (link.protocol+&quot;//&quot;+link.host+link.pathname+link.search+link.hash);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      js如何把相对路基的url转换为绝对路径
    
    </summary>
    
      <category term="javascript" scheme="http://jishusuishouji.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://jishusuishouji.github.io/tags/javascript/"/>
    
      <category term="js" scheme="http://jishusuishouji.github.io/tags/js/"/>
    
      <category term="相对路径" scheme="http://jishusuishouji.github.io/tags/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    
      <category term="绝对路径" scheme="http://jishusuishouji.github.io/tags/%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
</feed>
