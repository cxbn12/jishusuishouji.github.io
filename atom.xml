<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术随手记</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jishusuishouji.github.io/"/>
  <updated>2017-04-07T04:18:22.553Z</updated>
  <id>http://jishusuishouji.github.io/</id>
  
  <author>
    <name>技术随手记</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>反向代理</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/jiqun/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/jiqun/反向代理/</id>
    <published>2017-04-07T03:55:17.000Z</published>
    <updated>2017-04-07T04:18:22.553Z</updated>
    
    <content type="html"><![CDATA[<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><h3 id="通常的代理服务器-内部网络对Internet的连接请求"><a href="#通常的代理服务器-内部网络对Internet的连接请求" class="headerlink" title="通常的代理服务器(内部网络对Internet的连接请求)"></a>通常的代理服务器(内部网络对Internet的连接请求)</h3><p>通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>外部网络上的主机并不会配置并使用这个代理服务器，普通代理服务器也被设计为在Internet上搜寻多个不确定的服务器,而不是针对客户机的请求访问某一个固定的服务器，因此普通的Web代理服务器不支持外部对内部网络的访问请求。</p>
<h3 id="方向代理服务器"><a href="#方向代理服务器" class="headerlink" title="方向代理服务器"></a>方向代理服务器</h3><p>当一个代理服务器代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。此时代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个标准的Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者CGI程序，都保存在内部的Web服务器上。因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了Web服务器的安全性。</p>
<p>反向代理方式和包过滤方式或普通代理方式并无冲突，因此可以在防火墙设备中同时使用这两种方式，其中反向代理用于外部网络访问内部网络时使用，正向代理或包过滤方式用于拒绝其他外部访问方式并提供内部网络对外部网络的访问能力。因此可以结合这些方式提供最佳的安全访问方式。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输得更快、更稳定。通过在网络各处放置反向代理服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>如果您的内容服务器具有必须保持安全的敏感信息，如信用卡号数据库，可在防火墙外部设置一个代理服务器作为内容服务器的替身。当外部客户机尝试访问内容服务器时，会将其送到代理服务器。实际内容位于内容服务器上，在内部受到防火墙安全保护。代理服务器位于防火墙外部，在外部客户机看来就像是内容服务器。<br>当客户机向站点提出请求时，请求将转到代理服务器。然后，代理服务器通过防火墙中的特定通路，将客户机的请求发送到内容服务器。内容服务器再通过该通道将结果回传给代理服务器。代理服务器将检索到的信息发送给客户机，好像代理服务器就是实际的内容服务器。如果内容服务器返回错误消息，代理服务器会先行截取该消息并更改标头中列出的任何URL，然后再将消息发送给客户机。如此可防止外部客户机获取内部内容服务器的重定向URL。<br>这样，代理服务器就在安全数据库和可能的恶意攻击之间提供了又一道屏障。与有权访问整个数据库的情况相对比，就算是侥幸攻击成功，作恶者充其量也仅限于访问单个事务中所涉及的信息。未经授权的用户无法访问到真正的内容服务器，因为防火墙通路只允许代理服务器有权进行访问。<br><img src="/img/反向代理服务器就像是真正的内容服务器.jpg" alt="图1 反向代理服务器就像是真正的内容服务器"></p>
<p>可以配置防火墙路由器，使其只允许特定端口上的特定服务器有权通过防火墙进行访问，而不允许其他任何机器进出。</p>
<h2 id="安全反向代理"><a href="#安全反向代理" class="headerlink" title="安全反向代理"></a>安全反向代理</h2><p>当代理服务器与其他机器之间有一个或多个连接使用安全套接字层(SSL) 协议加密数据时，即会进行安全反向代理。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>可以提供从防火墙外部代理服务器到防火墙内部安全内容服务器的加密连接。<br>可以允许客户机安全地连接到代理服务器，从而有利于安全地传输信息（如信用卡号）。<br>安全反向代理会造成各安全连接因加密数据所涉及的系统开销而变慢。但是，由于 SSL 提供了高速缓存机制，所以连接双方可以重复使用先前协商的安全参数，从而大大降低后续连接的系统开销。</p>
<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>配置安全反向代理服务器的方法有三种：</p>
<h3 id="Secure-client-to-proxy"><a href="#Secure-client-to-proxy" class="headerlink" title="Secure client to proxy"></a>Secure client to proxy</h3><p>如果未经授权的用户很少或根本没有机会访问代理服务器与内容服务器之间交换的信息，则此方案很有效。<br><img src="/img/图 2 客户机安全连接到代理服务器.jpg" alt="图 2 客户机安全连接到代理服务器"></p>
<h3 id="Secure-proxy-to-content-server"><a href="#Secure-proxy-to-content-server" class="headerlink" title="Secure proxy to content server"></a>Secure proxy to content server</h3><p>如果客户机在防火墙外部而内容服务器在防火墙内部，则此方案很有效。在此方案中，代理服务器可以充当站点之间的安全通道<br><img src="/img/图 3 代理服务器安全连接到内容服务器.jpg" alt="图 3 代理服务器安全连接到内容服务器"></p>
<h3 id="Secure-client-to-proxy-and-secure-proxy-to-content-server"><a href="#Secure-client-to-proxy-and-secure-proxy-to-content-server" class="headerlink" title="Secure client to proxy and secure proxy to content server"></a>Secure client to proxy and secure proxy to content server</h3><p>如果需要保护服务器、代理服务器和客户机三者间所交换信息的安全，则此方案很有效。在此方案中，代理服务器既可起到站点间安全通道的作用，又可增加客户机验证的安全性。<br><img src="/img/Secure client to proxy and secure proxy to content server.jpg" alt="图 4 客户机安全连接到代理服务器并且代理服务器安全连接到内容服务器"></p>
<p>除了SSL之外，代理服务器还可以使用客户机验证，这种方法要求向代理服务器提出请求的计算机提供证书（或标识表单）以核实其身份。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="标准的代理缓冲服务器"><a href="#标准的代理缓冲服务器" class="headerlink" title="标准的代理缓冲服务器"></a>标准的代理缓冲服务器</h3><p>一个标准的代理缓冲服务被用于缓存静态的网页（例如：html文件和图片文件等）到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指明代理服务器的IP地址和端口号。客户端上网时，每次都把请求送给代理服务器处理，代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发给客户端浏览器。</p>
<h3 id="透明代理缓冲服务器"><a href="#透明代理缓冲服务器" class="headerlink" title="透明代理缓冲服务器"></a>透明代理缓冲服务器</h3><p>透明代理缓冲服务和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于Linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因为不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。</p>
<h3 id="反向代理缓冲服务器"><a href="#反向代理缓冲服务器" class="headerlink" title="反向代理缓冲服务器"></a>反向代理缓冲服务器</h3><p>反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于本地WEB服务器和Internet之间，处理所有对WEB服务器的请求，阻止了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发送给用户。这种方式通过降低了向WEB服务器的请求数从而降低了WEB服务器的负载。</p>
]]></content>
    
    <summary type="html">
    
      反向代理
    
    </summary>
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/categories/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Nginx/LVS/HAProxy负载均衡软件的优缺点详解</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/fuzaijunheng/Nginx_LVS_HAProxy%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/fuzaijunheng/Nginx_LVS_HAProxy负载均衡软件的优缺点详解/</id>
    <published>2017-04-07T03:42:08.000Z</published>
    <updated>2017-04-07T03:53:43.828Z</updated>
    
    <content type="html"><![CDATA[<p>根据网站规模不同使用不同的技术。中小型的Web应用(日PV小于1000万,平均下来一秒也就处理一百多个请求)用Nginx就可以了；如果机器不少，可以用DNS轮询，LVS需要的机器比较多；大型网站或重要的服务，且服务器比较多时，可以考虑用LVS。</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>F5和Array等商用的负载均衡器</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>有专业的维护团队进行维护</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>花销太大</p>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>Nginx/LVS/HAProxy等基于Linux的开源免费的负载均衡软件，通过软件级别来实现，费用非常低廉。</p>
<h2 id="合理流行的架构方案"><a href="#合理流行的架构方案" class="headerlink" title="合理流行的架构方案"></a>合理流行的架构方案</h2><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><p>Nginx/HAProxy+Keepalived作负载均衡器</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>MySQL数据库一主多从和读写分离，采用LVS+Keepalived的架构。</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>1、工作在网络协议的第7层，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。<br>2、Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大；<br>3、Nginx安装和配置比较简单，测试起来比较方便，日志功能很强大。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。<br>3、可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。<br>4、Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url来检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。<br>5、Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。<br>6、Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。<br>7、Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有lighttpd了，不过lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。<br>8、Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。</p>
<p>淘宝的前端使用的Tengine就是基于nginx做的二次开发定制版。</p>
<p>Nginx常规的HTTP请求和响应流程图：</p>
<p>nginx</p>
<p>Nginx的缺点是：<br>1、Nginx仅能支持http、https和Email协议，这样就在适用范围上面小些，这个是它的缺点。<br>2、对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过ip_hash来解决。</p>
<p>二、LVS<br>LVS：使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。</p>
<p>LVS的优点是：<br>1、抗负载能力强、是工作在网络4层之上仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。<br>2、配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。<br>3、工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过我们在项目实施中用得最多的还是LVS/DR+Keepalived。<br>4、无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会收到大流量的影响。<br>5、应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。</p>
<p>LVS DR(Direct Routing)模式的网络流程图：</p>
<p>lvs_dr</p>
<p>LVS的缺点是：<br>1、软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。<br>2、如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有Windows Server的机器的话，如果实施及配置还有维护过程就比较复杂了，相对而言，Nginx/HAProxy+Keepalived就简单多了。</p>
<p>三、HAProxy<br>HAProxy的特点是：<br>1、HAProxy也是支持虚拟主机的。<br>2、HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。<br>3、HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。<br>4、HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，大家可以用LVS+Keepalived对MySQL主从做负载均衡。<br>5、HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：<br>① roundrobin，表示简单的轮询，这个不多说，这个是负载均衡基本都具备的；<br>② static-rr，表示根据权重，建议关注；<br>③ leastconn，表示最少连接者先处理，建议关注；<br>④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；<br>⑤ ri，表示根据请求的URI；<br>⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parameter name；<br>⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；<br>⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。</p>
<p>四、总结<br>Nginx和LVS对比的总结：<br>1、Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx有用的这些功能使其可调整度要高于LVS，所以经常要去触碰触碰，触碰多了，人为出问题的几率也就会大。<br>2、Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。<br>3、Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。<br>4、Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。<br>5、Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。<br>6、Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大 量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。<br>7、Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用在这点上会比Nginx更多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给 LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。</p>
<p>现在对网络负载均衡的使用是随着网站规模的提升根据不同的阶段来使用不同的技术：</p>
<p>第一阶段：利用Nginx或HAProxy进行单点的负载均衡，这一阶段服务器规模刚脱离开单服务器、单数据库的模式，需要一定的负载均衡，但是仍然规模较小没有专业的维护团队来进行维护，也没有需要进行大规模的网站部署。这样利用Nginx或HAproxy就是第一选择，此时这些东西上手快， 配置容易，在七层之上利用HTTP协议就可以。这时是第一选择。</p>
<p>第二阶段：随着网络服务进一步扩大，这时单点的Nginx已经不能满足，这时使用LVS或者商用Array就是首要选择，Nginx此时就作为LVS或者Array的节点来使用，具体LVS或Array的是选择是根据公司规模和预算来选择，Array的应用交付功能非常强大，本人在某项目中使用过，性价比也远高于F5，商用首选！但是一般来说这阶段相关人才跟不上业务的提升，所以购买商业负载均衡已经成为了必经之路。</p>
<p>第三阶段：这时网络服务已经成为主流产品，此时随着公司知名度也进一步扩展，相关人才的能力以及数量也随之提升，这时无论从开发适合自身产品的定制，以及降低成本来讲开源的LVS，已经成为首选，这时LVS会成为主流。<br>最终形成比较理想的基本架构为：Array/LVS — Nginx/Haproxy — Squid/Varnish — AppServer。</p>
<p>永久链接 : <a href="http://www.ha97.com/5646.html" target="_blank" rel="external">http://www.ha97.com/5646.html</a><br>本文相关评论 - 才 18 条评论 RSS for this comments | Trackback URI<br>( 展开所有评论 | 收起所有评论 ) 立刻发表评论 »<br>sean<br>2014-07-22 15:42:32</p>
<p>Firefox 30.0 Firefox 30.0  Windows 8.1 x64 Edition Windows 8.1 x64 Edition<br>感谢总结，很棒！</p>
<p>回复他(她)<br>rootop<br>2014-07-24 09:33:30</p>
<p>uBrowser 6.x uBrowser 6.x  Windows 7 x64 Edition Windows 7 x64 Edition<br>感谢博主的总结，一直都很关注博主博客。受益匪浅。这里貌似有个小笔误。<br>“LVS需要向托管商至少申请多一个ip来做Visual IP” ，应该是virtual IP~~~</p>
<p>回复他(她)<br>Godbach<br>2014-07-24 09:56:26</p>
<p>Google Chrome 35.0.1916.153 Google Chrome 35.0.1916.153  Windows 7 x64 Edition Windows 7 x64 Edition<br>好文章。</p>
<p>不过对于 HAProxy，static-rr 是简单的轮询，选择 server 的逻辑最为简单。而 roundrobin 其实是高级一点的轮询，支持 HAProxy 运行期间动态修改 server weight。</p>
<p>不管是 static-rr， roundrobin 还是 leastconn，都是天然支持 weight 的。只是运行期间，static-rr 的 server weight 不可更改或者更改了也无效。所有 weight 为 1 的情形本身就是 weight-based 负载均衡算法的特例。</p>
<p>HAProxy 缺点没有介绍。结合个人对 Nignx 的部分了解，列举一些 HAProxy 不及 Nginx 的地方，仅供参考：</p>
<ol>
<li>不支持 POP/SMTP 协议</li>
<li>不支持 SPDY 协议</li>
<li>不支持 HTTP cache 功能。现在不少开源的 lb 项目，都或多或少具备 HTTP cache 功能。</li>
<li>重载配置的功能需要重启进程，虽然也是 soft restart，但没有 Nginx 的 reaload 更为平滑和友好。</li>
<li>多进程模式支持不够好。</li>
</ol>
<p>回复他(她)<br>crazyxiao<br>2014-07-31 18:45:17</p>
<p>Google Chrome 36.0.1985.125 Google Chrome 36.0.1985.125  Windows XP Windows XP<br>以前项目用的haproxy+nginx，配置确实很好上手</p>
<p>回复他(她)<br>BigBomb<br>2014-11-12 00:03:51</p>
<p>Google Chrome 35.0.1916.114 Google Chrome 35.0.1916.114  Windows 7 x64 Edition Windows 7 x64 Edition<br>我是路过顶教主的</p>
<p>回复他(她)<br>疯梦<br>2015-01-08 16:46:34</p>
<p>Google Chrome 31.0.1650.63 Google Chrome 31.0.1650.63  Windows 7 x64 Edition Windows 7 x64 Edition<br>用户上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。我想要问一下，对于这种情况有没有什么好点的解决办法？</p>
<p>回复他(她)<br>疯梦<br>2015-01-08 16:55:07</p>
<p>Google Chrome 31.0.1650.63 Google Chrome 31.0.1650.63  Windows 7 x64 Edition Windows 7 x64 Edition<br>用户上传文件，后台rs正好故障，nginx会切换到另一台服务器重新处理，lvs则直接断掉，我也在纠结这个问题，所以想请教下，有没有什么好点的办法？</p>
<p>回复他(她)<br>疯梦<br>2015-01-09 11:05:12</p>
<p>Google Chrome 31.0.1650.63 Google Chrome 31.0.1650.63  Windows 7 x64 Edition Windows 7 x64 Edition<br>当用户正在上传文件，如果后面RS突然故障，nginx会把请求发放给另一台RS来重新处理，而LVS则直接断掉，对于这种情况，因为我做的不多，请教下博主，有没有什么好点的办法呢？</p>
<p>回复他(她)<br>求学网 » Nginx、LVS及HAProxy负载均衡软件的优缺点详解<br>2015-01-24 10:52:19<br>WordPress 3.4.1 WordPress 3.4.1<br>[…] 原文链接： Nginx/LVS/HAProxy负载均衡软件的优缺点详解 （责编/魏伟） […]</p>
<p>回复他(她)<br>eaon<br>2015-03-13 13:32:00</p>
<p>Google Chrome 35.0.1916.114 Google Chrome 35.0.1916.114  Windows 7 x64 Edition Windows 7 x64 Edition<br>学习了，不错。就是感觉比较重复。</p>
<p>希望能有具体一些的数据来进行说明！</p>
<p>谢谢！</p>
<p>回复他(她)<br>eaon<br>2015-03-13 13:33:15</p>
<p>Google Chrome 35.0.1916.114 Google Chrome 35.0.1916.114  Windows 7 x64 Edition Windows 7 x64 Edition<br>有些重复，希望可以列举写具体的测试数据来进行比较。谢谢！</p>
<p>回复他(她)<br>seanlook<br>2015-05-19 01:19:05</p>
<p>Safari 8.0.5 Safari 8.0.5  Mac OS X  10.10.3 Mac OS X 10.10.3<br>你好，nginx在前端做负载均衡，转发到后端，但我后端tomcat来处理静态文件和上传的图片不太合理把，需要在tomcat前面再加一个nginx或apache来过滤静态文件吗？ 因为像我的图片是上传到tomcat所在服务器的，最前端的nginx没办法访问。</p>
<p>回复他(她)<br>yol<br>2015-05-29 11:00:50</p>
<p>Android Webkit 4.0 Android Webkit 4.0  Android 4.4.3 Android 4.4.3<br>不错，学习了</p>
<p>回复他(她)<br>wonderflow<br>2015-08-30 20:08:51</p>
<p>Google Chrome 44.0.2403.157 Google Chrome 44.0.2403.157  Mac OS X  10.10.4 Mac OS X 10.10.4<br>好文章，受益匪浅，谢谢分享！</p>
<p>回复他(她)<br>sun<br>2015-09-02 16:46:14</p>
<p>Google Chrome 44.0.2403.125 Google Chrome 44.0.2403.125  Windows 10 x64 Edition Windows 10 x64 Edition<br>楼主分析透着，学有所获！</p>
<p>回复他(她)<br>张戈博客<br>2016-04-26 22:53:34</p>
<p>Google Chrome 45.0.2454.85 Google Chrome 45.0.2454.85  Mac OS X  10.11.3 Mac OS X 10.11.3<br>经常参考这篇文章，很有用的对比和参考。<br>这里补充下：<br>1.9版本以上Nginx已经支持TCP负载均衡了，UDP负载均衡貌似也有第三方开发了内部模块，遗憾没能弄到测试下。<br>另外，taobao的tengine已经支持url的健康检查，且也有第三方开发的支持健康检查模块</p>
<p>回复他(她)<br>素梅好翔博客<br>2016-05-30 14:02:46</p>
<p>Google Chrome 31.0.1650.63 Google Chrome 31.0.1650.63  Windows 10 Windows 10<br>写的很好，学习了，以后还会常来</p>
<p>回复他(她)<br>kaliylinux<br>2016-07-30 13:42:59</p>
<p>Firefox 47.0 Firefox 47.0  Windows 7 x64 Edition Windows 7 x64 Edition<br>好博文，博客地址已收藏！</p>
<p>回复他(她)<br>昵称 *</p>
<p>电子邮件 *</p>
<p>网站/博客</p>
<p> 发表<br>« 关于云计算基础架构IaaS层的几点看法（原创）RHEL/CentOS/OracleLinux 7.x使用EPEL和REMI第三方yum源 »<br>站内搜索</p>
<p> Search<br>页面</p>
<p>Nginx_download<br>关于博主<br>标签云<br>订阅本站<br>我的腾讯微博</p>
<p>功能</p>
<p>注册<br>登录<br>文章RSS<br>评论RSS<br>WordPress.org<br>近期文章</p>
<p>（总结）Fedora 22跨版本升级到Fedora 24方法<br>（原创）机器学习开源框架Mahout配置与入门研究<br>大数据架构师技能图谱<br>主流大数据采集平台的架构图解<br>主流大数据厂商汇总分类<br>JDBC URL连接常用数据库格式<br>云计算十年：OpenStack如何成为开源IaaS的老大<br>2016年OpenStack &amp; Docker六大趋势预测<br>（总结）Hadoop 2.6报错解决：Could not find the main class: org.apache.hadoop.hdfs.server.namenode.NameNode.<br>odoo 8.0 VS odoo 9.0社区版&amp;企业版功能对比<br>（总结）CentOS 7.x里yum安装Odoo 8.0&amp;9.0（OpenERP）<br>（分享）GitHub上排名TOP100的Python项目<br>阿里蚂蚁金服的关系型数据库：OceanBase架构详解<br>SAP与OpenERP（Odoo）两大ERP系统比较<br>（总结）推荐10个实用的Python库<br>近期评论</p>
<p>PHP程序员雷雪松发表在《MySQL安全配置详解》<br>PHP程序员雷雪松发表在《大数据架构师技能图谱》<br>PHP程序员雷雪松发表在《（总结）Fedora 22跨版本升级到Fedora 24方法》<br>PHP程序员雷雪松发表在《（总结）Linux下设置SSH Server保持长时间连接》<br>PHP程序员雷雪松发表在《（总结）隐藏PHP版本与PHP基本安全设置》<br>80后发表在《（总结）Nginx配置文件nginx.conf中文详解》<br>wenming发表在《关于博主》<br>小小萝卜发表在《（原创）Linux下查看系统版本号信息的方法》<br>key发表在《Sun被Oracle收购两年后》<br>标签</p>
<p>2010 Apache centos Chrome Debian Google Linux mysql Nginx oracle PHP RedHat RHEL server Shell Web Windows WordPress XenServer yum 下载 互联网 优化 全球 原创 参数 命令 图解 安装 工具 常用 开源 总结 数据库 方法 服务器 架构 简介 系统 经典 脚本 腾讯 解决方法 详解 配置<br>博文浏览排名</p>
<p>（总结）Nginx配置文件nginx.conf中文详解 - 256,935 views<br>系统吞吐量（TPS）、用户并发量、性能测试概念和公式 - 249,451 views<br>（原创）Linux下查看系统版本号信息的方法 - 123,584 views<br>（总结）CentOS Linux下VNC Server远程桌面配置详解 - 113,898 views<br>（总结）CentOS Linux搭建SVN Server配置详解 - 93,766 views<br>（总结）Nginx/LVS/HAProxy负载均衡软件的优缺点详解 - 68,122 views<br>（原创）Oracle 9i所有版本的最新下载地址（已验证！） - 68,093 views<br>（总结）Web性能压力测试工具之ApacheBench（ab）详解 - 68,052 views<br>（总结）Linux下su与su -命令的本质区别 - 62,910 views<br>Linux抓包工具tcpdump详解 - 62,762 views<br>分类目录</p>
<p>Browser (7)<br>DataBase (70)<br>ERP (4)<br>Google (54)<br>IT精英 (32)<br>Linux (418)<br>MicroSoft (7)<br>Security (112)<br>SEO (22)<br>Tools (72)<br>UNIX (146)<br>VPS (14)<br>Web (155)<br>Web Server (77)<br>WordPress (39)<br>个人日记 (321)<br>书评影评 (6)<br>互联网 (221)<br>人文历史 (56)<br>人生百态 (93)<br>创业投资 (75)<br>原创总结 (135)<br>外文翻译 (76)<br>大数据应用 (14)<br>Hadoop (14)<br>开源世界 (45)<br>数据存储 (2)<br>旧文存档 (199)<br>服务器架构 (84)<br>未分类 (23)<br>游戏研究 (45)<br>科技资讯 (52)<br>编程开发 (129)<br>Python (15)<br>Shell (63)<br>网络应用 (14)<br>虚拟化与云计算 (46)<br>资源分享 (127)<br>运维经验 (39)<br>集群与负载均衡 (18)<br>项目管理 (9)<br>文章归档</p>
<p>2016年八月 (1)<br>2016年七月 (1)<br>2016年六月 (1)<br>2016年五月 (4)<br>2016年一月 (1)<br>2015年十一月 (1)<br>2015年十月 (1)<br>2015年八月 (1)<br>2015年七月 (2)<br>2015年六月 (1)<br>2015年二月 (2)<br>2014年九月 (3)<br>2014年八月 (4)<br>2014年七月 (6)<br>2014年六月 (2)<br>2014年五月 (5)<br>2014年四月 (1)<br>2013年十月 (2)<br>2013年九月 (5)<br>2013年七月 (1)<br>2013年六月 (1)<br>2013年三月 (2)<br>2013年二月 (1)<br>2013年一月 (12)<br>2012年十二月 (5)<br>2012年十一月 (10)<br>2012年十月 (2)<br>2012年九月 (5)<br>2012年八月 (12)<br>2012年七月 (21)<br>2012年六月 (23)<br>2012年五月 (21)<br>2012年四月 (7)<br>2012年三月 (2)<br>2012年二月 (1)<br>2012年一月 (2)<br>2011年十二月 (7)<br>2011年十一月 (6)<br>2011年十月 (5)<br>2011年八月 (2)<br>2011年七月 (28)<br>2011年六月 (24)<br>2011年五月 (37)<br>2011年四月 (28)<br>2011年三月 (18)<br>2011年二月 (1)<br>2011年一月 (14)<br>2010年十二月 (3)<br>2010年十一月 (17)<br>2010年十月 (24)<br>2010年九月 (100)<br>2010年八月 (119)<br>2010年七月 (184)<br>2010年六月 (157)<br>2010年五月 (154)<br>2010年四月 (42)<br>日历</p>
<p>2017年四月<br>一   二   三   四   五   六   日<br>« 8月<br>    1   2<br>3   4   5   6   7   8   9<br>10  11  12  13  14  15  16<br>17  18  19  20  21  22  23<br>24  25  26  27  28  29  30<br>Linux</p>
<p>CentOS<br>China Linux Forum<br>ChinaUnix<br>Debian<br>Gentoo<br>GNU<br>Linux Kernel<br>开源中国社区<br>常用网站</p>
<p>Google SSL<br>MySQL<br>PHP<br>SourceForge<br>豆瓣<br>技术blog</p>
<p>DBA Notes<br>张宴博客<br>服务器运维与架构<br>素包子<br>技术手册</p>
<p>LFS 6.6中文手册<br>Unix Toolbox中文版<br>开源世界旅行手册<br>鸟哥的Linux私房菜（简体版）<br>科技资讯</p>
<p>Engadget<br>GigaOM<br>奇客的资讯<br>链接表</p>
<p>绿盟科技<br>日志存档<br>2016年八月<br>2016年七月<br>2016年六月<br>2016年五月<br>2016年一月<br>2015年十一月<br>2015年十月<br>2015年八月<br>2015年七月<br>2015年六月<br>2015年二月<br>2014年九月<br>2014年八月<br>2014年七月<br>2014年六月<br>2014年五月<br>2014年四月<br>2013年十月<br>2013年九月<br>2013年七月<br>2013年六月<br>2013年三月<br>2013年二月<br>2013年一月<br>2012年十二月<br>2012年十一月<br>2012年十月<br>2012年九月<br>2012年八月<br>2012年七月<br>2012年六月<br>2012年五月<br>2012年四月<br>2012年三月<br>2012年二月<br>2012年一月<br>2011年十二月<br>2011年十一月<br>2011年十月<br>2011年八月<br>2011年七月<br>2011年六月<br>2011年五月<br>2011年四月<br>2011年三月<br>2011年二月<br>2011年一月</p>
]]></content>
    
    <summary type="html">
    
      Nginx/LVS/HAProxy负载均衡软件的优缺点详解
    
    </summary>
    
      <category term="负载均衡" scheme="http://jishusuishouji.github.io/categories/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
      <category term="负载均衡" scheme="http://jishusuishouji.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java集群--大型网站是怎样解决多用户高并发访问的</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/jiqun/Java%E9%9B%86%E7%BE%A4--%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%98%AF%E6%80%8E%E6%A0%B7%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%94%A8%E6%88%B7%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%9A%84/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/jiqun/Java集群--大型网站是怎样解决多用户高并发访问的/</id>
    <published>2017-04-07T00:06:33.000Z</published>
    <updated>2017-04-07T00:13:07.645Z</updated>
    
    <content type="html"><![CDATA[<p>为了解决大型网站的访问量大、并发量高、海量数据的问题，一般会考虑业务拆分和分布式部署。可以把那些关联不太大的业务独立出来，部署到不同的机器上，从而实现大规模的分布式系统。但这之中也有一个问题，那就是用户如何选择相应的机器的问题，这也被称为访问统一入口问题，而解决的方法是我们可以在集群机器的前面增加负载均衡设备，实现流量分发。<br><img src="/img/负载均衡.png" alt="负载均衡"><br>负载均衡:将负载（工作任务、访问请求等）进行平衡、分摊到多个操作单元（服务器、组件等）上进行执行，是解决高性能，单点故障（高可用，如果你是单机版网络，一旦服务器挂掉了，那么用户就无法请求了，但对于集群来说，一台服务器挂掉了，负载均衡器会把用户的请求发送给其他的服务器进行处理），扩展性（这里主要是指水平伸缩）的终极解决方案。<br>负载均衡设备为Nginx(F5太贵了，不过比较稳定)，这是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，具有占用内存少、并发能力强等，中国大陆使用nginx网站用户有：百度、网易、新浪、腾讯等。<br>1.nginx的负载均衡配置中默认是采用轮询的方式，这种方式中，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除，但存在各个服务器的session共享问题。<br>2.另外一种方式是ip_hash:每个请求按访问的ip的hash结果分配，如果访问的IP是固定的，那么在正常情况下，该用户的请求都会分配到后台的同一台服务器去处理，但是如果用户每次请求的IP都不同呢？所以这种方式也同1的方式一样都存在这么一个问题：session在各个服务器上的共享问题。<br>3.如果集群中的服务器的性能不一，可以通过配置各个服务器的权值来实现资源利用率的最大化，即性能好的优先选择</p>
<p>也许你会问，既然IP可能变化，那么用户用页面请求时的cookie的ID应该是确定的吧！那么我们可以用cookie_id来进行hash，然后在通过负载均衡器分发到对应的服务器上，这样就可以解决session问题了，其实当初本人也有想到这个方案，但最后本人也放弃这个方案了，因为是根据cookid_id确实可以把该用户的请求唯一的分发到那台独一无二的服务器上，那如果这台服务器挂掉了，那么根据这种分发策略，岂不是在这服务器上请求资源的用户都不能访问了。<br>解决服务器共享session问题：使用redis来共享各个服务器的session，并同时通过redis来缓存一些常用的资源，加快用户获得请求资源的速度（memcache不能做到持久化，这样这台服务器一挂掉，那么所有的资源也都没有了）。</p>
<p>进行集群部署，最好配上数据库的主从部署，因为如果在集群中只分配一个数据库服务器，那么这个系统的瓶颈将会出现在数据库的操作上，虽然redis能减轻这种负担，但对于数据量大的还是有一定影响的，而且数据库的主从部署也可以防止因某个数据库服务器的挂掉而丢失用户的信息。</p>
]]></content>
    
    <summary type="html">
    
      Java集群--大型网站是怎样解决多用户高并发访问的
    
    </summary>
    
      <category term="集群" scheme="http://jishusuishouji.github.io/categories/%E9%9B%86%E7%BE%A4/"/>
    
    
      <category term="集群" scheme="http://jishusuishouji.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>浅谈web应用的负载均衡、集群、高可用(HA)解决方案</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/web/%E6%B5%85%E8%B0%88web%E5%BA%94%E7%94%A8%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E9%9B%86%E7%BE%A4%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8_HA_%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/web/浅谈web应用的负载均衡、集群、高可用_HA_解决方案/</id>
    <published>2017-04-06T23:31:58.000Z</published>
    <updated>2017-04-07T00:05:49.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、几个组件"><a href="#1、几个组件" class="headerlink" title="1、几个组件"></a>1、几个组件</h2><h3 id="1-1、apache"><a href="#1-1、apache" class="headerlink" title="1.1、apache"></a>1.1、apache</h3><p>Apache软件基金会开放源代码的跨平台网页服务器，属于老牌的web服务器了，支持基于Ip或者域名的虚拟主机，支持代理服务器，支持安全Socket层(SSL)等等，目前主要用它做静态资源服务器，也可以做代理服务器转发请求(如：图片链等)，结合tomcat等servlet容器。</p>
<h3 id="1-2、ngnix"><a href="#1-2、ngnix" class="headerlink" title="1.2、ngnix"></a>1.2、ngnix</h3><p>俄罗斯人开发的一个高性能的HTTP和反向代理服务器。由于Nginx超越Apache的高性能和稳定性，使得国内使用Nginx作为Web服务器的网站也越来越多，其中包括新浪博客、新浪播客、网易新闻、腾讯网、搜狐博客等门户网站频道等，在3w以上的高并发环境下，ngnix处理能力相当于apache的10倍。</p>
<h3 id="1-3、lvs"><a href="#1-3、lvs" class="headerlink" title="1.3、lvs"></a>1.3、lvs</h3><p>Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。由毕业于国防科技大学的章文嵩博士于1998年5月创立，可以实现LINUX平台下的简单负载均衡。</p>
<h3 id="1-4、HAProxy"><a href="#1-4、HAProxy" class="headerlink" title="1.4、HAProxy"></a>1.4、HAProxy</h3><p>HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。HAProxy特别适用于那些负载特大的web站点， 这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全地整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上.</p>
<h3 id="1-5、keepalived"><a href="#1-5、keepalived" class="headerlink" title="1.5、keepalived"></a>1.5、keepalived</h3><p>可以实现web服务器的高可用(HA high availably)。它可以检测web服务器的工作状态，如果该服务器出现故障被检测到，将其剔除服务器群中，直至正常工作后，keepalive会自动检测到并加入到服务器群里面。实现主备服务器发生故障时ip瞬时无缝交接。它是LVS集群节点健康检测的一个用户空间守护进程，也是LVS的引导故障转移模块（director failover）。Keepalived守护进程可以检查LVS池的状态。如果LVS服务器池当中的某一个服务器宕机了。keepalived会通过一个setsockopt呼叫通知内核将这个节点从LVS拓扑图中移除。</p>
<h3 id="1-6、memcached"><a href="#1-6、memcached" class="headerlink" title="1.6、memcached"></a>1.6、memcached</h3><p>一个高性能分布式内存对象缓存系统。当初是Danga Interactive为了LiveJournal快速发展开发的系统，用于对业务查询数据缓存，减轻数据库的负载。其守护进程(daemon)是用C写的，但是客户端支持几乎所有语言(客户端基本上有3种版本[memcache client for java;spymemcached;xMecache])，服务端和客户端通过简单的协议通信；在memcached里面缓存的数据必须序列化。</p>
<h3 id="1-7、terracotta"><a href="#1-7、terracotta" class="headerlink" title="1.7、terracotta"></a>1.7、terracotta</h3><p>是一款由美国Terracotta公司开发的著名开源Java集群平台。它在JVM与Java应用之间实现了一个专门处理集群功能的抽象层，允许用户在不改变系统代码的情况下实现java应用的集群。支持数据的持久化、session的复制以及高可用(HA)。</p>
<h2 id="2、关键术语"><a href="#2、关键术语" class="headerlink" title="2、关键术语"></a>2、关键术语</h2><h3 id="2-1、负载均衡（load-balance）"><a href="#2-1、负载均衡（load-balance）" class="headerlink" title="2.1、负载均衡（load balance）"></a>2.1、负载均衡（load balance）</h3><p>如何处理高并发带来的系统性能问题，最终大家都会使用负载均衡机制。它是根据某种负载策略把请求分发到集群中的每一台服务器上，让整个服务器群来处理网站的请求。<br>公司比较有钱的，可以购买专门负责负载均衡的硬件（如：F5）,效果肯定会很好。对于大部分公司，会选择廉价有效的方法扩展整个系统的架构，来增加服务器的吞吐量和处理能力，以及承载能力。</p>
<h3 id="2-2、集群（Cluster）"><a href="#2-2、集群（Cluster）" class="headerlink" title="2.2、集群（Cluster）"></a>2.2、集群（Cluster）</h3><p>用N台服务器构成一个松耦合的多处理器系统(对外来说，他们就是一个服务器)，它们之间通过网络实现通信。让N台服务器之间相互协作，共同承载一个网站的请求压力。</p>
<h3 id="2-3、高可用（HA）"><a href="#2-3、高可用（HA）" class="headerlink" title="2.3、高可用（HA）"></a>2.3、高可用（HA）</h3><p>在集群服务器架构中，当主服务器故障时，备份服务器能够自动接管主服务器的工作，并及时切换过去，以实现对用户的不间断服务。ps：这里我感觉它跟故障转移(failover)是一个意思。</p>
<h3 id="2-4、session复制-共享"><a href="#2-4、session复制-共享" class="headerlink" title="2.4、session复制/共享"></a>2.4、session复制/共享</h3><p>在访问系统的会话过程中，用户登录系统后，不管访问系统的任何资源地址都不需要重复登录，这里面servlet容易保存了该用户的会话(session)。如果两个tomcat(A、B)提供集群服务时候，用户在A-tomcat上登录，接下来的请求web服务器根据策略分发到B-tomcat，因为B-tomcat没有保存用户的会话(session)信息，不知道其登录，会跳转到登录界面。<br>这时候我们需要让B-tomcat也保存有A-tomcat的会话，我们可以使用tomcat的session复制实现或者通过其他手段让session共享。</p>
<h2 id="3、常用web集群"><a href="#3、常用web集群" class="headerlink" title="3、常用web集群"></a>3、常用web集群</h2><h3 id="3-1、tomcat集群方案"><a href="#3-1、tomcat集群方案" class="headerlink" title="3.1、tomcat集群方案"></a>3.1、tomcat集群方案</h3><p>apache+tomcat；ngnix+tomcat；lvs+ngnix+tomcat。(lvs负责集群调度，nginx负责静态文件处理，tomcat负责动态文件处理[最优选择])。 以apache+tomcat集群为例：<br>1、他们之间的通信有三种方式：ajp_proxy、mod_jk链接器、http_proxy。<br>2、apache的分发策略有4种。权重(默认)、流量(bytraffic)、请求次数(byRequests)、繁忙程度(byBusyness根据活跃请求数的多少)<br>3、apache支持stickysession(粘性session)，即为：访问用户访问了A-tomcat，那么他的所有请求都会转发到A-tomcat，而不会到B-tomcat。[这样的负载均衡效果不好，适用于小型网站，下面说非粘性session]<br>4、它们之间的架构如图1：<br><img src="/img/apache+tomcat.jpg" alt="apache+tomcat"></p>
<p>问题1：只有一个web服务器，明显的单点故障。如果该apache出现问题，整个网站就会瘫痪。</p>
<h3 id="3-2、session复制"><a href="#3-2、session复制" class="headerlink" title="3.2、session复制"></a>3.2、session复制</h3><p>如果不采用stickysession(粘性session)，那么我们可以采用tomcat的session复制使所有节点tomcat的会话相同，tomcat使用组播技术，只要集群中一个tomcat节点的session发生改变，会广播通知所有tomcat节点发生改变。</p>
<p>问题2：据网友测试，当tomcat节点数达到4个以上时候，集群性能呈线性下滑；另外当用户访问量大到一定程度，会话内容随之增多，tomcat节点相互之间通信产生大量的网络消耗，产生网络阻塞，整个集群的吞吐量不能再上升。</p>
<h2 id="4、高可用-HA-和session共享-解决上面提到的两个问题"><a href="#4、高可用-HA-和session共享-解决上面提到的两个问题" class="headerlink" title="4、高可用(HA)和session共享(解决上面提到的两个问题)"></a>4、高可用(HA)和session共享(解决上面提到的两个问题)</h2><h3 id="4-1、使用lvs-keepalive实现集群高可用，达到更健壮的LB"><a href="#4-1、使用lvs-keepalive实现集群高可用，达到更健壮的LB" class="headerlink" title="4.1、使用lvs+keepalive实现集群高可用，达到更健壮的LB"></a>4.1、使用lvs+keepalive实现集群高可用，达到更健壮的LB</h3><p>可以前端使用lvs来做负载均衡，根据lvs的8种调度算法(可设置)，分发请求到对应的web服务器集群上。lvs做双机热备，通过keepalived模块能够达到故障自动转移到备份服务器，不间断提供服务，结构如图2：</p>
<p> <img src="/img/使用lvs+keepalive实现集群高可用，达到更健壮的LB.jpg" alt="使用lvs+keepalive实现集群高可用，达到更健壮的LB"></p>
<p> 说明：据查询了解，一般在WEB端使用的负载均衡比较多的是HAProxy+keepalived+nginx；数据库mysql集群使用Lvs+keepalived+mysql实现。因为HAProxy和nginx一样是工作在网络7层之上，并且前者弥补了nginx的一些缺点如session的保持，cookie的引导等，且它本身是个负责均衡软件，处理负载均衡上面必然优于nginx；lvs比较笨重，对于比较庞大的网络应用实施比较复杂，虽然它运行在网络4层之上，仅做分发没有流量产生，但是它不能做正则处理也不能也不能做动静分离，所以一般用lvs+keepalived或heatbeat做数据库层的负载均衡。</p>
<h3 id="4-2、使用terracotta或者memcached使session共享"><a href="#4-2、使用terracotta或者memcached使session共享" class="headerlink" title="4.2、使用terracotta或者memcached使session共享"></a>4.2、使用terracotta或者memcached使session共享</h3><h4 id="4-2-1、terracotta是jvm级别的session共享"><a href="#4-2-1、terracotta是jvm级别的session共享" class="headerlink" title="4.2.1、terracotta是jvm级别的session共享"></a>4.2.1、terracotta是jvm级别的session共享</h4><p>它基本原理是对于集群间共享的数据，当在一个节点发生变化的时候，Terracotta只把变化的部分发送给Terracotta服务器，然后由服务器把它转发给真正需要这个数据的节点，并且共享的数据对象不需要序列化。</p>
<h3 id="4-2-2、通过memcached实现内存级session共享"><a href="#4-2-2、通过memcached实现内存级session共享" class="headerlink" title="4.2.2、通过memcached实现内存级session共享"></a>4.2.2、通过memcached实现内存级session共享</h3><p>通过memcached-session-manager（msm）插件，通过tomcat上一定的配置，即可实现把session存储到memcached服务器上。注意：tomcat支持tomcat6+，并且memcached可以支持分布式内存，msm同时支持黏性session（sticky sessions）或者非黏性session（non-sticky sessions）两种模式，在memcached内存中共享的对象需要序列化。结构如图3：<br><img src="/img/通过memcached实现内存级session共享.jpg" alt="通过memcached实现内存级session共享"></p>
<p>通过一定的配置，可以实现故障转移(只支持对非粘性session)。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;Context&gt;    </div><div class="line">      ...    </div><div class="line">      &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot;    </div><div class="line">        memcachedNodes=&quot;n1:host1.yourdomain.com:11211,n2:host2.yourdomain.com:11211&quot;    </div><div class="line">        failoverNodes=&quot;n1&quot;    </div><div class="line">        requestUriIgnorePattern=&quot;.*\.(ico|png|gif|jpg|css|js)$&quot;    </div><div class="line">        transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot;    </div><div class="line">        /&gt;    </div><div class="line">&lt;/Context&gt;</div></pre></td></tr></table></figure></p>
<p>说明：<code>failoverNodes</code>：故障转移节点，对非粘性session不可用。属性<code>failoverNodes=&quot;n1&quot;</code>的作用是告诉msm最好是把session保存在memcached “n2”节点上，只有在n2节点不可用的情况下才把session保存在n1节点。这样即使host2上的tomcat宕机，仍然可以通过host1上的tomcat访问存放在memcached “n1” 节点中的session。</p>
<h3 id="4-2-3、其他方案"><a href="#4-2-3、其他方案" class="headerlink" title="4.2.3、其他方案"></a>4.2.3、其他方案</h3><p>通过cookie保存用户信息(一般是登录信息)，每一个请求到达web应用的时候，web应用从cookie中取出数据进行处理（这里尽量对cookie做加密处理）；<br>另外一种是把用户信息的关键属性保存到数据库，这样就不需要session了。请求过来从数据库查询关键属性数据，做相应处理。缺点：加大了数据库的负载，使数据库成为集群的瓶颈。</p>
]]></content>
    
    <summary type="html">
    
      浅谈web应用的负载均衡、集群、高可用(HA)解决方案
    
    </summary>
    
      <category term="负载均衡" scheme="http://jishusuishouji.github.io/categories/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
      <category term="负载均衡" scheme="http://jishusuishouji.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="集群" scheme="http://jishusuishouji.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="高可用" scheme="http://jishusuishouji.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>js如何把相对路基的url转换为绝对路径</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/js/js%E5%A6%82%E4%BD%95%E6%8A%8A%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%9F%BA%E7%9A%84url%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/js/js如何把相对路基的url转换为绝对路径/</id>
    <published>2017-04-06T13:50:53.000Z</published>
    <updated>2017-04-06T13:52:11.631Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var absolutePath = function(href) &#123;</div><div class="line">    var link = document.createElement(&quot;a&quot;);</div><div class="line">    link.href = href;</div><div class="line">    return (link.protocol+&quot;//&quot;+link.host+link.pathname+link.search+link.hash);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      js如何把相对路基的url转换为绝对路径
    
    </summary>
    
      <category term="javascript" scheme="http://jishusuishouji.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://jishusuishouji.github.io/tags/javascript/"/>
    
      <category term="js" scheme="http://jishusuishouji.github.io/tags/js/"/>
    
      <category term="相对路径" scheme="http://jishusuishouji.github.io/tags/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    
      <category term="绝对路径" scheme="http://jishusuishouji.github.io/tags/%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/shejiyuanze/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/shejiyuanze/设计模式六大原则/</id>
    <published>2017-04-05T23:43:16.000Z</published>
    <updated>2017-04-06T23:28:59.846Z</updated>
    
    <content type="html"><![CDATA[<p>开闭原则<br>单一职责原则<br>迪米特原则<br>面向对象的： 接口隔离原则<br>             依赖倒转原则<br>             里氏替换原则</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>定义：<strong>不要存在多于一个导致类变更的原因</strong>。</p>
<p>问题由来：类<code>T</code>负责两个不同的职责：职责<code>P1</code>，职责<code>P2</code>。当由于职责<code>P1</code>需求发生改变而需要修改类<code>T</code>时，有可能会导致原本运行正常的职责<code>P2</code>功能发生故障。</p>
<p>解决方案：遵循单一职责原则。分别建立两个类<code>T1</code>、<code>T2</code>，使<code>T1</code>完成职责<code>P1</code>功能，<code>T2</code>完成职责<code>P2</code>功能。这样，当修改类<code>T1</code>时，不会使职责P2发生故障风险；同理，当修改<code>T2</code>时，也不会使职责P1发生故障风险。</p>
<p>遵循单一职责原则可以避免因为修改了一个功能导致其他功能发生异常。</p>
<h3 id="职责扩散"><a href="#职责扩散" class="headerlink" title="职责扩散"></a>职责扩散</h3><p>职责扩散：因为某种原因，职责P被分化为粒度更细的职责P1和P2。<br>比如：类<code>T</code>只负责一个职责P，这样设计是符合单一职责原则的。后来由于需求变更了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类<code>T</code>分解为两个类<code>T1</code>和<code>T2</code>，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类<code>T</code>，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）</p>
<h3 id="职责扩散例子说明，用一个类描述动物呼吸这个场景："><a href="#职责扩散例子说明，用一个类描述动物呼吸这个场景：" class="headerlink" title="职责扩散例子说明，用一个类描述动物呼吸这个场景："></a>职责扩散例子说明，用一个类描述动物呼吸这个场景：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Animal&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸空气&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal animal = new Animal();</div><div class="line">        animal.breathe(&quot;牛&quot;);</div><div class="line">        animal.breathe(&quot;羊&quot;);</div><div class="line">        animal.breathe(&quot;猪&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">牛呼吸空气</div><div class="line">羊呼吸空气</div><div class="line">猪呼吸空气</div></pre></td></tr></table></figure>
<p>程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将<code>Animal</code>类细分为陆生动物类<code>Terrestrial</code>，水生动物<code>Aquatic</code>，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Terrestrial&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸空气&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Aquatic&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸水&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Terrestrial terrestrial = new Terrestrial();</div><div class="line">        terrestrial.breathe(&quot;牛&quot;);</div><div class="line">        terrestrial.breathe(&quot;羊&quot;);</div><div class="line">        terrestrial.breathe(&quot;猪&quot;);</div><div class="line">        </div><div class="line">        Aquatic aquatic = new Aquatic();</div><div class="line">        aquatic.breathe(&quot;鱼&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">牛呼吸空气</div><div class="line">羊呼吸空气</div><div class="line">猪呼吸空气</div><div class="line">鱼呼吸水</div></pre></td></tr></table></figure></p>
<p>我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类<code>Animal</code>来达成目的虽然违背了单一职责原则，但花销却小得多，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Animal&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        if(&quot;鱼&quot;.equals(animal))&#123;</div><div class="line">            System.out.println(animal+&quot;呼吸水&quot;);</div><div class="line">        &#125;else&#123;</div><div class="line">            System.out.println(animal+&quot;呼吸空气&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal animal = new Animal();</div><div class="line">        animal.breathe(&quot;牛&quot;);</div><div class="line">        animal.breathe(&quot;羊&quot;);</div><div class="line">        animal.breathe(&quot;猪&quot;);</div><div class="line">        animal.breathe(&quot;鱼&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这种修改方式要简单得多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改<code>Animal</code>类的<code>breathe</code>方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。(不要认为这是不可能的，这是绝对可能的，修改代码本来就应该认为是极其危险的，你可以扩展但是最好不要修改，修改了就一定要好好测试！)这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Animal&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸空气&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void breathe2(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸水&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal animal = new Animal();</div><div class="line">        animal.breathe(&quot;牛&quot;);</div><div class="line">        animal.breathe(&quot;羊&quot;);</div><div class="line">        animal.breathe(&quot;猪&quot;);</div><div class="line">        animal.breathe2(&quot;鱼&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一种呢？这需要根据实际情况来确定。原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；</p>
<p>例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类要复杂得多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。</p>
<h3 id="遵循单一职责原的优点有："><a href="#遵循单一职责原的优点有：" class="headerlink" title="遵循单一职责原的优点有："></a>遵循单一职责原的优点有：</h3><ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>降低变更引起的风险，变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<p>需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>在1988年麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。</p>
<p>定义1：如果对每一个类型为<code>T1</code>的对象<code>o1</code>，都有类型为<code>T2</code>的对象<code>o2</code>,使得在程序中所有的对象<code>o1</code>都代换成<code>o2</code>时，程序P的行为没有发生变化，那么类型<code>T2</code>是类型<code>T1</code>的子类型。</p>
<p>定义2：所有引用基类的地方必须能透明地使用其子类的对象。</p>
<p>问题由来：有一功能P1，由类<code>A</code>完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类<code>A</code>的子类<code>B</code>来完成，则子类<code>B</code>在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p>
<p>解决方案：当使用继承时，遵循里氏替换原则。类<code>B</code>继承类<code>A</code>时，除添加新的方法完成新增功能P2外，尽量不要重写父类<code>A</code>的方法，也尽量不要重载父类<code>A</code>的方法。</p>
<p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p>
<p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>一个两数相减的功能由类A来负责。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">    public int func1(int a, int b)&#123;</div><div class="line">        return a-b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        A a = new A();</div><div class="line">        System.out.println(&quot;100-50=&quot;+a.func1(100, 50));</div><div class="line">        System.out.println(&quot;100-80=&quot;+a.func1(100, 80));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">100-50=50</div><div class="line"></div><div class="line">100-80=20</div></pre></td></tr></table></figure></p>
<p>后来，需要增加一个新的功能：完成两数相加，然后再与100求和，由类<code>B</code>来负责。即类<code>B</code>需要完成两个功能：</p>
<ul>
<li>两数相减。</li>
<li>两数相加，然后再加100。</li>
</ul>
<p>由于类<code>A</code>已经实现了第一个功能，所以类<code>B</code>继承类<code>A</code>后，只需要再完成第二个功能就可以了，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class B extends A&#123;</div><div class="line">    public int func1(int a, int b)&#123;</div><div class="line">        return a+b;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int func2(int a, int b)&#123;</div><div class="line">        return func1(a,b)+100;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        B b = new B();</div><div class="line">        System.out.println(&quot;100-50=&quot;+b.func1(100, 50));</div><div class="line">        System.out.println(&quot;100-80=&quot;+b.func1(100, 80));</div><div class="line">        System.out.println(&quot;100+20+100=&quot;+b.func2(100, 20));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类<code>B</code>完成后，运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">100-50=150</div><div class="line">100-80=180</div><div class="line">100+20+100=220</div></pre></td></tr></table></figure></p>
<p>我们发现原本运行正常的相减功能发生了错误。原因就是类<code>B</code>在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类<code>B</code>重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类<code>A</code>完成的功能，换成子类<code>B</code>之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p>
<p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
<li>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？</li>
</ul>
<p>后果就是：你写的代码出问题的几率将会大大增加。</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>定义：<br>高层模块不应该依赖低层模块，二者都应该依赖其抽象；<br>抽象不应该依赖细节；细节应该依赖抽象。</p>
<p>问题由来：类<code>A</code>直接依赖类<code>B</code>，假如要将类<code>A</code>改为依赖类<code>C</code>，则必须通过修改类<code>A</code>的代码来达成。这种场景下，类<code>A</code>一般是高层模块，负责复杂的业务逻辑；类<code>B</code>和类<code>C</code>是低层模块，负责基本的原子操作；假如修改类<code>A</code>，会给程序带来不必要的风险。</p>
<p>解决方案：将类<code>A</code>修改为依赖接口<code>I</code>，类<code>B</code>和类<code>C</code>各自实现接口<code>I</code>，类<code>A</code>通过接口<code>I</code>间接与类<code>B</code>或者类<code>C</code>发生联系，则会大大降低修改类<code>A</code>的几率。</p>
<p>依赖倒置原则基于这样一个事实：<strong>相对于细节的多变性，抽象的东西要稳定得多。</strong>以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定得多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把细节的任务交给他们的实现类去完成。</p>
<p>依赖倒置原则的核心思想是面向接口编程。<br>Spring Ioc的好处在小项目是体会不到的，当你的项目大了，你就能体会到了。比如有一个项目有30多个maven子模块，在某个子模块中你根本就不知道服务层注入的到底是那个对象，你只知道那些接口，这样接口的实现可以随意变动，另一个人不会影响到你。</p>
<p>场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Book&#123;</div><div class="line">    public String getContent()&#123;</div><div class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Mother&#123;</div><div class="line">    public void narrate(Book book)&#123;</div><div class="line">        System.out.println(&quot;妈妈开始讲故事&quot;);</div><div class="line">        System.out.println(book.getContent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Mother mother = new Mother();</div><div class="line">        mother.narrate(new Book());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">妈妈开始讲故事</div><div class="line">很久很久以前有一个阿拉伯的故事……</div></pre></td></tr></table></figure></p>
<p>运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Newspaper&#123;</div><div class="line">    public String getContent()&#123;</div><div class="line">        return &quot;林书豪38+7领导尼克斯击败湖人……&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改<code>Mother</code>才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改<code>Mother</code>，这显然不是好的设计。原因就是<code>Mother</code>与<code>Book</code>之间的耦合性太高了，必须降低他们之间的耦合度才行。</p>
<p>我们引入一个抽象的接口<code>IReader</code>。读物，只要是带字的都属于读物：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface IReader&#123;</div><div class="line">    public String getContent();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Mother</code>类与接口<code>IReader</code>发生依赖关系，而<code>Book</code>和<code>Newspaper</code>都属于读物的范畴，他们各自都去实现<code>IReader</code>接口，这样就符合依赖倒置原则了，代码修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Newspaper implements IReader &#123;</div><div class="line">    public String getContent()&#123;</div><div class="line">        return &quot;林书豪17+9助尼克斯击败老鹰……&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Book implements IReader&#123;</div><div class="line">    public String getContent()&#123;</div><div class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Mother&#123;</div><div class="line">    public void narrate(IReader reader)&#123;</div><div class="line">        System.out.println(&quot;妈妈开始讲故事&quot;);</div><div class="line">        System.out.println(reader.getContent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Mother mother = new Mother();</div><div class="line">        mother.narrate(new Book());</div><div class="line">        mother.narrate(new Newspaper());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">妈妈开始讲故事</div><div class="line">很久很久以前有一个阿拉伯的故事……</div><div class="line">妈妈开始讲故事</div><div class="line">林书豪17+9助尼克斯击败老鹰……</div></pre></td></tr></table></figure></p>
<p>这样修改后，无论以后怎样扩展<code>Client</code>类，都不需要再修改<code>Mother</code>类了。这只是一个简单的例子，实际情况中，代表高层模块的<code>Mother</code>类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p>
<p>采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本<code>Mother</code>类与<code>Book</code>类直接耦合时，<code>Mother</code>类必须等<code>Book</code>类编码完成后才可以进行编码，因为<code>Mother</code>类依赖于<code>Book</code>类。修改后的程序则可以同时开工，互不影响，因为<code>Mother</code>与<code>Book</code>类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。</p>
<p>传递依赖关系有三种方式，以上的例子中使用的方法是<strong>接口传递</strong>，另外还有两种传递方式：<strong>构造方法传递</strong>和<strong>setter方法传递</strong>，相信用过Spring框架的，对依赖的传递方式一定不会陌生。</p>
<p>在实际编程中，我们一般需要做到如下3点：</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。</li>
<li>变量的声明类型尽量是抽象类或接口。</li>
<li>使用继承时遵循里氏替换原则。</li>
</ul>
<p>依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>定义：<br>客户端不应该依赖它不需要的接口；<br>一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>问题由来：类<code>A</code>通过接口<code>I</code>依赖类<code>B</code>，类<code>C</code>通过接口<code>I</code>依赖类<code>D</code>，如果接口<code>I</code>对于类<code>A</code>和类<code>C</code>来说不是最小接口，则类<code>B</code>和类<code>D</code>必须去实现他们不需要的方法。</p>
<p>解决方案：将臃肿的接口<code>I</code>拆分为独立的几个接口，类<code>A</code>和类<code>C</code>分别与它们需要的接口建立依赖关系。也就是采用接口隔离原则。</p>
<p>举例来说明接口隔离原则：<br><img src="/img/未遵循接口隔离原则的设计.jpg" alt="未遵循接口隔离原则的设计"></p>
<p>这个图的意思是：类<code>A</code>依赖接口<code>I</code>中的方法1、方法2、方法3，类<code>B</code>是对类<code>A</code>依赖的实现。类<code>C</code>依赖接口<code>I</code>中的方法1、方法4、方法5，类<code>D</code>是对类<code>C</code>依赖的实现。对于类<code>B</code>和类<code>D</code>来说，虽然它们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口<code>I</code>，所以也必须要实现这些用不到的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">interface I &#123;</div><div class="line">    public void method1();</div><div class="line">    public void method2();</div><div class="line">    public void method3();</div><div class="line">    public void method4();</div><div class="line">    public void method5();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">    public void depend1(I i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I i)&#123;</div><div class="line">        i.method2();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I i)&#123;</div><div class="line">        i.method3();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class B implements I&#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method2() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I的方法2&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method3() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I的方法3&quot;);</div><div class="line">    &#125;</div><div class="line">    //对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，</div><div class="line">    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</div><div class="line">    public void method4() &#123;&#125;</div><div class="line">    public void method5() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class C&#123;</div><div class="line">    public void depend1(I i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I i)&#123;</div><div class="line">        i.method4();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I i)&#123;</div><div class="line">        i.method5();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class D implements I&#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    //对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，</div><div class="line">    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</div><div class="line">    public void method2() &#123;&#125;</div><div class="line">    public void method3() &#123;&#125;</div><div class="line"></div><div class="line">    public void method4() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I的方法4&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method5() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I的方法5&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        A a = new A();</div><div class="line">        a.depend1(new B());</div><div class="line">        a.depend2(new B());</div><div class="line">        a.depend3(new B());</div><div class="line">        </div><div class="line">        C c = new C();</div><div class="line">        c.depend1(new D());</div><div class="line">        c.depend2(new D());</div><div class="line">        c.depend3(new D());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口<code>I</code>进行拆分。在这里我们将原有的接口<code>I</code>拆分为三个接口，拆分后的设计如图2所示：</p>
<p><img src="/img/图2 遵循接口隔离原则的设计.jpg" alt="图2 遵循接口隔离原则的设计"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> interface I1 &#123;</div><div class="line">    public void method1();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface I2 &#123;</div><div class="line">    public void method2();</div><div class="line">    public void method3();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface I3 &#123;</div><div class="line">    public void method4();</div><div class="line">    public void method5();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">    public void depend1(I1 i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I2 i)&#123;</div><div class="line">        i.method2();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I2 i)&#123;</div><div class="line">        i.method3();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class B implements I1, I2&#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I1的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method2() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I2的方法2&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method3() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I2的方法3&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class C&#123;</div><div class="line">    public void depend1(I1 i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I3 i)&#123;</div><div class="line">        i.method4();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I3 i)&#123;</div><div class="line">        i.method5();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class D implements I1, I3&#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I1的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method4() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I3的方法4&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method5() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I3的方法5&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<p>说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p>
<p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<ul>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
<li>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</li>
</ul>
<h2 id="迪米特法则-最少知道原则"><a href="#迪米特法则-最少知道原则" class="headerlink" title="迪米特法则(最少知道原则)"></a>迪米特法则(最少知道原则)</h2><p>定义：一个对象应该对其他对象保持最少的了解。</p>
<p>问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p>解决方案：尽量降低类与类之间的耦合。</p>
<p>低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量得低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</p>
<p>一个类对自己依赖的类知道得越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地将逻辑封装在类的内部，对外除了提供的<code>public</code>方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，<strong>陌生的类最好不要作为局部变量的形式出现在类的内部</strong>。</p>
<p>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> //总公司员工</div><div class="line">class Employee&#123;</div><div class="line">    private String id;</div><div class="line">    public void setId(String id)&#123;</div><div class="line">        this.id = id;</div><div class="line">    &#125;</div><div class="line">    public String getId()&#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//分公司员工</div><div class="line">class SubEmployee&#123;</div><div class="line">    private String id;</div><div class="line">    public void setId(String id)&#123;</div><div class="line">        this.id = id;</div><div class="line">    &#125;</div><div class="line">    public String getId()&#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class SubCompanyManager&#123;</div><div class="line">    public List&lt;SubEmployee&gt; getAllEmployee()&#123;</div><div class="line">        List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;();</div><div class="line">        for(int i=0; i&lt;100; i++)&#123;</div><div class="line">            SubEmployee emp = new SubEmployee();</div><div class="line">            //为分公司人员按顺序分配一个ID</div><div class="line">            emp.setId(&quot;分公司&quot;+i);</div><div class="line">            list.add(emp);</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class CompanyManager&#123;</div><div class="line"></div><div class="line">    public List&lt;Employee&gt; getAllEmployee()&#123;</div><div class="line">        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();</div><div class="line">        for(int i=0; i&lt;30; i++)&#123;</div><div class="line">            Employee emp = new Employee();</div><div class="line">            //为总公司人员按顺序分配一个ID</div><div class="line">            emp.setId(&quot;总公司&quot;+i);</div><div class="line">            list.add(emp);</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void printAllEmployee(SubCompanyManager sub)&#123;</div><div class="line">        List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();</div><div class="line">        for(SubEmployee e:list1)&#123;</div><div class="line">            System.out.println(e.getId());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        List&lt;Employee&gt; list2 = this.getAllEmployee();</div><div class="line">        for(Employee e:list2)&#123;</div><div class="line">            System.out.println(e.getId());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        CompanyManager e = new CompanyManager();</div><div class="line">        e.printAllEmployee(new SubCompanyManager());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在这个设计的主要问题出在<code>CompanyManager</code>中，根据迪米特法则，只与直接的朋友发生通信，而<code>SubEmployee</code>类并不是<code>CompanyManager</code>类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class SubCompanyManager&#123;</div><div class="line">    public List&lt;SubEmployee&gt; getAllEmployee()&#123;</div><div class="line">        List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;();</div><div class="line">        for(int i=0; i&lt;100; i++)&#123;</div><div class="line">            SubEmployee emp = new SubEmployee();</div><div class="line">            //为分公司人员按顺序分配一个ID</div><div class="line">            emp.setId(&quot;分公司&quot;+i);</div><div class="line">            list.add(emp);</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">    public void printEmployee()&#123;</div><div class="line">        List&lt;SubEmployee&gt; list = this.getAllEmployee();</div><div class="line">        for(SubEmployee e:list)&#123;</div><div class="line">            System.out.println(e.getId());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class CompanyManager&#123;</div><div class="line">    public List&lt;Employee&gt; getAllEmployee()&#123;</div><div class="line">        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();</div><div class="line">        for(int i=0; i&lt;30; i++)&#123;</div><div class="line">            Employee emp = new Employee();</div><div class="line">            //为总公司人员按顺序分配一个ID</div><div class="line">            emp.setId(&quot;总公司&quot;+i);</div><div class="line">            list.add(emp);</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void printAllEmployee(SubCompanyManager sub)&#123;</div><div class="line">        sub.printEmployee();</div><div class="line">        List&lt;Employee&gt; list2 = this.getAllEmployee();</div><div class="line">        for(Employee e:list2)&#123;</div><div class="line">            System.out.println(e.getId());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。</p>
<p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分地使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
<p>问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p>
<p>解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确地告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉得他什么都没说，但貌似又什么都说了。因为开闭原则真得太虚了。</p>
<p>在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守得好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守得好，平均分自然就高，说明软件设计开闭原则遵守得好；如果前面5项原则遵守得不好，则说明开闭原则遵守得不好。</p>
<p>其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象得合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p>
<p>说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭。</p>
<p>最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板地遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。</p>
<p><img src="/img/如何去遵守这六个原则.jpg" alt="如何去遵守这六个原则"></p>
<p>图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守得合理的话，这个点应该落在红色的同心圆内部；如果遵守得差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。<br><img src="/img/一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。.jpg" alt="一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。"></p>
<p>在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。</p>
]]></content>
    
    <summary type="html">
    
      设计模式六大原则
    
    </summary>
    
      <category term="设计原则" scheme="http://jishusuishouji.github.io/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="设计原则" scheme="http://jishusuishouji.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java 类的加载机制</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/java/Java_%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/java/Java_类的加载机制/</id>
    <published>2017-04-05T23:05:01.000Z</published>
    <updated>2017-04-05T23:38:16.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>类的加载:将类的<code>.class</code>文件的二进制数据读入到内存中，将其放在方法区内，然后在堆区创建一个<code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的<code>Class</code>对象，<code>Class</code>对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了<code>.class</code>文件缺失或存在错误，类加载器在程序首次主动使用该类时才报告错误（<code>LinkageError</code>错误）,否则如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p>
<h2 id="加载-class文件的方式"><a href="#加载-class文件的方式" class="headerlink" title="加载.class文件的方式"></a>加载.class文件的方式</h2><p>– 从本地系统中直接加载<br>– 通过网络下载<code>.class</code>文件<br>– 从zip，jar等归档文件中加载<code>.class</code>文件<br>– 从专有数据库中提取<code>.class</code>文件<br>– 将Java源文件动态编译为<code>.class</code>文件</p>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<h3 id="加载：查找并加载类的二进制数据"><a href="#加载：查找并加载类的二进制数据" class="headerlink" title="加载：查找并加载类的二进制数据"></a>加载：查找并加载类的二进制数据</h3><p>加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：<br>1、通过一个类的全限定名来获取其定义的二进制字节流。<br>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>3、在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口。</p>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证：确保被加载的类的正确性"><a href="#验证：确保被加载的类的正确性" class="headerlink" title="验证：确保被加载的类的正确性"></a>验证：确保被加载的类的正确性</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<ol>
<li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证：对字节码描述的信息进行语义分析（注意：对比<code>javac</code>编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有除了<code>java.lang.Object</code>之外的父类。</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：确保解析动作能正确执行。</li>
</ol>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h4 id="准备：为类的静态变量分配内存，并将其初始化为默认值"><a href="#准备：为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="准备：为类的静态变量分配内存，并将其初始化为默认值"></a>准备：为类的静态变量分配内存，并将其初始化为默认值</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：<br>1、这时候进行内存分配的仅包括类变量（<code>static</code>），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。<br>2、这里所设置的初始值通常情况下是数据类型默认的零值（如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等），而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为：<code>public static int value = 3</code>；<br>那么变量<code>value</code>在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何Java方法，而把<code>value</code>赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把<code>value</code>赋值为3的动作将在初始化阶段才会执行。</p>
<p>这里还需要注意如下几点：</p>
<p>· 对基本数据类型来说，对于类变量（<code>static</code>）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。<br>· 对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被<code>final</code>修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。<br>· 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。<br>· 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。<br>3、如果类字段的字段属性表中存在<code>ConstantValue</code>属性，即同时被<code>final</code>和<code>static</code>修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p>
<p>假设上面的类变量value被定义为： <code>public static final int value = 3</code>；</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</p>
<h4 id="解析：把类中的符号引用转换为直接引用"><a href="#解析：把类中的符号引用转换为直接引用" class="headerlink" title="解析：把类中的符号引用转换为直接引用"></a>解析：把类中的符号引用转换为直接引用</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<p>①声明类变量是指定初始值</p>
<p>②使用静态代码块为类变量指定初始值</p>
<h4 id="JVM初始化步骤"><a href="#JVM初始化步骤" class="headerlink" title="JVM初始化步骤"></a>JVM初始化步骤</h4><p>1、假如这个类还没有被加载和连接，则程序先加载并连接该类<br>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类<br>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p>
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：<br>– 创建类的实例，也就是new的方式<br>– 访问某个类或接口的静态变量，或者对该静态变量赋值<br>– 调用类的静态方法<br>– 反射（如Class.forName(“com.shengsiyuan.Test”)）<br>– 初始化某个类的子类，则其父类也会被初始化<br>– Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</p>
<h3 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h3><p>•在如下几种情况下，Java虚拟机将结束生命周期</p>
<p>– 执行了System.exit()方法<br>– 程序正常执行结束<br>– 程序在执行过程中遇到了异常或错误而异常终止<br>– 由于操作系统出现错误而导致Java虚拟机进程终止</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ClassLoaderTest &#123;</div><div class="line">     public static void main(String[] args) &#123;</div><div class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</div><div class="line">        System.out.println(loader);</div><div class="line">        System.out.println(loader.getParent());</div><div class="line">        System.out.println(loader.getParent().getParent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后，输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sun.misc.Launcher$AppClassLoader@64fef26a</div><div class="line">sun.misc.Launcher$ExtClassLoader@1ddd40f3</div><div class="line">null</div></pre></td></tr></table></figure></p>
<p>从上面的结果可以看出，并没有获取到<code>ExtClassLoader</code>的父<code>Loader</code>，原因是Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</p>
<p>这几种类加载器的层次关系如下图所示：<br><img src="/img/类加载器的层次关系.jpg" alt="类加载器的层次关系"><br>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。<br>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<ul>
<li><p>启动类加载器：Bootstrap ClassLoader，负责加载存放在<code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被<code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p>
</li>
<li><p>扩展类加载器：Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>DK\jre\lib\ext</code>目录中，或者由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器：Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<p>1）在执行非置信代码之前，自动验证数字签名。<br>2）动态地创建符合用户特定需要的定制化构建类。<br>3）从特定的场所取得java class，例如数据库中和网络中。</p>
<h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><p>•全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入<br>•父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类<br>•缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
<h2 id="4、类的加载"><a href="#4、类的加载" class="headerlink" title="4、类的加载"></a>4、类的加载</h2><p>类加载有三种方式：</p>
<p>1、命令行启动应用时候由JVM初始化加载<br>2、通过<code>Class.forName()</code>方法动态加载<br>3、通过<code>ClassLoader.loadClass()</code>方法动态加载</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class loaderTest &#123; </div><div class="line">        public static void main(String[] args) throws ClassNotFoundException &#123; </div><div class="line">                ClassLoader loader = HelloWorld.class.getClassLoader(); </div><div class="line">                System.out.println(loader); </div><div class="line">                //使用ClassLoader.loadClass()来加载类，不会执行初始化块 </div><div class="line">                loader.loadClass(&quot;Test2&quot;); </div><div class="line">                //使用Class.forName()来加载类，默认会执行初始化块 </div><div class="line">                Class.forName(&quot;Test2&quot;); </div><div class="line">                //使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </div><div class="line">                Class.forName(&quot;Test2&quot;, false, loader); </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>demo类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Test2 &#123; </div><div class="line">        static &#123; </div><div class="line">                System.out.println(&quot;静态初始化块执行了！&quot;); </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分别切换加载方式，会有不同的输出结果。</p>
<h3 id="Class-forName-和ClassLoader-loadClass-区别"><a href="#Class-forName-和ClassLoader-loadClass-区别" class="headerlink" title="Class.forName()和ClassLoader.loadClass()区别"></a>Class.forName()和ClassLoader.loadClass()区别</h3><p><code>Class.forName()</code>：将类的<code>.class</code>文件加载到jvm中之外，还会对类进行解释，执行类中的static块；<br><code>ClassLoader.loadClass()</code>：只干一件事情，就是将<code>.class</code>文件加载到jvm中，不会执行static中的内容,只有在new Instance才会去执行static块。</p>
<p>注：<br><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了new Instance()方法采用调用构造函数，创建类的对象 。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p>双亲委派机制:<br>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。<br>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。<br>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；<br>4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p>
<p>ClassLoader源码分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException &#123;</div><div class="line">            return loadClass(name, false);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException &#123;</div><div class="line">            // 首先判断该类型是否已经被加载</div><div class="line">            Class c = findLoadedClass(name);</div><div class="line">            if (c == null) &#123;</div><div class="line">                //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</div><div class="line">                try &#123;</div><div class="line">                    if (parent != null) &#123;</div><div class="line">                         //如果存在父类加载器，就委派给父类加载器加载</div><div class="line">                        c = parent.loadClass(name, false);</div><div class="line">                    &#125; else &#123;</div><div class="line">                    //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</div><div class="line">                        c = findBootstrapClass0(name);</div><div class="line">                    &#125;</div><div class="line">                &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                 // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</div><div class="line">                    c = findClass(name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (resolve) &#123;</div><div class="line">                resolveClass(c);</div><div class="line">            &#125;</div><div class="line">            return c;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>双亲委派模型意义：</p>
<p>-系统类防止内存中出现多份同样的字节码<br>-保证Java程序安全稳定运行</p>
<h2 id="6、自定义类加载器"><a href="#6、自定义类加载器" class="headerlink" title="6、自定义类加载器"></a>6、自定义类加载器</h2><p>应用是通过网络来传输Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自<code>ClassLoader</code>类，从上面对loadClass方法来分析来看，我们只需要重写<code>findClass</code> 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">import java.io.*;</div><div class="line"> </div><div class="line">public class MyClassLoader extends ClassLoader &#123;</div><div class="line"> </div><div class="line">    private String root;</div><div class="line"> </div><div class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</div><div class="line">        byte[] classData = loadClassData(name);</div><div class="line">        if (classData == null) &#123;</div><div class="line">            throw new ClassNotFoundException();</div><div class="line">        &#125; else &#123;</div><div class="line">            return defineClass(name, classData, 0, classData.length);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    private byte[] loadClassData(String className) &#123;</div><div class="line">        String fileName = root + File.separatorChar</div><div class="line">                + className.replace(&apos;.&apos;, File.separatorChar) + &quot;.class&quot;;</div><div class="line">        try &#123;</div><div class="line">            InputStream ins = new FileInputStream(fileName);</div><div class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</div><div class="line">            int bufferSize = 1024;</div><div class="line">            byte[] buffer = new byte[bufferSize];</div><div class="line">            int length = 0;</div><div class="line">            while ((length = ins.read(buffer)) != -1) &#123;</div><div class="line">                baos.write(buffer, 0, length);</div><div class="line">            &#125;</div><div class="line">            return baos.toByteArray();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public String getRoot() &#123;</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void setRoot(String root) &#123;</div><div class="line">        this.root = root;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static void main(String[] args)  &#123;</div><div class="line"> </div><div class="line">        MyClassLoader classLoader = new MyClassLoader();</div><div class="line">        classLoader.setRoot(&quot;E:\\temp&quot;);</div><div class="line"> </div><div class="line">        Class&lt;?&gt; testClass = null;</div><div class="line">        try &#123;</div><div class="line">            testClass = classLoader.loadClass(&quot;com.neo.classloader.Test2&quot;);</div><div class="line">            Object object = testClass.newInstance();</div><div class="line">            System.out.println(object.getClass().getClassLoader());</div><div class="line">        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p>
<p>1、这里传递的文件名需要是类的全限定性名称，即com.paddx.test.classloading.Test格式的，因为 defineClass 方法是按这种格式进行处理的。</p>
<p>2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</p>
<p>3、这类Test 类本身可以被 AppClassLoader 类加载，因此我们不能把 com/paddx/test/classloading/Test.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由AppClassLoader 加载，而不会通过我们自定义类加载器来加载。</p>
]]></content>
    
    <summary type="html">
    
      Java 类的加载机制
    
    </summary>
    
      <category term="jav" scheme="http://jishusuishouji.github.io/categories/jav/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>启动ActiveMQ的Broker</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/activemq/%E5%90%AF%E5%8A%A8ActiveMQ%E7%9A%84Broker/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/activemq/启动ActiveMQ的Broker/</id>
    <published>2017-04-05T22:57:20.000Z</published>
    <updated>2017-04-05T23:56:22.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、直接运行安装目录的bin-activemq-bat"><a href="#1、直接运行安装目录的bin-activemq-bat" class="headerlink" title="1、直接运行安装目录的bin\activemq.bat"></a>1、直接运行安装目录的<code>bin\activemq.bat</code></h2><h2 id="2、可以通过在应用程序中以编码的方式启动broker，例如："><a href="#2、可以通过在应用程序中以编码的方式启动broker，例如：" class="headerlink" title="2、可以通过在应用程序中以编码的方式启动broker，例如："></a>2、可以通过在应用程序中以编码的方式启动broker，例如：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BrokerService broker =new BrokerService();  </div><div class="line">broker.setBrokerName(&quot;testName&quot;);//如果启动多个Broker时，必须为Broker设置一个名称  </div><div class="line">broker.addConnector(&quot;tcp://localhost:61616&quot;);  </div><div class="line">broker.start();</div></pre></td></tr></table></figure>
<h2 id="3、可以通过BrokerFactory来创建broker，例如："><a href="#3、可以通过BrokerFactory来创建broker，例如：" class="headerlink" title="3、可以通过BrokerFactory来创建broker，例如："></a>3、可以通过<code>BrokerFactory</code>来创建<code>broker</code>，例如：</h2><pre><code>BrokerService broker =BrokerFactory.createBroker(new URI(&quot;broker:tcp://localhost:61616&quot;));  
broker.start();  
</code></pre><h2 id="4、测代码"><a href="#4、测代码" class="headerlink" title="4、测代码"></a>4、测代码</h2><pre><code>import java.net.URI;  
import org.apache.activemq.broker.BrokerFactory;  
import org.apache.activemq.broker.BrokerService;  

/** 
 * 启动ActiveMQ的代理Broker 
 */  
public class RunningBroker {  
    public static void main(String[] args){  
        try {  
            codeByRunning() ;  //启动Broker  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  

    /** 
     * 应用程序中以编码的方式启动 
     */  
    public static void codeByRunning() throws Exception{  
        BrokerService broker =new BrokerService();  
        broker.setBrokerName(&quot;testName&quot;);//如果启动多个Broker时，必须为Broker设置一个名称  
        broker.addConnector(&quot;tcp://localhost:61616&quot;);  
        broker.start();  
    }  

    /** 
     * 以BrokerFactory的方式启动 
     */  
    public static void factoryByRunning()throws Exception{  
        BrokerService broker =BrokerFactory.createBroker(new URI(&quot;broker:tcp://localhost:61616&quot;));  
        broker.start();  
    }  
}
</code></pre>]]></content>
    
    <summary type="html">
    
      启动ActiveMQ的Broker
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActiveMQ/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ实现负载均衡+高可用部署方案</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/activemq/ActiveMQ%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1_%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/activemq/ActiveMQ实现负载均衡_高可用部署方案/</id>
    <published>2017-04-05T22:29:04.000Z</published>
    <updated>2017-04-05T22:55:23.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、架构和技术介绍"><a href="#一、架构和技术介绍" class="headerlink" title="一、架构和技术介绍"></a>一、架构和技术介绍</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>ActiveMQ完全支持JMS1.1和J2EE 1.4规范的JMS Provider实现。</p>
<h3 id="2、activemq的特性"><a href="#2、activemq的特性" class="headerlink" title="2、activemq的特性"></a>2、activemq的特性</h3><ol>
<li>多种语言和协议编写客户端。语言: Java, C, C++, C#, Ruby, Perl, Python,PHP。应用协议: OpenWire,Stomp REST,WS Notification,XMPP,AMQP</li>
<li>完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务)</li>
<li>对Spring的支持,ActiveMQ可以很容易内嵌到使用Spring的系统里面去,而且也支持Spring2.0的特性</li>
<li>通过了常见J2EE服务器(如 Geronimo,JBoss 4, GlassFish,WebLogic)的测试,其中通过JCA 1.5 resourceadaptors的配置,可以让ActiveMQ可以自动地部署到任何兼容J2EE1.4商业服务器上</li>
<li>支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li>
<li>支持通过JDBC和journal提供高速的消息持久化</li>
<li>从设计上保证了高性能的集群,客户端-服务器,点对点</li>
<li>支持Ajax</li>
<li>支持与Axis的整合</li>
<li>可以很容易得调用内嵌JMS provider,进行测试</li>
</ol>
<h3 id="3、下载和安装ActiveMQ"><a href="#3、下载和安装ActiveMQ" class="headerlink" title="3、下载和安装ActiveMQ"></a>3、下载和安装ActiveMQ</h3><h4 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h4><h4 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h4><p>如果是在windows系统中运行，可以直接解压apache-activemq-5.9.0-bin.zip，并运行bin目录下的activemq.bat文件，此时使用的是默认的服务端口：61616和默认的console端口：8161。</p>
<p>如果是在linux或unix下运行，在bin目录下执行命令：<code>./activemq setup</code></p>
<h4 id="3、修改ActiveMQ的服务端口和console端口"><a href="#3、修改ActiveMQ的服务端口和console端口" class="headerlink" title="3、修改ActiveMQ的服务端口和console端口"></a>3、修改ActiveMQ的服务端口和console端口</h4><p>A、修改服务端口：打开<code>conf/activemq.xml</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> &lt;transportConnectors&gt;</div><div class="line">    &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://10.42.220.72:61618&quot;discoveryUri=&quot;multicast://default&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure></p>
<p>B、修改console的地址和端口:打开<code>conf/jetty.xml</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   &lt;bean id=&quot;jettyPort&quot;class=&quot;org.apache.activemq.web.WebConsolePort&quot;init-method=&quot;start&quot;&gt;</div><div class="line">      &lt;property name=&quot;port&quot; value=&quot;8162&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h4 id="4、通过客户端代码试用ActiveMQ"><a href="#4、通过客户端代码试用ActiveMQ" class="headerlink" title="4、通过客户端代码试用ActiveMQ"></a>4、通过客户端代码试用ActiveMQ</h4><p>需要提前将activemq解压包中的lib目录下的相关包引入到工程中，再进行如下编码：</p>
<h5 id="1、发送端的代码："><a href="#1、发送端的代码：" class="headerlink" title="1、发送端的代码："></a>1、发送端的代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">importjavax.jms.Connection;</div><div class="line">importjavax.jms.ConnectionFactory;</div><div class="line">importjavax.jms.DeliveryMode;</div><div class="line">importjavax.jms.Destination;</div><div class="line">importjavax.jms.MessageProducer;</div><div class="line">importjavax.jms.Session;</div><div class="line">importjavax.jms.TextMessage;</div><div class="line">importorg.apache.activemq.ActiveMQConnection;</div><div class="line">importorg.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"></div><div class="line">publicclass Sender &#123;</div><div class="line">    private static finalint SEND_NUMBER = 5;</div><div class="line"></div><div class="line">    publicstaticvoid main(String[] args) &#123;</div><div class="line">        // ConnectionFactory：连接工厂，JMS用它创建连接</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        // Connection：JMS客户端到JMS Provider的连接</div><div class="line">        Connection connection = null;</div><div class="line">        // Session：一个发送或接收消息的线程</div><div class="line">        Session session;</div><div class="line">        // Destination：消息的目的地;消息发送给谁.</div><div class="line">        Destination destination;</div><div class="line">        // MessageProducer：消息发送者</div><div class="line">        MessageProducer producer;</div><div class="line">        TextMessage message;</div><div class="line">    </div><div class="line">        //构造ConnectionFactory实例对象，此处采用ActiveMq的实现jar</div><div class="line">        connectionFactory = new ActiveMQConnectionFactory(</div><div class="line">                ActiveMQConnection.DEFAULT_USER,</div><div class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</div><div class="line">                &quot;failover:(tcp://10.42.220.72:61617,tcp://10.42.220.72:61618)&quot;);</div><div class="line">        try &#123;</div><div class="line">            //构造从工厂得到连接对象</div><div class="line">            connection =connectionFactory.createConnection();</div><div class="line">            //启动</div><div class="line">            connection.start();</div><div class="line">            //获取操作连接</div><div class="line">            session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);</div><div class="line">            //获取session</div><div class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</div><div class="line">            //得到消息生成者【发送者】</div><div class="line">            producer =session.createProducer(destination);</div><div class="line">            //设置不持久化，此处学习，实际根据项目决定</div><div class="line">            producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</div><div class="line">            //构造消息，此处写死，项目就是参数，或者方法获取</div><div class="line">            sendMessage(session, producer);</div><div class="line">            session.commit();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (null != connection)</div><div class="line">                    connection.close();</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    publicstaticvoid sendMessage(Session session,MessageProducer producer)</div><div class="line">            throws Exception &#123;</div><div class="line">        for (int i = 1; i &lt;=SEND_NUMBER; i++) &#123;</div><div class="line">            TextMessage message = session</div><div class="line">                    .createTextMessage(&quot;ActiveMq发送的消息&quot; + i);</div><div class="line">            //发送消息到目的地方</div><div class="line">            System.out.println(&quot;发送消息：&quot; + &quot;ActiveMq 发送的消息&quot; + i);</div><div class="line">            producer.send(message);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2、接收端代码："><a href="#2、接收端代码：" class="headerlink" title="2、接收端代码："></a>2、接收端代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">importjavax.jms.Connection;</div><div class="line">importjavax.jms.ConnectionFactory;</div><div class="line">importjavax.jms.Destination;</div><div class="line">importjavax.jms.MessageConsumer;</div><div class="line">importjavax.jms.Session;</div><div class="line">importjavax.jms.TextMessage;</div><div class="line">importorg.apache.activemq.ActiveMQConnection;</div><div class="line">importorg.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"> </div><div class="line"></div><div class="line">publicclass Receive &#123;</div><div class="line">    publicstaticvoid main(String[] args) &#123;</div><div class="line">        // ConnectionFactory：连接工厂，JMS用它创建连接</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        // Connection：JMS客户端到JMS Provider的连接</div><div class="line">        Connection connection = null;</div><div class="line">        // Session：一个发送或接收消息的线程</div><div class="line">        Session session;</div><div class="line">        // Destination：消息的目的地;消息发送给谁.</div><div class="line">        Destination destination;</div><div class="line">        //消费者，消息接收者</div><div class="line">        MessageConsumer consumer;</div><div class="line">        connectionFactory = new ActiveMQConnectionFactory(</div><div class="line">                ActiveMQConnection.DEFAULT_USER,</div><div class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</div><div class="line">                &quot;failover:(tcp://10.42.220.72:61617,tcp://10.42.220.72:61618)&quot;);</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            //构造从工厂得到连接对象</div><div class="line">            connection =connectionFactory.createConnection();</div><div class="line">            //启动</div><div class="line">            connection.start();</div><div class="line">            //获取操作连接</div><div class="line">            session = connection.createSession(false,</div><div class="line">                    Session.AUTO_ACKNOWLEDGE);</div><div class="line">            //获取session</div><div class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</div><div class="line">            consumer =session.createConsumer(destination);</div><div class="line">            while (true) &#123;</div><div class="line">                //设置接收者接收消息的时间，为了便于测试，这里谁定为100s</div><div class="line">                TextMessage message =(TextMessage) consumer.receive(100000);</div><div class="line">                if (null != message) &#123;</div><div class="line">                    System.out.println(&quot;收到消息&quot; + message.getText());</div><div class="line">                &#125; else &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (null != connection)</div><div class="line">                    connection.close();</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3、通过监控查看消息堆栈的记录："><a href="#3、通过监控查看消息堆栈的记录：" class="headerlink" title="3、通过监控查看消息堆栈的记录："></a>3、通过监控查看消息堆栈的记录：</h5><p>登陆<code>http://localhost:8162/admin/queues.jsp</code>，默认的用户名和密码：<code>admin/admin</code></p>
<h2 id="二、ActiveMQ的多种部署方式"><a href="#二、ActiveMQ的多种部署方式" class="headerlink" title="二、ActiveMQ的多种部署方式"></a>二、ActiveMQ的多种部署方式</h2><p>单点的ActiveMQ作为企业应用无法满足高可用和集群的需求，所以ActiveMQ提供了master-slave、broker cluster等多种部署方式，但通过分析多种部署方式之后我认为需要将两种部署方式相结合才能满足我们公司分布式和高可用的需求，所以后面就重点将解如何将两种部署方式相结合。</p>
<h3 id="1、Master-Slave部署方式"><a href="#1、Master-Slave部署方式" class="headerlink" title="1、Master-Slave部署方式"></a>1、Master-Slave部署方式</h3><h4 id="1）shared-filesystem-Master-Slave部署方式"><a href="#1）shared-filesystem-Master-Slave部署方式" class="headerlink" title="1）shared filesystem Master-Slave部署方式"></a>1）shared filesystem Master-Slave部署方式</h4><p>主要是通过共享存储目录来实现master和slave的热备，所有的ActiveMQ应用都在不断地获取共享目录的控制权，哪个应用抢到了控制权，它就成为master。</p>
<p>多个共享存储目录的应用，谁先启动，谁就可以最早取得共享目录的控制权成为master，其他的应用就只能作为slave。<br><img src="/img/ActiveMQ Master-Slave部署方式.png" alt="ActiveMQ Master-Slave部署方式"></p>
<h4 id="2）shared-database-Master-Slave方式"><a href="#2）shared-database-Master-Slave方式" class="headerlink" title="2）shared database Master-Slave方式"></a>2）shared database Master-Slave方式</h4><p>与shared filesystem方式类似，只是共享的存储介质由文件系统改成了数据库而已。</p>
<h4 id="3）Replicated-LevelDB-Store方式"><a href="#3）Replicated-LevelDB-Store方式" class="headerlink" title="3）Replicated LevelDB Store方式"></a>3）Replicated LevelDB Store方式</h4><p>这种主备方式是ActiveMQ5.9以后才新增的特性，使用ZooKeeper协调选择一个node作为master。被选择的master broker node开启并接受客户端连接。<br>其他node转入slave模式，连接master并同步他们的存储状态。slave不接受客户端连接。所有的存储操作都将被复制到连接至Master的slaves。</p>
<p>如果master死了，得到了最新更新的slave被允许成为master。fialed node能够重新加入到网络中并连接master进入slave mode。所有需要同步的disk的消息操作都将等待存储状态被复制到其他法定节点的操作完成才能完成。所以，如果你配置了replicas=3，那么法定大小是(3/2)+1=2. Master将会存储并更新然后等待 (2-1)=1个slave存储和更新完成，才汇报success。至于为什么是2-1，熟悉Zookeeper的应该知道，有一个node要作为观擦者存在。</p>
<p>当一个新的master被选中，你需要至少保障一个法定node在线以能够找到拥有最新状态的node。这个node将会成为新的master。因此，推荐运行至少3个replica nodes，以防止一个node失败了，服务中断。</p>
<p><img src="/img/Replicated LevelDB Store方式.png" alt="Replicated LevelDB Store方式"></p>
<h3 id="2、Broker-Cluster部署方式"><a href="#2、Broker-Cluster部署方式" class="headerlink" title="2、Broker-Cluster部署方式"></a>2、Broker-Cluster部署方式</h3><p>前面的Master-Slave的方式虽然能解决多服务热备的高可用问题，但无法解决负载均衡和分布式的问题。Broker-Cluster的部署方式就可以解决负载均衡的问题。</p>
<p>Broker-Cluster部署方式中，各个broker通过网络互相连接，并共享queue。当broker-A上面指定的queue-A中接收到一个message处于pending状态，而此时没有consumer连接broker-A时。如果cluster中的broker-B上面有一个consumer在消费queue-A的消息，那么broker-B会先通过内部网络获取到broker-A上面的message，并通知自己的consumer来消费。</p>
<h4 id="1）static-Broker-Cluster部署"><a href="#1）static-Broker-Cluster部署" class="headerlink" title="1）static Broker-Cluster部署"></a>1）static Broker-Cluster部署</h4><p>在<code>activemq.xml</code>文件中静态指定Broker需要建立桥连接的其他Broker：</p>
<h5 id="1、首先在Broker-A节点中添加networkConnector节点："><a href="#1、首先在Broker-A节点中添加networkConnector节点：" class="headerlink" title="1、首先在Broker-A节点中添加networkConnector节点："></a>1、首先在Broker-A节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61617)&quot;duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="2、修改Broker-A节点中的服务提供端口为61616："><a href="#2、修改Broker-A节点中的服务提供端口为61616：" class="headerlink" title="2、修改Broker-A节点中的服务提供端口为61616："></a>2、修改Broker-A节点中的服务提供端口为61616：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<p>#####3、  在Broker-B节点中添加networkConnector节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61616)&quot;duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure></p>
<h5 id="4、修改Broker-A节点中的服务提供端口为61617："><a href="#4、修改Broker-A节点中的服务提供端口为61617：" class="headerlink" title="4、修改Broker-A节点中的服务提供端口为61617："></a>4、修改Broker-A节点中的服务提供端口为61617：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61617?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="5、分别启动Broker-A和Broker-B。"><a href="#5、分别启动Broker-A和Broker-B。" class="headerlink" title="5、分别启动Broker-A和Broker-B。"></a>5、分别启动Broker-A和Broker-B。</h5><h4 id="2）Dynamic-Broker-Cluster部署"><a href="#2）Dynamic-Broker-Cluster部署" class="headerlink" title="2）Dynamic Broker-Cluster部署"></a>2）Dynamic Broker-Cluster部署</h4><p>在<code>activemq.xml</code>文件中不直接指定Broker需要建立桥连接的其他Broker，由activemq在启动后动态查找：</p>
<h5 id="1、首先在Broker-A节点中添加networkConnector节点：-1"><a href="#1、首先在Broker-A节点中添加networkConnector节点：-1" class="headerlink" title="1、首先在Broker-A节点中添加networkConnector节点："></a>1、首先在Broker-A节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnectoruri=&quot;multicast://default&quot;</div><div class="line">           dynamicOnly=&quot;true&quot;</div><div class="line">           networkTTL=&quot;3&quot;</div><div class="line">           prefetchSize=&quot;1&quot;</div><div class="line">           decreaseNetworkConsumerPriority=&quot;true&quot; /&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="2、修改Broker-A节点中的服务提供端口为61616：-1"><a href="#2、修改Broker-A节点中的服务提供端口为61616：-1" class="headerlink" title="2、修改Broker-A节点中的服务提供端口为61616："></a>2、修改Broker-A节点中的服务提供端口为61616：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61616? &quot; discoveryUri=&quot;multicast://default&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="3、在Broker-B节点中添加networkConnector节点："><a href="#3、在Broker-B节点中添加networkConnector节点：" class="headerlink" title="3、在Broker-B节点中添加networkConnector节点："></a>3、在Broker-B节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">                &lt;networkConnectoruri=&quot;multicast://default&quot;</div><div class="line">           dynamicOnly=&quot;true&quot;</div><div class="line">           networkTTL=&quot;3&quot;</div><div class="line">           prefetchSize=&quot;1&quot;</div><div class="line">           decreaseNetworkConsumerPriority=&quot;true&quot; /&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="4、修改Broker-B节点中的服务提供端口为61617："><a href="#4、修改Broker-B节点中的服务提供端口为61617：" class="headerlink" title="4、修改Broker-B节点中的服务提供端口为61617："></a>4、修改Broker-B节点中的服务提供端口为61617：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61617&quot; discoveryUri=&quot;multicast://default&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="5、启动Broker-A和Broker-B"><a href="#5、启动Broker-A和Broker-B" class="headerlink" title="5、启动Broker-A和Broker-B"></a>5、启动Broker-A和Broker-B</h5><h3 id="2、Master-Slave与Broker-Cluster相结合的部署方式"><a href="#2、Master-Slave与Broker-Cluster相结合的部署方式" class="headerlink" title="2、Master-Slave与Broker-Cluster相结合的部署方式"></a>2、Master-Slave与Broker-Cluster相结合的部署方式</h3><p>可以看到Master-Slave的部署方式虽然解决了高可用的问题，但不支持负载均衡，Broker-Cluster解决了负载均衡，但当其中一个Broker突然宕掉的话，那么存在于该Broker上处于Pending状态的message将会丢失，无法达到高可用的目的。</p>
<p><img src="/img/activemqMaster-Slave与Broker-Cluster相结合的部署方式.png" alt="activemqMaster-Slave与Broker-Cluster相结合的部署方式"></p>
<h4 id="1、部署的配置修改"><a href="#1、部署的配置修改" class="headerlink" title="1、部署的配置修改"></a>1、部署的配置修改</h4><p>这里以Broker-A + Broker-B建立cluster，Broker-C作为Broker-B的slave为例：</p>
<h5 id="1）首先在Broker-A节点中添加networkConnector节点："><a href="#1）首先在Broker-A节点中添加networkConnector节点：" class="headerlink" title="1）首先在Broker-A节点中添加networkConnector节点："></a>1）首先在Broker-A节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;masterslave:(tcp://0.0.0.0:61617,tcp:// 0.0.0.0:61618)&quot; duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="2）修改Broker-A节点中的服务提供端口为61616："><a href="#2）修改Broker-A节点中的服务提供端口为61616：" class="headerlink" title="2）修改Broker-A节点中的服务提供端口为61616："></a>2）修改Broker-A节点中的服务提供端口为61616：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="3）在Broker-B节点中添加networkConnector节点："><a href="#3）在Broker-B节点中添加networkConnector节点：" class="headerlink" title="3）在Broker-B节点中添加networkConnector节点："></a>3）在Broker-B节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61616)&quot;duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h4 id="4）修改Broker-B节点中的服务提供端口为61617："><a href="#4）修改Broker-B节点中的服务提供端口为61617：" class="headerlink" title="4）修改Broker-B节点中的服务提供端口为61617："></a>4）修改Broker-B节点中的服务提供端口为61617：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line"></div><div class="line">         &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61617?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<p>5）修改Broker-B节点中的持久化方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">     &lt;kahaDB directory=&quot;/localhost/kahadb&quot;/&gt;</div><div class="line">  &lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure></p>
<p>6）在Broker-C节点中添加networkConnector节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61616)&quot;duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure></p>
<p>7）修改Broker-C节点中的服务提供端口为61618：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">    &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61618?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure></p>
<p>8）修改Broker-C节点中的持久化方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">     &lt;kahaDB directory=&quot;/localhost/kahadb&quot;/&gt;</div><div class="line"> &lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure></p>
<p>9）分别启动broker-A、broker-B、broker-C，因为是broker-B先启动，所以“/localhost/kahadb”目录被lock住，broker-C将一直处于挂起状态，当人为停掉broker-B之后，broker-C将获取目录“/localhost/kahadb”的控制权，重新与broker-A组成cluster提供服务。</p>
]]></content>
    
    <summary type="html">
    
      ActiveMQ实现负载均衡+高可用部署方案
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActiveMQ/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ理解</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/activemq/ActiveMQ%E7%90%86%E8%A7%A3/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/activemq/ActiveMQ理解/</id>
    <published>2017-04-05T20:25:34.000Z</published>
    <updated>2017-04-05T22:12:57.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Running-Broker"><a href="#Running-Broker" class="headerlink" title="Running Broker"></a>Running Broker</h2><p>直接运行bin/activemq脚本可以启动一个broker。</p>
<p>此外也可以通过Broker Configuration URI或Broker XBean URI对broker进行配置，以下是一些命令行参数的例子：</p>
<ul>
<li><code>activemq</code> Runs a broker using the default ‘<code>xbean:activemq.xml</code>‘ as the broker configuration file. </li>
<li><code>activemq xbean:myconfig.xml</code> Runs a broker using the file <code>myconfig.xml</code> as the broker configuration file that is located in the classpath. </li>
<li><code>activemq xbean:file:./conf/broker1.xml</code> Runs a broker using the file <code>broker1.xml</code> as the broker configuration file that is located in the relative file path <code>./conf/broker1.xml</code> </li>
<li><code>activemq xbean:file:C:/ActiveMQ/conf/broker2.xml</code> Runs a broker using the file <code>broker2.xml</code> as the broker configuration file that is located in the absolute file path <code>C:/ActiveMQ/conf/broker2.xml</code> </li>
<li><code>activemq broker:(tcp://localhost:61616, tcp://localhost:5000)?useJmx=true</code> Runs a broker with two transport connectors and JMX enabled. </li>
<li><code>activemq broker:(tcp://localhost:61616, network:tcp://localhost:5000)?persistent=false</code> Runs a broker with 1 transport connector and 1 network connector with persistence disabled. </li>
</ul>
<h2 id="Embedded-Broker"><a href="#Embedded-Broker" class="headerlink" title="Embedded Broker"></a>Embedded Broker</h2><p>可以通过在应用程序中以编码的方式启动broker，例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = new BrokerService(); </div><div class="line">broker.addConnector(&quot;tcp://localhost:61616&quot;); </div><div class="line">broker.start();</div></pre></td></tr></table></figure>
<p>如果需要启动多个broker，那么需要为broker设置一个名字。例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = new BrokerService(); </div><div class="line">broker.setName(&quot;fred&quot;); </div><div class="line">broker.addConnector(&quot;tcp://localhost:61616&quot;); </div><div class="line">broker.start();</div></pre></td></tr></table></figure>
<p>如果希望在同一个JVM内访问这个broker，那么可以使用VM Transport，URI是：<code>vm://brokerName</code>。 </p>
<h2 id="可以通过BrokerFactory来创建broker，例如："><a href="#可以通过BrokerFactory来创建broker，例如：" class="headerlink" title="可以通过BrokerFactory来创建broker，例如："></a>可以通过<code>BrokerFactory</code>来创建broker，例如：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = BrokerFactory.createBroker(new URI(someURI));</div></pre></td></tr></table></figure>
<p><code>someURI</code>的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>xbean:</code></td>
<td style="text-align:center"><code>xbean:activemq.xml</code></td>
<td style="text-align:center">Searches the classpath for an XML document with the given URI (<code>activemq.xml</code> in this case) which will then be used as the Xml Configuration</td>
</tr>
<tr>
<td style="text-align:center"><code>file:</code></td>
<td style="text-align:center"><code>file:foo/bar/activemq.xml</code></td>
<td style="text-align:center">Loads the given file (in this example <code>foo/bar/activemq.xml</code>) as the Xml Configuration</td>
</tr>
<tr>
<td style="text-align:center"><code>broker:</code></td>
<td style="text-align:center"><code>broker:tcp://localhost:61616</code></td>
<td style="text-align:center">Uses the Broker Configuration URI to configure the broker</td>
</tr>
</tbody>
</table>
<p>当使用<code>XBean</code>的配置方式的时候，需要指定一个xml配置文件，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = BrokerFactory.createBroker(new URI(&quot;xbean:com/test/activemq.xml&quot;));</div></pre></td></tr></table></figure></p>
<p>使用Spring的配置方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;broker&quot; class=&quot;org.apache.activemq.xbean.BrokerFactoryBean&quot;&gt; </div><div class="line">   &lt;property name=&quot;config&quot; value=&quot;classpath:org/apache/activemq/xbean/activemq.xml&quot; /&gt; </div><div class="line">   &lt;property name=&quot;start&quot; value=&quot;true&quot; /&gt; </div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Monitoring-Broker"><a href="#Monitoring-Broker" class="headerlink" title="Monitoring Broker"></a>Monitoring Broker</h2><h3 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h3><p>在使用JMX监控broker之前，首先要启用broker的JMX监控功能，例如在配置文件中设置<code>useJmx=&quot;true&quot;</code>，如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;broker useJmx=&quot;true&quot; brokerName=&quot;broker1&gt; </div><div class="line">    &lt;managementContext&gt; </div><div class="line">         &lt;managementContext createConnector=&quot;true&quot;/&gt; </div><div class="line">    &lt;/managementContext&gt; </div><div class="line"> ... </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure>
<p>接下来运行JDK自带的jconsole。在运行了jconsole后，它会弹出对话框来选择需要连接到的<code>agent</code>。如果是在启动broker的主机上运行jconsole，那么ActiveMQ broker会出现在jconsole的Local标签中。如果要连接到远程的broker，那么可以在Advanced标签中指定JMX URL，以下是一个连接到本机的JMX URL：<br><code>service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi</code><br>在jconsole的MBeans标签中，可以查看详细信息，也可以执行相应的operation。需要注意的是，在jconsole连接到broker的时候，并不需要输入用户名和密码，如果这存在潜在的安全问题，那么就需要为JMX Connector配置密码保护（需要使用1.5以上版本的JDK）。 </p>
<p>首先要禁止ActiveMQ创建自己的connector，例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.org/config/1.0&quot; brokerName=&quot;localhost&quot;useJmx=&quot;true&quot;&gt; </div><div class="line">    &lt;managementContext&gt; </div><div class="line">        &lt;managementContext createConnector=&quot;false&quot;/&gt; </div><div class="line">    &lt;/managementContext&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure>
<p>然后在ActiveMQ的<code>conf</code>目录下创建一个访问控制文件和密码文件，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">conf/jmx.access： </div><div class="line"># The &quot;monitorRole&quot; role has readonly access. </div><div class="line"># The &quot;controlRole&quot; role has readwrite access. </div><div class="line">monitorRole readonly </div><div class="line">controlRole readwrite</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">conf/jmx.password： </div><div class="line"># The &quot;monitorRole&quot; role has password &quot;abc123&quot;. </div><div class="line"># The &quot;controlRole&quot; role has password &quot;abcd1234&quot;. </div><div class="line">monitorRole abc123 </div><div class="line">controlRole abcd1234</div></pre></td></tr></table></figure>
<p>然后修改ActiveMQ的bin目录下activemq的启动脚本，查找包含”<code>SUNJMX=</code>“的一行如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">REM set SUNJMX=-Dcom.sun.management.jmxremote.port=1616 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false</div></pre></td></tr></table></figure>
<p>把它替换成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set SUNJMX=-Dcom.sun.management.jmxremote.port=1616 -Dcom.sun.management.jmxremote.authenticate=true -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.password.file=%ACTIVEMQ_BASE%/conf/jmx.password -Dcom.sun.management.jmxremote.access.file=%ACTIVEMQ_BASE%/conf/jmx.access</div></pre></td></tr></table></figure>
<p>最后重启ActiveMQ和jconsole，这时候需要强制login。如果在启动activemq的过程中出现以下错误，那么需要为这个文件增加访问控制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error: Password file read access must be restricted: D:\apache-activemq-5.0.0\bin\../conf/jmx.password</div></pre></td></tr></table></figure></p>
<h3 id="Web-Console"><a href="#Web-Console" class="headerlink" title="Web Console"></a>Web Console</h3><p>Web Console被集成到了ActiveMQ的二进制发布包中，因此缺省访问<code>http://localhost:8161/admin</code>即可访问Web Console。<br>在配置文件中，可以通过修改<code>nioConnector</code>的<code>port</code>属性来修改Web console的缺省端口： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;jetty xmlns=&quot;http://mortbay.com/schemas/jetty/1.0&quot;&gt; </div><div class="line">        &lt;connectors&gt; </div><div class="line">                &lt;nioConnector port=&quot;8161&quot; /&gt; </div><div class="line">        &lt;/connectors&gt; </div><div class="line">        ... </div><div class="line">&lt;/jetty&gt;</div></pre></td></tr></table></figure>
<p>出于安全性或者可靠性的考虑，Web Console可以被部署到不同于ActiveMQ的进程中。例如把<code>activemq-web-console.war</code>部署到一个单独的web容器中（Tomcat，Jetty等）。在ActiveMQ5.0的二进制发布包中不包含<code>activemq-web-console.war</code>，因此需要下载 ActiveMQ的源码，然后进入到<code>${activemq.base}/src/activemq-web-console</code>目录中执行<code>mvn instanll</code>。如果一切正常，那么缺省会在<code>${activemq.base}/src/activemq-web-console/target</code>目录中生成<code>activemq-web-console-5.0.0.war</code>。然后将<code>activemq-web-console-5.0.0.war</code>拷贝到Tomcat的<code>webapps</code>目录中，并重命名成<code>activemq-web-console.war</code>。<br>需要注意的是，要将<code>activemq-all-5.0.0.jar</code>拷贝到<code>WEB-INF\lib</code>目录中（可能还需要拷贝<code>jms.jar</code>）。还要为Tomcat设置以下五个系统属性（修改<code>catalina.bat</code>文件）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.type=&quot;properties&quot; </div><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.jms.url=&quot;tcp://localhost:61616&quot; </div><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.jmx.url=&quot;service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi&quot; </div><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.jmx.role=&quot;&quot; </div><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.jmx.password=&quot;&quot;</div></pre></td></tr></table></figure></p>
<p>如果JMX没有配置密码保护，那么<code>webconsole.jmx.role</code>和<code>webconsole.jmx.password</code>设置成<code>&quot;&quot;</code>即可。如果broker被配置成了Master/Slave模式，那么可以配置成使用failover transport，例如： </p>
<pre><code>-Dwebconsole.jms.url=failover:(tcp://serverA:61616,tcp://serverB:61616)
</code></pre><p>顺便说一下，由于<code>webconsole.type</code>属性是<code>properties</code>，因此实际上起作用的Web Console的配置文件是<code>WEB-INF/webconsole-properties.xml</code>。最后启动被监控的ActiveMQ，访问<code>http://localhost:8080 /activemq-web-console/</code>，查看显示是否正常。 </p>
<h3 id="Advisory-Message"><a href="#Advisory-Message" class="headerlink" title="Advisory Message"></a>Advisory Message</h3><p>ActiveMQ支持Advisory Messages，它允许你通过标准的JMS消息来监控系统。目前的Advisory Messages支持：<br>• consumers, producers and connections starting and stopping<br>• temporary destinations being created and destroyed<br>• messages expiring on topics and queues<br>• brokers sending messages to destinations with no consumers.<br>• connections starting and stopping </p>
<p>Advisory Messages可以被想象成某种的管理通道，通过它你可以得到关于JMS provider、producers、consumers和destinations的信息。Advisory topics都使用<code>ActiveMQ.Advisory.</code>这个前缀，以下是目前支持的topics： </p>
<p>Client based advisories<br>Advisory Topics Description<br>ActiveMQ.Advisory.Connection Connection start &amp; stop messages<br>ActiveMQ.Advisory.Producer.Queue Producer start &amp; stop messages on a Queue<br>ActiveMQ.Advisory.Producer.Topic Producer start &amp; stop messages on a Topic<br>ActiveMQ.Advisory.Consumer.Queue Consumer start &amp; stop messages on a Queue<br>ActiveMQ.Advisory.Consumer.Topic Consumer start &amp; stop messages on a Topic </p>
<p>在消费者启动/停止的Advisory Messages的消息头中有个<code>consumerCount</code>属性，它用来指明目前desination上活跃的consumer的数量。<br>Destination and Message based advisories<br>Advisory Topics Description<br>ActiveMQ.Advisory.Queue Queue create &amp; destroy<br>ActiveMQ.Advisory.Topic Topic create &amp; destroy<br>ActiveMQ.Advisory.TempQueue Temporary Queue create &amp; destroy<br>ActiveMQ.Advisory.TempTopic Temporary Topic create &amp; destroy<br>ActiveMQ.Advisory.Expired.Queue Expired messages on a Queue<br>ActiveMQ.Advisory.Expired.Topic Expired messages on a Topic<br>ActiveMQ.Advisory.NoConsumer.Queue No consumer is available to process messages being sent on a Queue<br>ActiveMQ.Advisory.NoConsumer.Topic No consumer is available to process messages being sent on a Topic </p>
<p>以上的这些destnations都可以用来作为前缀，在其后面追加其它的重要信息，例如topic、queue、clientID、 producderID和consumerID等。这令你可以利用Wildcards和Selectors来过滤Advisory Messages。<br>例如，如果你希望订阅<code>FOO.BAR</code>这个queue上Consumer的start/stop的消息，那么可以订阅<code>ActiveMQ.Advisory.Consumer.Queue.FOO.BAR</code>；如果希望订阅所有queue上的start/stop消息，那么可以订阅<code>ActiveMQ.Advisory.Consumer.Queue.</code>；如果希望订阅所有queue或者topic上的start/stop消息，那么可以订阅<code>ActiveMQ.Advisory.Consumer.</code>。<br><code>org.apache.activemq.advisory.AdvisorySupport</code>类上有如下的helper methods，用来在程序中得到advisory destination objects。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">AdvisorySupport.getConsumerAdvisoryTopic() </div><div class="line">AdvisorySupport.getProducerAdvisoryTopic() </div><div class="line">AdvisorySupport.getDestinationAdvisoryTopic() </div><div class="line">AdvisorySupport.getExpiredTopicMessageAdvisoryTopic() </div><div class="line">AdvisorySupport.getExpiredQueueMessageAdvisoryTopic() </div><div class="line">AdvisorySupport.getNoTopicConsumersAdvisoryTopic() </div><div class="line">AdvisorySupport.getNoQueueConsumersAdvisoryTopic()</div></pre></td></tr></table></figure></p>
<p>以下是段使用Advisory Messages的程序代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Destination advisoryDestination = AdvisorySupport.getProducerAdvisoryTopic(destination) </div><div class="line">MessageConsumer consumer = session.createConsumer(advisoryDestination); </div><div class="line">consumer.setMessageListener(this); </div><div class="line">... </div><div class="line">public void onMessage(Message msg)&#123; </div><div class="line">        if (msg instanceof ActiveMQMessage)&#123; </div><div class="line">                try &#123; </div><div class="line">                        ActiveMQMessage aMsg = (ActiveMQMessage)msg; </div><div class="line">                        ProducerInfo prod = (ProducerInfo) aMsg.getDataStructure(); </div><div class="line">                &#125; catch (JMSException e) &#123; </div><div class="line">                        log.error(&quot;Failed to process message: &quot; + msg); </div><div class="line">                &#125; </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Command-Agent"><a href="#Command-Agent" class="headerlink" title="Command Agent"></a>Command Agent</h3><p>在介绍Command Agent前首先简要介绍一下XMPP(Jabber)协议，XMPP是一种基于XML的即时通信协议，它由Jabber软件基金会开发。在配置文件中通过增加<code>transportConnector</code>来支持XMPP协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.org/config/1.0&quot;&gt; </div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">        ... </div><div class="line">                &lt;transportConnector name=&quot;xmpp&quot; uri=&quot;xmpp://localhost:61222&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>ActiveMQ提供了ActiveMQ messages和XMPP之间的双向桥接：<br>• 如果客户加入了一个聊天室，那么这个聊天室的名字会被映射到一个JMS topic。<br>• 尝试在聊天室内发送消息会导致一个JMS消息被发送到这个topic。<br>• 呆在一个聊天室中意味着这将保持一个对相应JMS topic的订阅。因此发送到这个topic的JMS消息也会被发送到聊天室。</p>
<p>从4.2版本起，ActiveMQ支持<code>Command Agent</code>。在配置文件中，通过设置<code>commandAgent</code>来启用Command Agent： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt; </div><div class="line">        &lt;broker useJmx=&quot;true&quot; xmlns=&quot;http://activemq.org/config/1.0&quot;&gt; </div><div class="line">        ... </div><div class="line">        &lt;/broker&gt; </div><div class="line">        &lt;commandAgent xmlns=&quot;http://activemq.org/config/1.0&quot;/&gt; </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>启用了Command Agent的broker上会有一个来自Command Agent的连接，它同时订阅topic：<code>ActiveMQ.Agent</code>。在你启动XMPP客户端，加入到<code>ActiveMQ.Agent</code>聊天室后，就可以同broker进行交谈了。通过在XMPP客户端中键入help，可以得到帮助信息。<br>需要注意的是，ActiveMQ5.0版本有个小bug，如果broker没有采用缺省的用户名和密码，那么Command Agent便无法正常启动。Apache官方文档说，此bug已经被修正，预定在5.2.0版本上体现。修改方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;commandAgent xmlns=&quot;http://activemq.org/config/1.0&quot; brokerUser=&quot;user&quot; brokerPassword=&quot;passward&quot;/&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Visualization-plugin"><a href="#Visualization-plugin" class="headerlink" title="Visualization plugin"></a>Visualization plugin</h3><p>ActiveMQ支持以broker插件的形式生成DOT文件(可以用agrviewer来查看)，以图表的方式描述connections、sessions、producers、consumers、destinations等信息。配置方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.org/config/1.0&quot; brokerName=&quot;localhost&quot; useJmx=&quot;true&quot;&gt; </div><div class="line">        ... </div><div class="line">    &lt;plugins&gt; </div><div class="line">        &lt;connectionDotFilePlugin file=&quot;connection.dot&quot;/&gt; </div><div class="line">        &lt;destinationDotFilePlugin file=&quot;destination.dot&quot;/&gt; </div><div class="line">        &lt;/plugins&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，笔者认为ActiveMQ5.0版本的Visualization Plugin尚不稳定，存在诸多问题。例如：如果使用<code>connectionDotFilePlugin</code>，那么<code>brokerName</code>必须是<code>localhost</code>；如果使用<code>destinationDotFilePlugin</code>可能会导致<code>ArrayStoreException</code>。 </p>
<h2 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h2><p>ActiveMQ目前支持的transport有：VM Transport、TCP Transport、SSL Transport、Peer Transport、UDP Transport、Multicast Transport、HTTP and HTTPS Transport、Failover Transport、Fanout Transport、Discovery Transport、ZeroConf Transport等。</p>
<h3 id="VM-Transport"><a href="#VM-Transport" class="headerlink" title="VM Transport"></a>VM Transport</h3><p>VM transport允许在VM内部通信，从而避免了网络传输的开销。这时候采用的连接不是socket连接，而是直接地方法调用。 第一个创建VM连接的客户会启动一个embed VM broker，接下来所有使用相同的broker name的VM连接都会使用这个broker。当这个broker上所有的连接都关闭的时候，这个broker也会自动关闭。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vm://brokerName?transportOptions</div></pre></td></tr></table></figure>
<p>例如：<code>vm://broker1?marshal=false&amp;broker.persistent=false</code><br>Transport Options的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Option Name</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Marshal</td>
<td style="text-align:center">false</td>
<td style="text-align:center">If true, forces each command sent over the transport to be marshlled and unmarshlled using a WireFormat</td>
</tr>
<tr>
<td style="text-align:center">wireFormat</td>
<td style="text-align:center">default</td>
<td style="text-align:center">The name of the WireFormat to use </td>
</tr>
</tbody>
</table>
<p>wireFormat.<em> All the properties with this prefix are used to configure the wireFormat |<br>| create |  true |  If the broker should be created on demand if it does not allready exist. Only supported in ActiveMQ 4.1 |<br>| broker.</em>  | All  | the properties with this prefix are used to configure the broker. See Configuring Wire Formats for more information  | </p>
<p>以下是高级配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vm:(broker:(tcp://localhost)?brokerOptions)?transportOptions </div><div class="line">vm:broker:(tcp://localhost)?brokerOptions</div></pre></td></tr></table></figure></p>
<p>例如：<code>vm:(broker:(tcp://localhost:6000)?persistent=false)?marshal=false</code> </p>
<p>使用配置文件的配置语法：<br><code>vm://localhost?brokerConfig=xbean:activemq.xml</code><br>例如：<code>vm:// localhost?brokerConfig=xbean:com/test/activemq.xml</code></p>
<p>使用Spring的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;broker&quot; class=&quot;org.apache.activemq.xbean.BrokerFactoryBean&quot;&gt; </div><div class="line">        &lt;property name=&quot;config&quot; value=&quot;classpath:org/apache/activemq/xbean/activemq.xml&quot; /&gt; </div><div class="line">        &lt;property name=&quot;start&quot; value=&quot;true&quot; /&gt; </div><div class="line">        &lt;/bean&gt; </div><div class="line"></div><div class="line">&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot; depends-on=&quot;broker&quot;&gt; </div><div class="line">&lt;property name=&quot;brokerURL&quot; value=&quot;vm://localhost&quot;/&gt; </div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>如果<code>persistent</code>是<code>true</code>，那么ActiveMQ会在当前目录下创建一个缺省值是<code>activemq-data</code>的目录用于持久化保存数据。需要注意的是，如果程序中启动了多个不同名字的VM broker，那么可能会有如下警告：<code>Failed to start jmx connector: Cannot bind to URL [rmi://localhost:1099/jmxrmi]:javax.naming.NameAlreadyBoundException…</code>可以通过在<code>transportOptions</code>中追加<code>broker.useJmx=false</code>来禁用JMX来避免这个警告。 </p>
<h3 id="TCP-Transport"><a href="#TCP-Transport" class="headerlink" title="TCP Transport"></a>TCP Transport</h3><p>TCP transport 允许客户端通过TCP socket连接到远程的broker。以下是配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcp://hostname:port?transportOptions</div></pre></td></tr></table></figure></p>
<p>Transport Options的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Option Name</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">minmumWireFormatVersion</td>
<td style="text-align:center">0</td>
<td style="text-align:center">The minimum version wireformat that is allowed</td>
</tr>
<tr>
<td style="text-align:center">trace</td>
<td style="text-align:center">false</td>
<td style="text-align:center">Causes all commands that are sent over the transport to be logged</td>
</tr>
<tr>
<td style="text-align:center">useLocalHost</td>
<td style="text-align:center">true</td>
<td style="text-align:center">When true, it causes the local machines name to resolve to “localhost”.</td>
</tr>
<tr>
<td style="text-align:center">socketBufferSize</td>
<td style="text-align:center">64 * 1024</td>
<td style="text-align:center">Sets the socket buffer size in bytes </td>
</tr>
</tbody>
</table>
<p>soTimeout 0 sets the socket timeout in milliseconds |<br>| connectionTimeout | 30000 | A non-zero value specifies the connection timeout in milliseconds. A zero value means wait forever for the connection to be established. Negative values are ignored. |<br>| wireFormat | default | The name of the WireFormat to use wireFormat.* All the properties with this prefix are used to configure the wireFormat. See Configuring Wire Formats for more information  | </p>
<p>例如：<code>tcp://localhost:61616?trace=false</code> </p>
<h3 id="Failover-Transport"><a href="#Failover-Transport" class="headerlink" title="Failover Transport"></a>Failover Transport</h3><p>Failover Transport是一种重新连接的机制，它工作于其它transport的上层，用于建立可靠的传输。它的配置语法允许制定任意多个复合的URI。Failover transport会自动选择其中的一个URI来尝试建立连接。如果没有成功，那么会选择一个其它的URI来建立一个新的连接。以下是配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">failover:(uri1,...,uriN)?transportOptions </div><div class="line">failover:uri1,...,uriN</div></pre></td></tr></table></figure></p>
<p>Transport Options的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Option Name</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">initialReconnectDelay</td>
<td style="text-align:center">10</td>
<td style="text-align:center">How long to wait before the first reconnect attempt (in ms)</td>
</tr>
<tr>
<td style="text-align:center">maxReconnectDelay</td>
<td style="text-align:center">30000</td>
<td style="text-align:center">The maximum amount of time we ever wait between reconnect attempts (in ms)</td>
</tr>
<tr>
<td style="text-align:center">useExponentialBackOff</td>
<td style="text-align:center">true</td>
<td style="text-align:center">Should an exponential backoff be used between reconnect attempts</td>
</tr>
<tr>
<td style="text-align:center">backOffMultiplier</td>
<td style="text-align:center">2</td>
<td style="text-align:center">The exponent used in the exponential backoff attempts</td>
</tr>
<tr>
<td style="text-align:center">maxReconnectAttempts</td>
<td style="text-align:center">0</td>
<td style="text-align:center">If not 0, then this is the maximum number of reconnect attempts before an error is sent back to the client</td>
</tr>
<tr>
<td style="text-align:center">randomize</td>
<td style="text-align:center">true</td>
<td style="text-align:center">use a random algorithm to choose the URI to use for reconnect from the list provided</td>
</tr>
<tr>
<td style="text-align:center">backup</td>
<td style="text-align:center">false</td>
<td style="text-align:center">initialize and hold a second transport connection - to enable fast failover</td>
</tr>
</tbody>
</table>
<p>例如：<code>failover:(tcp://localhost:61616,tcp://remotehost:61616)?initialReconnectDelay=100</code></p>
<h3 id="Discovery-transport"><a href="#Discovery-transport" class="headerlink" title="Discovery transport"></a>Discovery transport</h3><p>Discovery transport是可靠的tranport。它使用Discovery transport来定位用来连接的URI列表。以下是配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">discovery:(discoveryAgentURI)?transportOptions </div><div class="line">discovery:discoveryAgentURI</div></pre></td></tr></table></figure></p>
<p>Transport Options的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Option Name</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">initialReconnectDelay</td>
<td style="text-align:center">10</td>
<td style="text-align:center">How long to wait before the first reconnect attempt</td>
</tr>
<tr>
<td style="text-align:center">maxReconnectDelay</td>
<td style="text-align:center">30000</td>
<td style="text-align:center">The maximum amount of time we ever wait between reconnect attempts</td>
</tr>
<tr>
<td style="text-align:center">useExponentialBackOff</td>
<td style="text-align:center">true</td>
<td style="text-align:center">Should an exponential backoff be used btween reconnect attempts</td>
</tr>
<tr>
<td style="text-align:center">backOffMultiplier</td>
<td style="text-align:center">2</td>
<td style="text-align:center">The exponent used in the exponential backoff attempts</td>
</tr>
<tr>
<td style="text-align:center">maxReconnectAttempts</td>
<td style="text-align:center">0</td>
<td style="text-align:center">If not 0, then this is the maximum number of reconnect attempts before an error is sent back to the client</td>
</tr>
</tbody>
</table>
<p>例如：<code>discovery:(multicast://default)?initialReconnectDelay=100</code><br>为了使用Discovery来发现broker，需要为broker启用discovery agent。 以下是XML配置文件中的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;broker name=&quot;foo&quot;&gt; </div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">                &lt;transportConnector uri=&quot;tcp://localhost:0&quot; discoveryUri=&quot;multicast://default&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line">... </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>在使用Failover Transport或Discovery transport等能够自动重连的transport的时候，需要注意的是：设想有两个broker，它们都启用AMQ Message Store作为持久化存储，有一个producer和一个consumer连接到某个queue。当因其中一个broker失效时而切换到另一个 broker的时候，如果失效的broker的queue中还有未被consumer消费的消息，那么这个queue里的消息仍然滞留在失效broker 的中，直到失效的broker被修复并重新切换回这个被修复的broker后，之前被保留的消息才会被consumer消费掉。如果被处理的消息有时序限制，那么应用程序就需要处理这个问题。另外也可以通过ActiveMQ集群来解决这个问题。<br>在transport重连的时候，可以在connection上注册<code>TransportListener</code>来获得回调，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(ActiveMQConnection)connection).addTransportListener(new TransportListener() &#123; </div><div class="line">public void onCommand(Object cmd) &#123; </div><div class="line">&#125; </div><div class="line"></div><div class="line">public void onException(IOException exp) &#123; </div><div class="line">&#125; </div><div class="line"></div><div class="line">public void transportInterupted() &#123; </div><div class="line">// The transport has suffered an interruption from which it hopes to recover. </div><div class="line">&#125; </div><div class="line"> </div><div class="line">public void transportResumed() &#123; </div><div class="line">// The transport has resumed after an interruption. </div><div class="line">&#125; </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h2><h3 id="AMQ-Message-Store"><a href="#AMQ-Message-Store" class="headerlink" title="AMQ Message Store"></a>AMQ Message Store</h3><p>AMQ Message Store是ActiveMQ5.0缺省的持久化存储。Message commands被保存到transactional journal（由rolling data logs组成）。Messages被保存到data logs中，同时被reference store进行索引以提高存取速度。Date logs由一些单独的data log文件组成，缺省的文件大小是32M，如果某个消息的大小超过了data log文件的大小，那么可以修改配置以增加data log文件的大小。如果某个data log文件中所有的消息都被成功消费了，那么这个data log文件将会被标记，以便在下一轮的清理中被删除或者归档。以下是其配置的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=&quot;broker&quot; persistent=&quot;true&quot; useShutdownHook=&quot;false&quot;&gt; </div><div class="line">        &lt;persistenceAdapter&gt; </div><div class="line">                &lt;amqPersistenceAdapter directory=&quot;$&#123;activemq.base&#125;/data&quot; maxFileLength=&quot;32mb&quot;/&gt; </div><div class="line">        &lt;/persistenceAdapter&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">Property name</th>
<th style="text-align:center">Default value</th>
<th style="text-align:center">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">directory</td>
<td style="text-align:center">activemq-data</td>
<td style="text-align:center">the path to the directory to use to store the message store data and log files</td>
</tr>
<tr>
<td style="text-align:center">useNIO</td>
<td style="text-align:center">true</td>
<td style="text-align:center">use NIO to write messages to the data logs</td>
</tr>
<tr>
<td style="text-align:center">syncOnWrite</td>
<td style="text-align:center">false</td>
<td style="text-align:center">sync every write to disk</td>
</tr>
<tr>
<td style="text-align:center">maxFileLength</td>
<td style="text-align:center">32mb</td>
<td style="text-align:center">a hint to set the maximum size of the message data logs</td>
</tr>
<tr>
<td style="text-align:center">persistentIndex</td>
<td style="text-align:center">true</td>
<td style="text-align:center">use a persistent index for the message logs. If this is false, an in-memory structure is maintained</td>
</tr>
<tr>
<td style="text-align:center">maxCheckpointMessageAddSize</td>
<td style="text-align:center">4kb</td>
<td style="text-align:center">the maximum number of messages to keep in a transaction before automatically committing</td>
</tr>
<tr>
<td style="text-align:center">cleanupInterval</td>
<td style="text-align:center">30000</td>
<td style="text-align:center">time (ms) before checking for a discarding/moving message data logs that are no longer used</td>
</tr>
<tr>
<td style="text-align:center">indexBinSize</td>
<td style="text-align:center">1024</td>
<td style="text-align:center">default number of bins used by the index. The bigger the bin size - the better the relative performance of the index</td>
</tr>
<tr>
<td style="text-align:center">indexKeySize</td>
<td style="text-align:center">96</td>
<td style="text-align:center">the size of the index key - the key is the message id </td>
</tr>
</tbody>
</table>
<p>indexPageSize 16kb the size of the index page - the bigger the page - the better the write performance of the index  |<br>| directoryArchive | archive | the path to the directory to use to store discarded data logs |<br>| archiveDataLogs | false | if true data logs are moved to the archive directory instead of being deleted | </p>
<h3 id="Kaha-Persistence"><a href="#Kaha-Persistence" class="headerlink" title="Kaha Persistence"></a>Kaha Persistence</h3><p>Kaha Persistence 是一个专门针对消息持久化的解决方案。它对典型的消息使用模式进行了优化。在Kaha中，数据被追加到data logs中。当不再需要log文件中的数据的时候，log文件会被丢弃。以下是其配置的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=&quot;broker&quot; persistent=&quot;true&quot; useShutdownHook=&quot;false&quot;&gt; </div><div class="line">        &lt;persistenceAdapter&gt; </div><div class="line">                &lt;kahaPersistenceAdapter directory=&quot;activemq-data&quot;       maxDataFileLength=&quot;33554432&quot;/&gt; </div><div class="line">        &lt;/persistenceAdapter&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h3 id="JDBC-Persistence"><a href="#JDBC-Persistence" class="headerlink" title="JDBC Persistence"></a>JDBC Persistence</h3><p>目前支持的数据库有Apache Derby, Axion, DB2, HSQL, Informix, MaxDB, MySQL, Oracle, Postgresql, SQLServer, Sybase。<br>如果你使用的数据库不被支持，那么可以调整<code>StatementProvider</code>来保证使用正确的SQL方言（flavour of SQL）。通常绝大多数数据库支持以下adaptor：<br>• org.activemq.store.jdbc.adapter.BlobJDBCAdapter<br>• org.activemq.store.jdbc.adapter.BytesJDBCAdapter<br>• org.activemq.store.jdbc.adapter.DefaultJDBCAdapter<br>• org.activemq.store.jdbc.adapter.ImageJDBCAdapter</p>
<p>也可以在配置文件中直接指定JDBC adaptor，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;jdbcPersistenceAdapter adapterClass=&quot;org.apache.activemq.store.jdbc.adapter.ImageBasedJDBCAdaptor&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>以下是其配置的一个例子： </p>
<pre><code>&lt;persistence&gt; 
     &lt;jdbcPersistence dataSourceRef=&quot; mysql-ds&quot;/&gt; 
&lt;/persistence&gt; 

&lt;bean id=&quot;mysql-ds&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; 
     &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; 
     &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/activemq?relaxAutoCommit=true&quot;/&gt; 
     &lt;property name=&quot;username&quot; value=&quot;activemq&quot;/&gt; 
     &lt;property name=&quot;password&quot; value=&quot;activemq&quot;/&gt; 
     &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt; 
&lt;/bean&gt; 
</code></pre><p>需要注意的是，如果使用MySQL，那么需要设置<code>relaxAutoCommit</code>标志为<code>true</code>。 </p>
<h3 id="Disable-Persistence"><a href="#Disable-Persistence" class="headerlink" title="Disable Persistence"></a>Disable Persistence</h3><p>以下是其配置的一个例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;broker persistent=&quot;false&quot;&gt;&lt;/broker&gt;</div></pre></td></tr></table></figure>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p>ActiveMQ支持可插拔的安全机制，用以在不同的provider之间切换。 </p>
<h3 id="Simple-Authentication-Plugin"><a href="#Simple-Authentication-Plugin" class="headerlink" title="Simple Authentication Plugin"></a>Simple Authentication Plugin</h3><p>Simple Authentication Plugin适用于简单的认证需求，或者用于建立测试环境。它允许在XML配置文件中指定用户、用户组和密码等信息。以下是ActiveMQ配置的一个例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;plugins&gt; </div><div class="line">        ... </div><div class="line">        &lt;simpleAuthenticationPlugin&gt; </div><div class="line">                &lt;users&gt; </div><div class="line">                     &lt;authenticationUser username=&quot;system&quot; password=&quot;manager&quot;   groups=&quot;users,admins&quot;/&gt; </div><div class="line">                     &lt;authenticationUser username=&quot;user&quot; password=&quot;password&quot; groups=&quot;users&quot;/&gt; </div><div class="line">                     &lt;authenticationUser username=&quot;guest&quot; password=&quot;password&quot; groups=&quot;guests&quot;/&gt; </div><div class="line">                &lt;/users&gt; </div><div class="line">        &lt;/simpleAuthenticationPlugin&gt; </div><div class="line">&lt;/plugins&gt;</div></pre></td></tr></table></figure>
<h3 id="JAAS-Authentication-Plugin"><a href="#JAAS-Authentication-Plugin" class="headerlink" title="JAAS Authentication Plugin"></a>JAAS Authentication Plugin</h3><p>JAAS Authentication Plugin依赖标准的JAAS机制来实现认证。通常情况下，你需要通过设置<code>java.security.auth.login.config</code>系统属性来配置login modules的配置文件。如果没有指定这个系统属性，那么JAAS Authentication Plugin会缺省使用<code>login.config</code>作为文件名。以下是一个<code>login.config</code>文件的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">activemq-domain &#123; </div><div class="line">        org.apache.activemq.jaas.PropertiesLoginModule required debug=true org.apache.activemq.jaas.properties.user=&quot;users.properties&quot; org.apache.activemq.jaas.properties.group=&quot;groups.properties&quot;; </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个<code>login.config</code>文件中设置了两个属性：<code>org.apache.activemq.jaas.properties.user</code>和<code>org.apache.activemq.jaas.properties.group</code>分别用来指向<code>user.properties</code>和<code>group.properties</code>文件。需要注意的是，<code>PropertiesLoginModule</code>使用本地文件的查找方式，而且查找时采用的base directory是<code>login.config</code>文件所在的目录。因此这个<code>login.config</code>说明<code>user.properties</code>和<code>group.properties</code>文件存放在跟<code>login.config</code>文件相同的目录里。<br>以下是ActiveMQ配置的一个例子： </p>
<pre><code>&lt;plugins&gt; 
        ... 
        &lt;jaasAuthenticationPlugin configuration=&quot;activemq-domain&quot; /&gt; 
&lt;/plugins&gt; 
</code></pre><p>基于以上的配置，在JAAS的<code>LoginContext</code>中会使用<code>activemq-domain</code>中配置的<code>PropertiesLoginModule</code>来进行登陆。<br>ActiveMQ JAAS还支持<code>LDAPLoginModule</code>、<code>CertificateLoginModule</code>、<code>TextFileCertificateLoginModule</code>等login module。 </p>
<h3 id="Custom-Authentication-Implementation"><a href="#Custom-Authentication-Implementation" class="headerlink" title="Custom Authentication Implementation"></a>Custom Authentication Implementation</h3><p>可以通过编码的方式为ActiveMQ增加认证功能。例如编写一个类继承自<code>XBeanBrokerService</code>。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">package com.yourpackage; </div><div class="line"></div><div class="line">import java.net.URI; </div><div class="line">import java.util.HashMap; </div><div class="line">import java.util.Map; </div><div class="line"></div><div class="line">import org.apache.activemq.broker.Broker; </div><div class="line">import org.apache.activemq.broker.BrokerFactory; </div><div class="line">import org.apache.activemq.broker.BrokerService; </div><div class="line">import org.apache.activemq.security.SimpleAuthenticationBroker; </div><div class="line">import org.apache.activemq.xbean.XBeanBrokerService; </div><div class="line"></div><div class="line">public class SimpleAuthBroker extends XBeanBrokerService &#123; </div><div class="line">        // </div><div class="line">        private String user; </div><div class="line">        private String password; </div><div class="line"></div><div class="line">        @SuppressWarnings(&quot;unchecked&quot;) </div><div class="line">        protected Broker addInterceptors(Broker broker) throws Exception &#123; </div><div class="line">                broker = super.addInterceptors(broker); </div><div class="line">                Map passwords = new HashMap(); </div><div class="line">                passwords.put(getUser(), getPassword()); </div><div class="line">                broker = new SimpleAuthenticationBroker(broker, passwords, new HashMap()); </div><div class="line">                return broker; </div><div class="line">        &#125; </div><div class="line"></div><div class="line">        public String getUser() &#123; </div><div class="line">              return user; </div><div class="line">        &#125; </div><div class="line"></div><div class="line">        public void setUser(String user) &#123; </div><div class="line">                this.user = user; </div><div class="line">        &#125; </div><div class="line"> </div><div class="line">    public String getPassword() &#123; </div><div class="line">         return password; </div><div class="line">    &#125; </div><div class="line">     </div><div class="line">    public void setPassword(String password) &#123; </div><div class="line">            this.password = password; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是ActiveMQ配置文件的一个例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt; </div><div class="line">    … </div><div class="line">    &lt;auth:SimpleAuthBroker </div><div class="line">    xmlns:auth=&quot;java://com.yourpackage&quot; </div><div class="line">    xmlns=&quot;http://activemq.org/config/1.0&quot; brokerName=&quot;SimpleAuthBroker1&quot; user=&quot;user&quot; password=&quot;password&quot; useJmx=&quot;true&quot;&gt; </div><div class="line"></div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">                &lt;transportConnector uri=&quot;tcp://localhost:61616&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line">    &lt;/auth:SimpleAuthBroker&gt; </div><div class="line">    … </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>在这个配置文件中增加了一个namespace auth，用于指向之前编写的哪个类。同时为<code>SimpleAuthBroker</code>注入了两个属性值<code>user</code>和<code>password</code>，因此在被<code>SimpleAuthBroker</code>改写的<code>addInterceptors</code>方法里，可以使用这两个属性进行认证了。ActiveMQ提供的<code>SimpleAuthenticationBroker</code>类继承自<code>BrokerFilter</code>可以简单的看成是Broker的Adaptor），它的构造函数中的两个<code>Map</code>分别是<code>userPasswords</code>和<code>userGroups</code>。<br><code>SimpleAuthenticationBroker</code>在<code>addConnection</code>方法中使用<code>userPasswords</code>进行认证，同时会把<code>userGroups</code>的信息保存到<code>ConnectionContext</code>中。</p>
<h3 id="Authorization-Plugin"><a href="#Authorization-Plugin" class="headerlink" title="Authorization Plugin"></a>Authorization Plugin</h3><p>可以通过Authorization Plugin为认证后的用户授权，以下ActiveMQ配置文件的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;plugins&gt; </div><div class="line">    &lt;jaasAuthenticationPlugin configuration=&quot;activemq-domain&quot;/&gt;  </div><div class="line">    &lt;authorizationPlugin&gt; </div><div class="line">        &lt;map&gt; </div><div class="line">            &lt;authorizationMap&gt; </div><div class="line">                &lt;authorizationEntries&gt; </div><div class="line">                    &lt;authorizationEntry queue=&quot;&gt;&quot; read=&quot;admins&quot; write=&quot;admins&quot; admin=&quot;admins&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry queue=&quot;USERS.&gt;&quot; read=&quot;users&quot; write=&quot;users&quot; admin=&quot;users&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry queue=&quot;GUEST.&gt;&quot; read=&quot;guests&quot; write=&quot;guests,users&quot; admin=&quot;guests,users&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry topic=&quot;&gt;&quot; read=&quot;admins&quot; write=&quot;admins&quot; admin=&quot;admins&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry topic=&quot;USERS.&gt;&quot; read=&quot;users&quot; write=&quot;users&quot; admin=&quot;users&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry topic=&quot;GUEST.&gt;&quot; read=&quot;guests&quot; write=&quot;guests,users&quot; admin=&quot;guests,users&quot; /&gt; </div><div class="line">     </div><div class="line">                    &lt;authorizationEntry topic=&quot;ActiveMQ.Advisory.&gt;&quot; read=&quot;guests,users&quot; write=&quot;guests,users&quot; admin=&quot;guests,users&quot;/&gt; </div><div class="line">                &lt;/authorizationEntries&gt; </div><div class="line">            &lt;/authorizationMap&gt; </div><div class="line">        &lt;/map&gt; </div><div class="line">    &lt;/authorizationPlugin&gt; </div><div class="line">&lt;/plugins&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h2><p>ActiveMQ从多种不同的方面提供了集群的支持。 </p>
<h3 id="Queue-consumer-clusters"><a href="#Queue-consumer-clusters" class="headerlink" title="Queue consumer clusters"></a>Queue consumer clusters</h3><p>ActiveMQ支持订阅同一个queue的consumers上的集群。如果一个consumer失效，那么所有未被确认 （unacknowledged）的消息都会被发送到这个queue上其它的consumers。如果某个consumer的处理速度比其它consumers更快，那么这个consumer就会消费更多的消息。<br>需要注意的是，笔者发现AcitveMQ5.0版本的Queue consumer clusters存在一个bug：采用AMQ Message Store，运行一个producer，两个consumer，并采用如下的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt; </div><div class="line">    &lt;broker xmlns=&quot;http://activemq.org/config/1.0&quot; brokerName=&quot;BugBroker1&quot; useJmx=&quot;true&quot;&gt; </div><div class="line"></div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">            &lt;transportConnector uri=&quot;tcp://localhost:61616&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line"></div><div class="line">        &lt;persistenceAdapter&gt; </div><div class="line">            &lt;amqPersistenceAdapter directory=&quot;activemq-data/BugBroker1&quot; maxFileLength=&quot;32mb&quot;/&gt; </div><div class="line">        &lt;/persistenceAdapter&gt; </div><div class="line">     </div><div class="line">    &lt;/broker&gt; </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>那么经过一段时间后可能会报出如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR [ActiveMQ Transport: tcp:///127.0.0.1:1843 - RecoveryListenerAdapter.java:58 - RecoveryListenerAdapter] Message id ID:versus-1837-1203915536609-0:2:1:1:419 could not be recovered from the data store!</div></pre></td></tr></table></figure></p>
<p>Apache官方文档说，此bug已经被修正，预定在5.1.0版本上体现。 </p>
<h3 id="Broker-clusters"><a href="#Broker-clusters" class="headerlink" title="Broker clusters"></a>Broker clusters</h3><p>一个常见的场景是有多个JMS broker，一个客户连接到其中一个broker。如果这个broker失效，那么客户会自动重新连接到其它的broker。在ActiveMQ中使用<code>failover://</code> 协议来实现这个功能。ActiveMQ3.x版本的<code>reliable://</code>协议已经变更为<code>failover://</code>。<br>如果某个网络上有多个brokers而且客户使用静态发现（使用Static Transport或Failover Transport）或动态发现（使用Discovery Transport），那么客户可以容易地在某个broker失效的情况下切换到其它的brokers。然而，stand alone brokers并不了解其它brokers上的consumers，也就是说如果某个broker上没有consumers，那么这个broker上的消息可能会因得不到处理而积压起来。目前的解决方案是使用Network of brokers，以便在broker之间存储转发消息。ActiveMQ在未来会有更好的特性，用来在客户端处理这个问题。<br>从ActiveMQ1.1版本起，ActiveMQ支持networks of brokers。它支持分布式的queues和topics。一个broker会相同对待所有的订阅（subscription）：不管他们是来自本地的客户连接，还是来自远程broker，它都会递送有关的消息拷贝到每个订阅。远程broker得到这个消息拷贝后，会依次把它递送到其内部的本地连接上。有两种方式配置Network of brokers，一种是使用static transport：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=&quot;receiver&quot; persistent=&quot;false&quot; useJmx=&quot;false&quot;&gt; </div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">                &lt;transportConnector uri=&quot;tcp://localhost:62002&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line">        </div><div class="line">        &lt;networkConnectors&gt; </div><div class="line">                &lt;networkConnector uri=&quot;static:( tcp://localhost:61616,tcp://remotehost:61616)&quot;/&gt; </div><div class="line">        &lt;/networkConnectors&gt; </div><div class="line">… </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>另外一种是使用multicast discovery，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;broker name=&quot;sender&quot; persistent=&quot;false&quot; useJmx=&quot;false&quot;&gt; </div><div class="line">    &lt;transportConnectors&gt; </div><div class="line">        &lt;transportConnector uri=&quot;tcp://localhost:0&quot; discoveryUri=&quot;multicast://default&quot;/&gt; </div><div class="line">    &lt;/transportConnectors&gt; </div><div class="line">    &lt;networkConnectors&gt; </div><div class="line">        &lt;networkConnector uri=&quot;multicast://default&quot;/&gt; </div><div class="line">    &lt;/networkConnectors&gt; </div><div class="line">... </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>Network Connector有以下属性： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Property</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">name</td>
<td style="text-align:center">bridge</td>
<td style="text-align:center">name of the network - for more than one network connector between the same two brokers - use different names</td>
</tr>
<tr>
<td style="text-align:center">dynamicOnly</td>
<td style="text-align:center">false</td>
<td style="text-align:center">if true, only forward messages if a consumer is active on the connected broker</td>
</tr>
<tr>
<td style="text-align:center">decreaseNetworkConsumerPriority</td>
<td style="text-align:center">false</td>
<td style="text-align:center">decrease the priority for dispatching to a Queue consumer the further away it is (in network hops) from the producer</td>
</tr>
<tr>
<td style="text-align:center">networkTTL</td>
<td style="text-align:center">1</td>
<td style="text-align:center">the number of brokers in the network that messages and subscriptions can pass through</td>
</tr>
<tr>
<td style="text-align:center">conduitSubscriptions</td>
<td style="text-align:center">true</td>
<td style="text-align:center">multiple consumers subscribing to the same destination are treated as one consumer by the network</td>
</tr>
<tr>
<td style="text-align:center">excludedDestinations</td>
<td style="text-align:center">empty</td>
<td style="text-align:center">destinations matching this list won’t be forwarded across the network</td>
</tr>
<tr>
<td style="text-align:center">dynamicallyIncludedDestinations</td>
<td style="text-align:center">empty</td>
<td style="text-align:center">destinations that match this list will be forwarded across the network n.b. an empty list means all destinations not in the excluded list will be forwarded</td>
</tr>
<tr>
<td style="text-align:center">staticallyIncludedDestinations</td>
<td style="text-align:center">empty</td>
<td style="text-align:center">destinations that match will always be passed across the network - even if no consumers have ever registered an interest</td>
</tr>
<tr>
<td style="text-align:center">duplex</td>
<td style="text-align:center">false</td>
<td style="text-align:center">if true, a network connection will be used to both produce AND Consume messages. This is useful for hub and spoke scenarios when the hub is behind a firewall etc.</td>
</tr>
</tbody>
</table>
<p>关于conduitSubscriptions属性，这里稍稍说明一下。设想有两个brokers，分别是brokerA和brokerB，它们之间用 forwarding bridge连接。有一个consumer连接到brokerA并订阅queue：<code>Q.TEST</code>。有两个consumers连接到brokerB，也是订 阅queue：<code>Q.TEST</code>。这三个consumers有相同的优先级。然后启动一个producer。</p>
]]></content>
    
    <summary type="html">
    
      ActiveMQ理解
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActiveMQ/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>JMS概念</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMQ_%E5%88%9D%E6%AD%A5%E5%85%A5%E9%97%A8%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMQ_初步入门及相关概念理解/</id>
    <published>2017-04-05T05:45:24.000Z</published>
    <updated>2017-04-05T20:24:34.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JMS的基本构件"><a href="#JMS的基本构件" class="headerlink" title="JMS的基本构件"></a>JMS的基本构件</h2><h3 id="连接工厂"><a href="#连接工厂" class="headerlink" title="连接工厂"></a>连接工厂</h3><p>连接工厂是客户用来创建连接的对象，例如ActiveMQ提供的<code>ActiveMQConnectionFactory</code>。 </p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>JMS <code>Connection</code>封装了客户与JMS提供者之间的一个虚拟的连接。 </p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>JMS <code>Session</code>是生产和消费消息的一个单线程上下文。会话用于创建消息生产者（producer）、消息消费者（consumer）和消息（message）等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接收被组合到了一个原子操作中。 </p>
<h3 id="目的地"><a href="#目的地" class="headerlink" title="目的地"></a>目的地</h3><p>目的地是客户用来指定它生产的消息的目标和它消费的消息的来源的对象。JMS1.0.2规范中定义了两种消息传递域：点对点（PTP）消息传递域和发布/订阅消息传递域。 </p>
<h4 id="点对点消息传递域的特点如下："><a href="#点对点消息传递域的特点如下：" class="headerlink" title="点对点消息传递域的特点如下："></a>点对点消息传递域的特点如下：</h4><p>• 每个消息只能有一个消费者。<br>• 消息的生产者和消费者之间没有时间上的相关性。无论消费者在生产者发送消息的时候是否处于运行状态，它都可以提取消息。(前提是没有其他消费者消费了该消息)<br>• 在点对点消息传递域中，目的地被称为队列（queue）</p>
<h4 id="发布-订阅消息传递域的特点如下："><a href="#发布-订阅消息传递域的特点如下：" class="headerlink" title="发布/订阅消息传递域的特点如下："></a>发布/订阅消息传递域的特点如下：</h4><p>• 每个消息可以有多个消费者。<br>• 生产者和消费者之间有时间上的相关性。订阅一个主题的消费者只能消费自它订阅之后发布的消息。JMS规范允许客户创建持久订阅，这在一定程度上放松了时间上的相关性要求。持久订阅允许消费者消费它在未处于激活状态时发送的消息。<br>• 在发布/订阅消息传递域中，目的地被称为主题（topic）。 </p>
<h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><p>消息生产者是由会话创建的一个对象，用于把消息发送到一个目的地。 </p>
<h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>消息消费者是由会话创建的一个对象，它用于接收发送到目的地的消息。消息的消费可以采用以下两种方法之一： </p>
<p>• 同步消费。通过调用消费者的<code>receive</code>方法从目的地中显式提取消息。<code>receive</code>方法可以一直阻塞到消息到达。<br>• 异步消费。客户可以为消费者注册一个消息监听器，以定义在消息到达时所采取的动作。 </p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>JMS消息由以下三部分组成：<br>• 消息头。每个消息头字段都有相应的getter和setter方法。<br>• 消息属性。如果需要除消息头字段以外的值，那么可以使用消息属性。<br>• 消息体。JMS定义的消息类型有<code>TextMessage</code>、<code>MapMessage</code>、<code>BytesMessage</code>、<code>StreamMessage</code>和<code>ObjectMessage</code>。 </p>
<h2 id="JMS的可靠性机制"><a href="#JMS的可靠性机制" class="headerlink" title="JMS的可靠性机制"></a>JMS的可靠性机制</h2><h3 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h3><p>JMS消息只有在被确认之后，才认为已经被成功地消费了。消息的成功消费通常包含三个阶段：客户接收消息、客户处理消息和消息被确认。<br>在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式（acknowledgement mode）。该参数有以下三个可选值：<br>• <code>Session.AUTO_ACKNOWLEDGE</code>。当客户成功地从<code>receive</code>方法返回的时候，或者从<code>MessageListener.onMessage</code>方法成功返回的时候，会话自动确认客户收到的消息。<br>• <code>Session.CLIENT_ACKNOWLEDGE</code>。 客户通过消息的<code>acknowledge</code>方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行：确认一个被消费的消息将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。<br>• <code>Session.DUPS_OK_ACKNOWLEDGE</code>。 </p>
<p>The duplicates okay acknowledgement mode closely resembles the auto acknowledgement mode. However, rather than pass <code>Session.AUTO_ACKNOWLEDGE</code>, you specify <code>Session.DUPS_OK_ACKNOWLEDGE</code> as the acknowledgement mode of <code>createSession()</code>‘s second argument. With less overhead than auto mode, in duplicates okay mode, the JMS provider guarantees at-least-once message delivery. During failure recovery, certain messages are probably delivered more than once.如果JMS provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的<code>JMSRedelivered</code>字段设置为true。 </p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>JMS 支持以下两种消息提交模式：<br>• <code>PERSISTENT</code>。指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失。<br>• <code>NON_PERSISTENT</code>。不要求JMS provider持久保存消息。 </p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>可以使用消息优先级来指示JMS provider首先提交紧急的消息。优先级分10个级别，从0（最低）到9（最高）。如果不指定优先级，默认级别是4。需要注意的是，JMS provider并不一定保证按照优先级的顺序提交消息。 </p>
<h3 id="消息过期"><a href="#消息过期" class="headerlink" title="消息过期"></a>消息过期</h3><p>可以设置消息在一定时间后过期，默认是永不过期。 </p>
<h3 id="临时目的地"><a href="#临时目的地" class="headerlink" title="临时目的地"></a>临时目的地</h3><p>可以通过会话上的<code>createTemporaryQueue</code>方法和<code>createTemporaryTopic</code>方法来创建临时目的地。它们的存在时间只限于创建它们的连接所保持的时间。只有创建该临时目的地的连接上的消息消费者才能够从临时目的地中提取消息。 </p>
<h3 id="持久订阅"><a href="#持久订阅" class="headerlink" title="持久订阅"></a>持久订阅</h3><p>首先消息生产者必须使用<code>PERSISTENT</code>提交消息。客户可以通过会话上的<code>createDurableSubscriber</code>方法来创建一个持久订阅，该方法的第一个参数必须是一个<code>topic</code>。第二个参数是订阅的名称。<br>JMS provider会存储发布到持久订阅对应的topic上的消息。如果最初创建持久订阅的客户或者任何其它客户使用相同的连接工厂和连接的客户ID、相同的主题和相同的订阅名再次调用会话上的<code>createDurableSubscriber</code>方法，那么该持久订阅就会被激活。JMS provider会向客户发送客户处于非激活状态时所发布的消息。<br><strong>持久订阅在某个时刻只能有一个激活的订阅者。</strong>持久订阅在创建之后会一直保留，直到应用程序调用会话上的<code>unsubscribe</code>方法。 </p>
<h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>在一个JMS客户端，可以使用本地事务来组合消息的发送和接收。JMS Session接口提供了<code>commit</code>和<code>rollback</code>方法。<br>事务提交意味着生产的所有消息被发送，消费的所有消息被确认；事务回滚意味着生产的所有消息被销毁，消费的所有消息被恢复并重新提交，除非它们已经过期。 </p>
<blockquote>
<p>需要注意的是，如果使用请求/回复机制，即发送一个消息，同时希望在同一个事务中等待接收该消息的回复，那么程序将被挂起，因为直到事务提交，发送操作才会真正执行。<br>所以，消息的生产和消费不能包含在同一个事务中。 </p>
</blockquote>
<h2 id="JMS-规范的变迁"><a href="#JMS-规范的变迁" class="headerlink" title="JMS 规范的变迁"></a>JMS 规范的变迁</h2><p>JMS最新版本是1.1。它和1.0.2版本最大的差别是，JMS1.1通过统一消息传递域简化了消息传递。这不仅简化了JMS API，也有利于开发人员灵活选择消息传递域，同时也有助于程序的重用和维护。<br>以下是不同消息传递域的相应接口： </p>
<table>
<thead>
<tr>
<th style="text-align:center">JMS公共</th>
<th style="text-align:center">点对点域</th>
<th style="text-align:center">发布/订阅域</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ConnectionFactory</code></td>
<td style="text-align:center"><code>QueueConnectionFactory</code></td>
<td style="text-align:center"><code>TopicConnectionFactory</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Connection</code></td>
<td style="text-align:center"><code>QueueConnection</code></td>
<td style="text-align:center"><code>TopicConnection</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Destination</code></td>
<td style="text-align:center"><code>Queue</code></td>
<td style="text-align:center"><code>Topic</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Session</code></td>
<td style="text-align:center"><code>QueueSession</code></td>
<td style="text-align:center"><code>TopicSession</code></td>
</tr>
<tr>
<td style="text-align:center"><code>MessageProducer</code></td>
<td style="text-align:center"><code>QueueSender</code></td>
<td style="text-align:center"><code>TopicPublisher</code></td>
</tr>
<tr>
<td style="text-align:center"><code>MessageConsumer</code></td>
<td style="text-align:center"><code>QueueReceiver</code></td>
<td style="text-align:center"><code>TopicSubscriber</code></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      JMS概念
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMq性能优化</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMq%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMq性能优化/</id>
    <published>2017-04-05T05:30:41.000Z</published>
    <updated>2017-04-05T05:38:01.424Z</updated>
    
    <content type="html"><![CDATA[<p>ActiveMq是比较稳定的，吞吐速度也很快，如果出现入队列或者出队列慢问题，先检查一下自己的代码，是不是本身取到数据后处理过慢。</p>
<h2 id="1-使用spring的JmsTemplate"><a href="#1-使用spring的JmsTemplate" class="headerlink" title="1. 使用spring的JmsTemplate"></a>1. 使用spring的<code>JmsTemplate</code></h2><p><code>JmsTemplate</code>的<code>send</code>和<code>convertAndSend</code>会使用持久化<code>mode</code>，即使你设置了<code>NON_PERSISTENT</code>。这会导致入队列速度变得非常慢。</p>
<p>解决办法，使用下面的<code>MyJmsTemplate</code>代替<code>JmsTemplate</code>。</p>
<pre><code>public class MyJmsTemplate extends JmsTemplate {
    private Session session;

    public MyJmsTemplate() {
        super();
    }

    public MyJmsTemplate(ConnectionFactory connectionFactory) {
        super(connectionFactory);
    }

    public void doSend(MessageProducer producer, Message message) throws JMSException {
        if (isExplicitQosEnabled()) {
            producer.send(message, getDeliveryMode(), getPriority(), getTimeToLive());
        } else {
            producer.send(message);
        }
    }

    public Session getSession() {
        return session;
    }

    public void setSession(Session session) {
        this.session = session;
    }
}
</code></pre><h2 id="2-DeliveryMode的选择，如果你入队列的数据，不考虑MQ挂掉的情况（这概率很小），使用NON-PERSISTENT会显著提高数据写入速度。"><a href="#2-DeliveryMode的选择，如果你入队列的数据，不考虑MQ挂掉的情况（这概率很小），使用NON-PERSISTENT会显著提高数据写入速度。" class="headerlink" title="2. DeliveryMode的选择，如果你入队列的数据，不考虑MQ挂掉的情况（这概率很小），使用NON_PERSISTENT会显著提高数据写入速度。"></a>2. <code>DeliveryMode</code>的选择，如果你入队列的数据，不考虑MQ挂掉的情况（这概率很小），使用<code>NON_PERSISTENT</code>会显著提高数据写入速度。</h2><h2 id="3-生产者使用事务会提高入队列性能，但是消费者如果启动了事务则会显著影响数据的消费速度。"><a href="#3-生产者使用事务会提高入队列性能，但是消费者如果启动了事务则会显著影响数据的消费速度。" class="headerlink" title="3. 生产者使用事务会提高入队列性能，但是消费者如果启动了事务则会显著影响数据的消费速度。"></a>3. 生产者使用事务会提高入队列性能，但是消费者如果启动了事务则会显著影响数据的消费速度。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</div></pre></td></tr></table></figure>
<p>代码中的<code>false</code>代表不启动事物。</p>
<h2 id="4-消费者的消息处理即onMessage方法优化"><a href="#4-消费者的消息处理即onMessage方法优化" class="headerlink" title="4. 消费者的消息处理即onMessage方法优化:"></a>4. 消费者的消息处理即<code>onMessage方</code>法优化:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class SmsMoPool implements MessageListener &#123;</div><div class="line">    private final static Logger logger = LoggerFactory.getLogger(SmsMoPool.class);</div><div class="line">    private DefaultEventPubliser moEventPublisher;</div><div class="line">    private final EventFactory eventFactory = new DefaultEventFactory();</div><div class="line">    private DefaultDataGather dataGather;</div><div class="line">    private ExecutorService pool = Executors.newFixedThreadPool(5);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onMessage(final Message message) &#123;</div><div class="line">        pool.execute(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                final ObjectMessage msg = (ObjectMessage) message;</div><div class="line">                Serializable obj = null;</div><div class="line">                try &#123;</div><div class="line">                    obj = msg.getObject();</div><div class="line">                &#125; catch (JMSException e) &#123;</div><div class="line">                    logger.error(&quot;从消息队列获得上行信息异常&#123;&#125;&quot;, e);</div><div class="line">                &#125;</div><div class="line">                if (obj != null) &#123;</div><div class="line">                    dataGather.incrementDateCount(MasEntityConstants.TRAFFIC_SMS_MO_IN);</div><div class="line">                    AgentToServerReq req = (AgentToServerReq) obj;</div><div class="line">                    if (logger.isInfoEnabled()) &#123;</div><div class="line">                        logger.info(&quot;驱动--&gt;调度：&#123;&#125;&quot;, req.toXmlStr());</div><div class="line">                    &#125;</div><div class="line">                    Event event = eventFactory.createMoEvent(req);</div><div class="line">                    moEventPublisher.publishEvent(event);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码使用了线程池，另一点要注意的是<code>msg.getObject();</code>这个方法是一个比较耗时的方法，你的代码中不应该出现多次<code>getObject()</code>。</p>
<h2 id="5-消费者使用预取，如何使用预取，下面以spring版本为例"><a href="#5-消费者使用预取，如何使用预取，下面以spring版本为例" class="headerlink" title="5. 消费者使用预取，如何使用预取，下面以spring版本为例"></a>5. 消费者使用预取，如何使用预取，下面以spring版本为例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;</div><div class="line">    &lt;constructor-arg value=&quot;data.mo?consumer.prefetchSize=100&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>预取数量根据具体入队列数据而定，以上设置100，是针对2000/sec入队列速度设定的。<br>另外如果是慢消费者，这里可设置为1。</p>
<h2 id="6-检查你的MQ数据吞吐速度，保持生产和消费的平衡，不会出现大量积压。"><a href="#6-检查你的MQ数据吞吐速度，保持生产和消费的平衡，不会出现大量积压。" class="headerlink" title="6. 检查你的MQ数据吞吐速度，保持生产和消费的平衡，不会出现大量积压。"></a>6. 检查你的MQ数据吞吐速度，保持生产和消费的平衡，不会出现大量积压。</h2><h2 id="7-ActiveMQ使用TCP协议时tcpNoDelay-默认是false-，设置为true可以提高性能。"><a href="#7-ActiveMQ使用TCP协议时tcpNoDelay-默认是false-，设置为true可以提高性能。" class="headerlink" title="7. ActiveMQ使用TCP协议时tcpNoDelay=默认是false ，设置为true可以提高性能。"></a>7. ActiveMQ使用TCP协议时<code>tcpNoDelay=</code>默认是<code>false</code> ，设置为<code>true</code>可以提高性能。</h2><p>还是spring版本的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;mqPoolConnectionFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot; destroy-method=&quot;stop&quot;&gt;</div><div class="line">       &lt;property name=&quot;connectionFactory&quot;&gt;</div><div class="line">           &lt;bean id=&quot;mqConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot; p:useAsyncSend=&quot;true&quot;</div><div class="line">                 p:brokerURL=&quot;failover://(tcp://127.0.0.1:61616?tcpNoDelay=true)&quot;/&gt;</div><div class="line">       &lt;/property&gt;</div><div class="line">   &lt;/bean&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      ActiveMq性能优化
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActivefMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActivefMQ/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出JMS(一)--JMS基本概念</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJMS_%E4%B8%80_--JMS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/深入浅出JMS_一_--JMS基本概念/</id>
    <published>2017-04-05T05:15:49.000Z</published>
    <updated>2017-04-05T05:28:39.827Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>The Java Message Service (JMS) API is a messaging standard that allows application components based on the Java Platform Enterprise Edition (Java EE) to create, send, receive, and read messages. It enables distributed communication that is loosely coupled, reliable, and asynchronous.</p>
</blockquote>
<p>JMS（JAVA Message Service,java消息服务）API是一个消息服务的标准(规范)，允许基于JavaEE平台的应用程序组件创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠并采用异步方式。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JMS是java的消息服务，JMS的客户端之间通过JMS服务进行异步消息传输。</p>
<h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><ul>
<li>Point-to-Point(P2P)</li>
<li>Publish/Subscribe(Pub/Sub)</li>
</ul>
<p>即点对点和发布订阅模型</p>
<h4 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h4><p><img src="/img/JMS P2P模式" alt="JMS P2P模式"></p>
<ul>
<li>消息队列（Queue）</li>
<li>发送者(Sender)</li>
<li>接收者(Receiver)</li>
</ul>
<p>每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到它们被消费或超时。</p>
<h5 id="P2P的特点"><a href="#P2P的特点" class="headerlink" title="P2P的特点"></a>P2P的特点</h5><p>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)<br>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列；接收者在成功接收消息之后需向队列应答成功；如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。</p>
<h4 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h4><p><img src="/img/Pub Sub模式图" alt="Pub/Sub模式图"> </p>
<ul>
<li>主题（Topic）</li>
<li>发布者（Publisher）</li>
<li>订阅者（Subscriber） </li>
</ul>
<p>多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p>
<h5 id="Pub-Sub的特点"><a href="#Pub-Sub的特点" class="headerlink" title="Pub/Sub的特点"></a>Pub/Sub的特点</h5><ul>
<li>每个消息可以有多个消费者</li>
<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。</li>
<li>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</li>
<li>如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型</li>
</ul>
<h2 id="消息的消费"><a href="#消息的消费" class="headerlink" title="消息的消费"></a>消息的消费</h2><p>在JMS中，消息的产生和消息是异步的。</p>
<ul>
<li>同步<br>订阅者或接收者调用<code>receive</code>方法来接收消息，<code>receive</code>方法在能够接收到消息之前（或超时之前）将一直阻塞 </li>
<li>异步<br>订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的<code>onMessage</code>方法。</li>
</ul>
<h2 id="JMS编程模型"><a href="#JMS编程模型" class="headerlink" title="JMS编程模型"></a>JMS编程模型</h2><p>(1) <code>ConnectionFactory</code></p>
<p>创建<code>Connection</code>对象的工厂，针对两种不同的jms消息模型，分别有<code>QueueConnectionFactory</code>和<code>TopicConnectionFactory</code>两种。可以通过JNDI来查找<code>ConnectionFactory</code>对象。</p>
<p>(2) <code>Destination</code></p>
<p><code>Destination</code>的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者或消费者来说，它的<code>Destination</code>是某个队列（Queue）或某个主题（Topic）。</p>
<p><code>Destination</code>实际上就是两种类型的对象：<code>Queue</code>、<code>Topic</code>。<br>(3) <code>Connection</code></p>
<p><code>Connection</code>表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。<code>Connection</code>可以产生一个或多个<code>Session</code>。跟<code>ConnectionFactory</code>一样，<code>Connection</code>也有两种类型：<code>QueueConnection</code>和<code>TopicConnection</code>。</p>
<p>(4) <code>Session</code></p>
<p><code>Session</code>是操作消息的接口。可以通过session创建生产者、消费者、消息等。<code>Session</code>提供了事务的功能。当需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分<code>QueueSession</code>和<code>TopicSession</code>。</p>
<p>(5) 消息的生产者</p>
<p>消息生产者由<code>Session</code>创建，并用于将消息发送到<code>Destination</code>。同样，消息生产者分两种类型：<code>QueueSender</code>和<code>TopicPublisher</code>。可以调用消息生产者的方法（<code>send</code>或<code>publish</code>方法）发送消息。</p>
<p>(6) 消息消费者</p>
<p>消息消费者由<code>Session</code>创建，用于接收被发送到<code>Destination</code>的消息。两种类型：<code>QueueReceiver</code>和<code>TopicSubscriber</code>。可分别通过<code>session</code>的<code>createReceiver(Queue)</code>或<code>createSubscriber(Topic)</code>来创建。当然，也可以<code>session</code>的<code>creatDurableSubscriber</code>方法来创建持久化的订阅者。</p>
<p>(7) <code>MessageListener</code></p>
<p>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的<code>onMessage</code>方法。EJB中的MDB（Message-Driven Bean）就是一种<code>MessageListener</code>。</p>
<h2 id="企业消息系统的好处"><a href="#企业消息系统的好处" class="headerlink" title="企业消息系统的好处"></a>企业消息系统的好处</h2><p>应用程序A将Message发送到服务器上，然后应用程序B从服务器中接收A发来的消息： </p>
<p><img src="/img/企业消息系统的好处" alt="企业消息系统的好处"></p>
<ul>
<li>提供消息灵活性</li>
<li>松散耦合</li>
<li>异步性</li>
</ul>
]]></content>
    
    <summary type="html">
    
      深入浅出JMS(一)--JMS基本概念
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ入门实例</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMQ%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMQ入门实例/</id>
    <published>2017-04-05T05:08:11.000Z</published>
    <updated>2017-04-05T05:14:59.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-下载ActiveMQ"><a href="#1-下载ActiveMQ" class="headerlink" title="1.下载ActiveMQ"></a>1.下载ActiveMQ</h2><p>去官方网站下载：<a href="http://activemq.apache.org/" target="_blank" rel="external">http://activemq.apache.org/</a></p>
<h2 id="2-运行ActiveMQ"><a href="#2-运行ActiveMQ" class="headerlink" title="2.运行ActiveMQ"></a>2.运行ActiveMQ</h2><p>解压缩<code>apache-activemq-5.5.1-bin.zip</code>，然后双击<code>apache-activemq-5.5.1\bin\activemq.bat</code>运行ActiveMQ程序。</p>
<p>启动ActiveMQ以后，登陆：<code>http://localhost:8161/admin/</code>，创建一个<code>Queue</code>，命名为<code>FirstQueue</code>。</p>
<h2 id="3-创建Eclipse项目并运行"><a href="#3-创建Eclipse项目并运行" class="headerlink" title="3.创建Eclipse项目并运行"></a>3.创建Eclipse项目并运行</h2><p>创建project：<code>ActiveMQ-5.5</code>，并导入<code>apache-activemq-5.5.1\lib</code>目录下需要用到的jar文件，项目结构如下图所示：</p>
<p><img src="/img/ActiveMQ的Eclipse项目.jpg" alt="ActiveMQ的Eclipse项目"></p>
<h3 id="3-1-Sender-java"><a href="#3-1-Sender-java" class="headerlink" title="3.1.Sender.java"></a>3.1.<code>Sender.java</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.activemq;</div><div class="line"></div><div class="line">import javax.jms.Connection;</div><div class="line">import javax.jms.ConnectionFactory;</div><div class="line">import javax.jms.DeliveryMode;</div><div class="line">import javax.jms.Destination;</div><div class="line">import javax.jms.MessageProducer;</div><div class="line">import javax.jms.Session;</div><div class="line">import javax.jms.TextMessage;</div><div class="line">import org.apache.activemq.ActiveMQConnection;</div><div class="line">import org.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"></div><div class="line">public class Sender &#123;</div><div class="line">    private static final int SEND_NUMBER = 5;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // ConnectionFactory ：连接工厂，JMS 用它创建连接</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        // Connection ：JMS 客户端到JMS Provider 的连接</div><div class="line">        Connection connection = null;</div><div class="line">        // Session： 一个发送或接收消息的线程</div><div class="line">        Session session;</div><div class="line">        // Destination ：消息的目的地;消息发送给谁.</div><div class="line">        Destination destination;</div><div class="line">        // MessageProducer：消息发送者</div><div class="line">        MessageProducer producer;</div><div class="line">        // TextMessage message;</div><div class="line">        // 构造ConnectionFactory实例对象，此处采用ActiveMq的实现jar</div><div class="line">        connectionFactory = new ActiveMQConnectionFactory(</div><div class="line">                ActiveMQConnection.DEFAULT_USER,</div><div class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</div><div class="line">                &quot;tcp://localhost:61616&quot;);</div><div class="line">        try &#123;</div><div class="line">            // 构造从工厂得到连接对象</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            // 启动</div><div class="line">            connection.start();</div><div class="line">            // 获取操作连接</div><div class="line">            session = connection.createSession(Boolean.TRUE,</div><div class="line">                    Session.AUTO_ACKNOWLEDGE);</div><div class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</div><div class="line">            // 得到消息生成者【发送者】</div><div class="line">            producer = session.createProducer(destination);</div><div class="line">            // 设置不持久化，此处学习，实际根据项目决定</div><div class="line">            producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</div><div class="line">            // 构造消息，此处写死</div><div class="line">            sendMessage(session, producer);</div><div class="line">            session.commit();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (null != connection)</div><div class="line">                    connection.close();</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void sendMessage(Session session, MessageProducer producer)</div><div class="line">            throws Exception &#123;</div><div class="line">        for (int i = 1; i &lt;= SEND_NUMBER; i++) &#123;</div><div class="line">            TextMessage message = session</div><div class="line">                    .createTextMessage(&quot;ActiveMq 发送的消息&quot; + i);</div><div class="line">            // 发送消息到目的地方</div><div class="line">            System.out.println(&quot;发送消息：&quot; + &quot;ActiveMq 发送的消息&quot; + i);</div><div class="line">            producer.send(message);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-Receiver-java"><a href="#3-2-Receiver-java" class="headerlink" title="3.2.Receiver.java"></a>3.2.Receiver.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.activemq;</div><div class="line"></div><div class="line">import javax.jms.Connection;</div><div class="line">import javax.jms.ConnectionFactory;</div><div class="line">import javax.jms.Destination;</div><div class="line">import javax.jms.MessageConsumer;</div><div class="line">import javax.jms.Session;</div><div class="line">import javax.jms.TextMessage;</div><div class="line">import org.apache.activemq.ActiveMQConnection;</div><div class="line">import org.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"></div><div class="line">public class Receiver &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // ConnectionFactory ：连接工厂，JMS 用它创建连接</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        // Connection ：JMS 客户端到JMS Provider 的连接</div><div class="line">        Connection connection = null;</div><div class="line">        // Session： 一个发送或接收消息的线程</div><div class="line">        Session session;</div><div class="line">        // Destination ：消息的目的地;消息发送给谁.</div><div class="line">        Destination destination;</div><div class="line">        // 消费者，消息接收者</div><div class="line">        MessageConsumer consumer;</div><div class="line">        connectionFactory = new ActiveMQConnectionFactory(</div><div class="line">                ActiveMQConnection.DEFAULT_USER,</div><div class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</div><div class="line">                &quot;tcp://localhost:61616&quot;);</div><div class="line">        try &#123;</div><div class="line">            // 构造从工厂得到连接对象</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            // 启动</div><div class="line">            connection.start();</div><div class="line">            // 获取操作连接</div><div class="line">            session = connection.createSession(Boolean.FALSE,</div><div class="line">                    Session.AUTO_ACKNOWLEDGE);</div><div class="line">   </div><div class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</div><div class="line">            consumer = session.createConsumer(destination);</div><div class="line">            while (true) &#123;</div><div class="line">                //设置接收者接收消息的时间，为了便于测试，这里谁定为100s</div><div class="line">                TextMessage message = (TextMessage) consumer.receive(100000);</div><div class="line">                if (null != message) &#123;</div><div class="line">                    System.out.println(&quot;收到消息&quot; + message.getText());</div><div class="line">                &#125; else &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (null != connection)</div><div class="line">                    connection.close();</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h2><p>最后接收者跟发送者在不同的机器上测试</p>
<h2 id="5-测试过程"><a href="#5-测试过程" class="headerlink" title="5.测试过程"></a>5.测试过程</h2><p>运行<code>Receiver</code>后没有任何信息，运行Sender以后，显示如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">发送消息：ActiveMq 发送的消息1</div><div class="line">发送消息：ActiveMq 发送的消息2</div><div class="line">发送消息：ActiveMq 发送的消息3</div><div class="line">发送消息：ActiveMq 发送的消息4</div><div class="line">发送消息：ActiveMq 发送的消息5</div></pre></td></tr></table></figure></p>
<p>而<code>Receiver</code>现如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">收到消息ActiveMq 发送的消息1</div><div class="line">收到消息ActiveMq 发送的消息2</div><div class="line">收到消息ActiveMq 发送的消息3</div><div class="line">收到消息ActiveMq 发送的消息4</div><div class="line">收到消息ActiveMq 发送的消息5</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      ActiveMQ入门实例
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>activemq的几种基本通信方式总结</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/activemq%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/activemq的几种基本通信方式总结/</id>
    <published>2017-04-05T03:09:12.000Z</published>
    <updated>2017-04-05T05:07:35.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>面向消息队列是一个总体比较合理的应用系统集成方案。<br>ActiveMQ是JMS消息通信规范的一个实现。消息通信模式主要有发布-订阅、点对点。</p>
<h2 id="基础流程"><a href="#基础流程" class="headerlink" title="基础流程"></a>基础流程</h2><p>ActiveMQ启动服务的过程:</p>
<ol>
<li>获得JMS connection factory，通过提供特定环境的连接信息来构造factory。</li>
<li>利用factory构造JMS connection.</li>
<li>启动connection</li>
<li>通过connection创建JMS session.</li>
<li>指定JMS destination.</li>
<li>创建JMS producer和JMS message并提供destination.</li>
<li>创建JMS consumer和注册JMS message listener.</li>
<li>发送和接收JMS message.</li>
<li>关闭所有JMS资源，包括connection, session, producer, consumer等。</li>
</ol>
<h2 id="publish-subscribe"><a href="#publish-subscribe" class="headerlink" title="publish-subscribe"></a>publish-subscribe</h2><p>发布订阅模式类似于订阅报纸。</p>
<p><img src="/img/JMS发布订阅模式示意图.jpg" alt="JMS发布订阅模式示意图"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="publisher"><a href="#publisher" class="headerlink" title="publisher"></a>publisher</h4><p>publisher是属于发布信息的一方，它通过定义一个或者多个topic，然后给这些topic发送消息。<br>publisher的构造函数如下：</p>
<pre><code>public Publisher() throws JMSException {  
    factory = new ActiveMQConnectionFactory(brokerURL);  
    connection = factory.createConnection();  
    try {  
        connection.start();  
    } catch (JMSException jmse) {  
        connection.close();  
        throw jmse;  
    }  
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
    producer = session.createProducer(null);  
}
</code></pre><p>按照前面说的流程定义了基本的<code>connectionFactory</code>, <code>connection</code>,<code>session</code>,<code>producer</code>。。</p>
<h4 id="接着定义一系列的topic让所有的consumer来订阅"><a href="#接着定义一系列的topic让所有的consumer来订阅" class="headerlink" title="接着定义一系列的topic让所有的consumer来订阅"></a>接着定义一系列的topic让所有的consumer来订阅</h4><pre><code>protected void setTopics(String[] stocks) throws JMSException {  
    destinations = new Destination[stocks.length];  
    for(int i = 0; i &lt; stocks.length; i++) {  
        destinations[i] = session.createTopic(&quot;STOCKS.&quot; + stocks[i]);  
    }  
}  
</code></pre><h4 id="定义好topic之后要给这些指定的topic发消息："><a href="#定义好topic之后要给这些指定的topic发消息：" class="headerlink" title="定义好topic之后要给这些指定的topic发消息："></a>定义好topic之后要给这些指定的topic发消息：</h4><pre><code>protected void sendMessage(String[] stocks) throws JMSException {  
    for(int i = 0; i &lt; stocks.length; i++) {  
        Message message = createStockMessage(stocks[i], session);  
        System.out.println(&quot;Sending: &quot; + ((ActiveMQMapMessage)message).getContentMap() + &quot; on destination: &quot; + destinations[i]);  
        producer.send(destinations[i], message);  
    }  
}  

protected Message createStockMessage(String stock, Session session) throws JMSException {  
    MapMessage message = session.createMapMessage();  
    message.setString(&quot;stock&quot;, stock);  
    message.setDouble(&quot;price&quot;, 1.00);  
    message.setDouble(&quot;offer&quot;, 0.01);  
    message.setBoolean(&quot;up&quot;, true);          
    return message;  
}  
</code></pre><p>在<code>sendMessage</code>方法里遍历每个<code>topic</code>，然后给每个<code>topic</code>发送定义的<code>Message</code>消息。</p>
<h4 id="publisher发布消息"><a href="#publisher发布消息" class="headerlink" title="publisher发布消息"></a>publisher发布消息</h4><pre><code>public static void main(String[] args) throws JMSException {  
    if(args.length &lt; 1)  
        throw new IllegalArgumentException();  

    // Create publisher       
    Publisher publisher = new Publisher();  

    // Set topics  
    publisher.setTopics(args);  

    for(int i = 0; i &lt; 10; i++) {  
        publisher.sendMessage(args);  
        System.out.println(&quot;Publisher &apos;&quot; + i + &quot; price messages&quot;);  
        try {  
            Thread.sleep(1000);  
        } catch(InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
    // Close all resources  
    publisher.close();  
}  
</code></pre><h4 id="close方法关闭资源："><a href="#close方法关闭资源：" class="headerlink" title="close方法关闭资源："></a><code>close</code>方法关闭资源：</h4><pre><code>public void close() throws JMSException {  
    if (connection != null) {  
        connection.close();  
    }  
}  
</code></pre><h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><p>具体的步骤:<br>1.初始化资源。 </p>
<ol>
<li>接收消息。 </li>
<li>必要的时候关闭资源。</li>
</ol>
<h4 id="初始化资源放到构造函数里面："><a href="#初始化资源放到构造函数里面：" class="headerlink" title="初始化资源放到构造函数里面："></a>初始化资源放到构造函数里面：</h4><pre><code>public Consumer() throws JMSException {  
    factory = new ActiveMQConnectionFactory(brokerURL);  
    connection = factory.createConnection();  
    connection.start();  
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
}  
</code></pre><h4 id="接收和处理消息的方法"><a href="#接收和处理消息的方法" class="headerlink" title="接收和处理消息的方法"></a>接收和处理消息的方法</h4><p>分为同步和异步的：</p>
<ul>
<li>同步  <code>MessageConsumer.receive()</code>方法</li>
<li><p>异步  注册<code>MessageListener</code>，使用<code>MessageConsumer.setMessageListener()</code>。</p>
<p>  public static void main(String[] args) throws JMSException {  </p>
<pre><code>Consumer consumer = new Consumer();  
for (String stock : args) {  
    Destination destination = consumer.getSession().createTopic(&quot;STOCKS.&quot; + stock);  
    MessageConsumer messageConsumer = consumer.getSession().createConsumer(destination);  
    messageConsumer.setMessageListener(new Listener());  
}  
</code></pre><p>  }  </p>
<p>  public Session getSession() {  </p>
<pre><code>return session;  
</code></pre><p>  }  </p>
</li>
</ul>
<blockquote>
<p>这里的代码不要当真了，写得很烂</p>
</blockquote>
<h4 id="Listener负责处理接收到的消息："><a href="#Listener负责处理接收到的消息：" class="headerlink" title="Listener负责处理接收到的消息："></a><code>Listener</code>负责处理接收到的消息：</h4><pre><code>public class Listener implements MessageListener {  
    public void onMessage(Message message) {  
        try {  
            MapMessage map = (MapMessage)message;  
            String stock = map.getString(&quot;stock&quot;);  
            double price = map.getDouble(&quot;price&quot;);  
            double offer = map.getDouble(&quot;offer&quot;);  
            boolean up = map.getBoolean(&quot;up&quot;);  
            DecimalFormat df = new DecimalFormat( &quot;#,###,###,##0.00&quot; );  
            System.out.println(stock + &quot;\t&quot; + df.format(price) + &quot;\t&quot; + df.format(offer) + &quot;\t&quot; + (up?&quot;up&quot;:&quot;down&quot;));  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  
}  
</code></pre><p>实现了<code>MessageListener</code>接口，里面的<code>onMessage</code>方法在接收到消息之后会被调用的方法。</p>
<h3 id="实现pub-sub模式的步骤"><a href="#实现pub-sub模式的步骤" class="headerlink" title="实现pub-sub模式的步骤"></a>实现pub-sub模式的步骤</h3><p>两者设定一个共同的topic。</p>
<p>在publisher端通过<code>session</code>创建<code>producer</code>，根据指定的参数创建<code>destination</code>，然后将消息和<code>destination</code>作为<code>producer.send()</code>方法的参数。</p>
<p>在consumer端也要创建类似的<code>connection</code>,<code>session</code>。通过<code>session</code>得到<code>destination</code>，再通过<code>session.createConsumer(destination)</code>来得到一个<code>MessageConsumer</code>对象。有了这个<code>MessageConsumer</code>就可以自行选择是直接同步的<code>receive</code>消息还是注册listener了。</p>
<h2 id="p2p"><a href="#p2p" class="headerlink" title="p2p"></a>p2p</h2><p><img src="/img/JMS点对点模式示意图.jpg" alt="JMS点对点模式示意图"></p>
<p>在p2p的场景里，相互通信的双方是通过一个类似于队列的方式来进行交流。和pub-sub的区别在于一个消息会发送给订阅此topic的多个订阅者，而在p2p里queue的消息只能被一个接受者接受。</p>
<h3 id="发送者"><a href="#发送者" class="headerlink" title="发送者"></a>发送者</h3><pre><code>public Publisher() throws JMSException {  
    factory = new ActiveMQConnectionFactory(brokerURL);  
    connection = factory.createConnection();  
    connection.start();  
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
    producer = session.createProducer(null);  
}
</code></pre><h4 id="发送消息："><a href="#发送消息：" class="headerlink" title="发送消息："></a>发送消息：</h4><pre><code>public void sendMessage() throws JMSException {  
    for(int i = 0; i &lt; jobs.length; i++)  
    {  
        String job = jobs[i];  
        Destination destination = session.createQueue(&quot;JOBS.&quot; + job);  
        Message message = session.createObjectMessage(i);  
        System.out.println(&quot;Sending: id: &quot; + ((ObjectMessage)message).getObject() + &quot; on queue: &quot; + destination);  
        producer.send(destination, message);  
    }  
}  
</code></pre><h4 id="消息发送者的启动代码："><a href="#消息发送者的启动代码：" class="headerlink" title="消息发送者的启动代码："></a>消息发送者的启动代码：</h4><pre><code>public static void main(String[] args) throws JMSException {  
    Publisher publisher = new Publisher();  
    for(int i = 0; i &lt; 10; i++) {  
        publisher.sendMessage();  
        System.out.println(&quot;Published &quot; + i + &quot; job messages&quot;);  
    try {  
            Thread.sleep(1000);  
        } catch (InterruptedException x) {  
            e.printStackTrace();  
        }  
    }  
    publisher.close();  
}  
</code></pre><p>在这里发送10条消息，在每个<code>sendMessage</code>的方法里实际上是针对每个<code>queue</code>发送了10条。</p>
<h3 id="接收者"><a href="#接收者" class="headerlink" title="接收者"></a>接收者</h3><pre><code>public Consumer() throws JMSException {  
    factory = new ActiveMQConnectionFactory(brokerURL);  
    connection = factory.createConnection();  
    connection.start();  
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
}  


public static void main(String[] args) throws JMSException {  
        Consumer consumer = new Consumer();  
        for (String job : consumer.jobs) {  
            Destination destination = consumer.getSession().createQueue(&quot;JOBS.&quot; + job);  
            MessageConsumer messageConsumer = consumer.getSession().createConsumer(destination);  
            messageConsumer.setMessageListener(new Listener(job));  
        }  
    }  

    public Session getSession() {  
        return session;  
    }
</code></pre><h4 id="MessageListener接口实现类"><a href="#MessageListener接口实现类" class="headerlink" title="MessageListener接口实现类"></a><code>MessageListener</code>接口实现类</h4><pre><code>import javax.jms.Message;  
import javax.jms.MessageListener;  
import javax.jms.ObjectMessage;  

public class Listener implements MessageListener {        
    private String job;  

    public Listener(String job) {  
        this.job = job;  
    }  

    public void onMessage(Message message) {  
        try {  
            //do something here  
            System.out.println(job + &quot; id:&quot; + ((ObjectMessage)message).getObject());  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }        
}
</code></pre><h2 id="比较pub-sub和p2p模式"><a href="#比较pub-sub和p2p模式" class="headerlink" title="比较pub-sub和p2p模式"></a>比较pub-sub和p2p模式</h2><p>基本的处理流程都是类似的，除了在pub-sub中要通过<code>createTopic</code>来设置topic，而在p2p中要通过<code>createQueue</code>来创建通信队列。</p>
<h2 id="request-response"><a href="#request-response" class="headerlink" title="request-response"></a>request-response</h2><p>和前面两种方式比较起来，request-response的通信方式很常见，但是不是默认提供的一种模式。在前面的两种模式中都是一方负责发送消息而另外一方负责处理。而实际中的很多应用需要双方都能给对方发送消息。<br>请求-应答方式并不是JMS规范系统默认提供的一种通信方式，而是通过在现有通信方式的基础上稍微运用一点技巧实现的。</p>
<blockquote>
<p>以下这种方式只能说是很差，并不是什么高明的做法</p>
</blockquote>
<p><img src="/img/JMS实际应用中产生的应答方式示意图.jpg" alt="JMS实际应用中产生的应答方式示意图"><br>在JMS里面，如果要实现请求/应答的方式，可以利用<code>JMSReplyTo</code>和<code>JMSCorrelationID</code>消息头来将通信的双方关联起来。另外，<code>QueueRequestor</code>和<code>TopicRequestor</code>能够支持简单的请求/应答过程。</p>
<pre><code>// client side  
Destination tempDest = session.createTemporaryQueue();  
MessageConsumer responseConsumer = session.createConsumer(tempDest);  
...  

// send a request..  
message.setJMSReplyTo(tempDest)  
message.setJMSCorrelationID(myCorrelationID);  

producer.send(message);  
</code></pre><p>client端创建一个临时队列并在发送的消息里指定了发送返回消息的<code>destination</code>以及<code>correlationID</code>。那么在处理消息的server端得到这个消息后就知道该发送给谁了。Server端的大致流程如下：</p>
<pre><code>public void onMessage(Message request) {  

  Message response = session.createMessage();  
  response.setJMSCorrelationID(request.getJMSCorrelationID())  

  producer.send(request.getJMSReplyTo(), response)  
}  
</code></pre><p>这里是在server端注册<code>MessageListener</code>，通过设置返回信息的<code>CorrelationID</code>和<code>JMSReplyTo</code>将信息返回。</p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client:"></a>Client:</h3><pre><code>public Client() {  
    ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://localhost:61616&quot;);  
    Connection connection;  
    try {  
        connection = connectionFactory.createConnection();  
        connection.start();  
        Session session = connection.createSession(transacted, ackMode);  
        Destination adminQueue = session.createQueue(clientQueueName);  

        //Setup a message producer to send message to the queue the server is consuming from  
        this.producer = session.createProducer(adminQueue);  
        this.producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);  

        //Create a temporary queue that this client will listen for responses on then create a consumer  
        //that consumes message from this temporary queue...for a real application a client should reuse  
        //the same temp queue for each message to the server...one temp queue per client  
        Destination tempDest = session.createTemporaryQueue();  
        MessageConsumer responseConsumer = session.createConsumer(tempDest);  

        //This class will handle the messages to the temp queue as well  
        responseConsumer.setMessageListener(this);  

        //Now create the actual message you want to send  
        TextMessage txtMessage = session.createTextMessage();  
        txtMessage.setText(&quot;MyProtocolMessage&quot;);  

        //Set the reply to field to the temp queue you created above, this is the queue the server  
        //will respond to  
        txtMessage.setJMSReplyTo(tempDest);  

        //Set a correlation ID so when you get a response you know which sent message the response is for  
        //If there is never more than one outstanding message to the server then the  
        //same correlation ID can be used for all the messages...if there is more than one outstanding  
        //message to the server you would presumably want to associate the correlation ID with this  
        //message somehow...a Map works good  
        String correlationId = this.createRandomString();  
        txtMessage.setJMSCorrelationID(correlationId);  
        this.producer.send(txtMessage);  
    } catch (JMSException e) {  
        //Handle the exception appropriately  
    }  
}  
</code></pre><p>这里的代码除了初始化构造函数里的参数还同时设置了两个destination，一个是自己要发送消息出去的destination，在<code>session.createProducer(adminQueue);</code>这一句设置。另外一个是自己要接收的消息destination, 通过<code>Destination tempDest = session.createTemporaryQueue(); responseConsumer = session.createConsumer(tempDest);</code> 这两句指定了要接收消息的目的地。这里是用的一个临时队列。在前面指定了返回消息的通信队列之后，需要通知server端知道发送返回消息给哪个队列。于是<code>txtMessage.setJMSReplyTo(tempDest);</code>指定了这一部分，同时<code>txtMessage.setJMSCorrelationID(correlationId);</code>方法主要是为了保证每次发送回来请求的server端能够知道对应的是哪个请求。这里一个请求和一个应答是相当于对应一个相同的序列号一样。</p>
<p>同时，因为client端在发送消息之后还要接收server端返回的消息，所以它也要实现一个消息receiver的功能。这里采用实现<code>MessageListener</code>接口的方式：</p>
<pre><code>public void onMessage(Message message) {  
    String messageText = null;  
    try {  
        if (message instanceof TextMessage) {  
            TextMessage textMessage = (TextMessage) message;  
            messageText = textMessage.getText();  
            System.out.println(&quot;messageText = &quot; + messageText);  
        }  
    } catch (JMSException e) {  
        //Handle the exception appropriately  
    }  
}  
</code></pre><h3 id="Server"><a href="#Server" class="headerlink" title="Server:"></a>Server:</h3><p>这里server端要执行的过程和client端相反，它是先接收消息，在接收到消息后根据提供的<code>JMSCorelationID</code>来发送返回的消息：</p>
<pre><code>public void onMessage(Message message) {  
    try {  
        TextMessage response = this.session.createTextMessage();  
        if (message instanceof TextMessage) {  
            TextMessage txtMsg = (TextMessage) message;  
            String messageText = txtMsg.getText();  
            response.setText(this.messageProtocol.handleProtocolMessage(messageText));  
        }  

        //Set the correlation ID from the received message to be the correlation id of the response message  
        //this lets the client identify which message this is a response to if it has more than  
        //one outstanding message to the server  
        response.setJMSCorrelationID(message.getJMSCorrelationID());  

        //Send the response to the Destination specified by the JMSReplyTo field of the received message,  
        //this is presumably a temporary queue created by the client  
        this.replyProducer.send(message.getJMSReplyTo(), response);  
    } catch (JMSException e) {  
        //Handle the exception appropriately  
    }  
}
</code></pre><p>前面，在<code>replyProducer.send()</code>方法里，<code>message.getJMSReplyTo()</code>就得到了要发送消息回去的destination。<br>另外，设置这些发送返回信息的replyProducer的信息主要在构造函数相关的方法里实现了：</p>
<pre><code>public Server() {  
    try {  
        //This message broker is embedded  
        BrokerService broker = new BrokerService();  
        broker.setPersistent(false);  
        broker.setUseJmx(false);  
        broker.addConnector(messageBrokerUrl);  
        broker.start();  
    } catch (Exception e) {  
        //Handle the exception appropriately  
    }  

    //Delegating the handling of messages to another class, instantiate it before setting up JMS so it  
    //is ready to handle messages  
    this.messageProtocol = new MessageProtocol();  
    this.setupMessageQueueConsumer();  
}  

private void setupMessageQueueConsumer() {  
    ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(messageBrokerUrl);  
    Connection connection;  
    try {  
        connection = connectionFactory.createConnection();  
        connection.start();  
        this.session = connection.createSession(this.transacted, ackMode);  
        Destination adminQueue = this.session.createQueue(messageQueueName);  

        //Setup a message producer to respond to messages from clients, we will get the destination  
        //to send to from the JMSReplyTo header field from a Message  
        this.replyProducer = this.session.createProducer(null);  
        this.replyProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);  

        //Set up a consumer to consume messages off of the admin queue  
        MessageConsumer consumer = this.session.createConsumer(adminQueue);  
        consumer.setMessageListener(this);  
    } catch (JMSException e) {  
        //Handle the exception appropriately  
    }  
}
</code></pre><p>对于请求/应答的方式来说，这种典型交互的过程就是Client端在设定正常发送请求的Queue同时也设定一个临时的Queue。同时在要发送的message里头指定要返回消息的destination以及CorelationID，这些就好比是一封信里面所带的回执。根据这个信息人家才知道怎么给你回信。对于Server端来说则要额外创建一个producer，在处理接收到消息的方法里再利用producer将消息发回去。这一系列的过程看起来很像http协议里面请求-应答的方式，都是一问一答。</p>
<h2 id="一些应用和改进"><a href="#一些应用和改进" class="headerlink" title="一些应用和改进"></a>一些应用和改进</h2><p>回顾前面三种基本的通信方式，发现它们都存在着一定的共同点，比如说都要初始化<code>ConnectionFactory</code>, <code>Connection</code>, <code>Session</code>等。在使用完之后都要将这些资源关闭。如果每一个实现它的通信端都这么写一通的话，其实是一种简单的重复。从工程的角度来看是完全没有必要的。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>通过工厂方法封装这些对象的创建和销毁，然后简单的通过调用工厂方法的方式得到它们。<br>既然基本的流程都是在开头创建资源在结尾销毁，也可以采用Template Method模式的思路。通过继承一个抽象类，在抽象类里提供了资源的封装。所有继承的类只要实现怎么去使用这些资源的方法就可以了。</p>
]]></content>
    
    <summary type="html">
    
      activemq的几种基本通信方式总结
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS，ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS%EF%BC%8CActiveMQ/"/>
    
    
      <category term="activeMQ" scheme="http://jishusuishouji.github.io/tags/activeMQ/"/>
    
  </entry>
  
  <entry>
    <title>基于ZooKeeper和Thrift构建动态RPC调用</title>
    <link href="http://jishusuishouji.github.io/2017/04/03/thrift/%E5%9F%BA%E4%BA%8EZooKeeper%E5%92%8CThrift%E6%9E%84%E5%BB%BA%E5%8A%A8%E6%80%81RPC%E8%B0%83%E7%94%A8/"/>
    <id>http://jishusuishouji.github.io/2017/04/03/thrift/基于ZooKeeper和Thrift构建动态RPC调用/</id>
    <published>2017-04-03T10:49:07.000Z</published>
    <updated>2017-04-03T14:57:53.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、基本功能"><a href="#一、基本功能" class="headerlink" title="一、基本功能"></a>一、基本功能</h2><p>实现服务端向ZooKeeper集群注册自己提供的服务，并且把自己的IP地址和服务端口创建到具体的服务目录下。客户端向ZooKeeper集群监听自己关注的RPC服务（例如：<code>sayHello</code>和天气服务）， 监听服务目录下的IP地址列表变化。若要在自己的项目中使用，可以采用阿里的Dubbo分布式服务框架。<br>在WEB端展示可以访问的RPC服务，WEB端可以通过RPC客户端向指定IP地址的RPC服务器发出调用RPC服务，RPC服务端向客户端反馈提供的服务内容，WEB客户端展示内容。<br>只是展示动态RPC基本原理，真正的调用一般都不是web端触发的，应该是RPC的客户端根据监听到的多个IP服务提供者，根据每个IP的负载情况，动态选择最优可用的RPC服务端并且调用服务。 </p>
<p>我们提供2个基本RPC服务，网络及应用部署如图:<br><img src="/img/基本RPC服务网络及应用部署" alt="基本RPC服务网络及应用部署"></p>
<h2 id="二、ZooKeeper介绍"><a href="#二、ZooKeeper介绍" class="headerlink" title="二、ZooKeeper介绍"></a>二、ZooKeeper介绍</h2><p>ZooKeeper是一个开放源代码的分布式应用程序协调服务，由知名互联网公司雅虎创建，是Google的Chubby一个开源的实现，是Hadoop和Hbase的重要组件。<br>ZooKeeper的目标就是封装好复杂易出错的关键服务，将简单易用的接口和性能高效、功能稳定的系统提供给用户。它是一个为分布式应用提供一致性服务的软件，以下是ZooKeeper典型的应用场景</p>
<ul>
<li>数据发布和订阅：就是发布者将数据发布到ZooKeeper的一个或一系列节点上，供订阅者进行数据订阅，进而达到动态获取数据的目的，实现配置信息的集中管理和数据的动态更新。</li>
<li>负载均衡：用来对多个计算机、网络连接、CPU、磁盘驱动或其他资源进分配负载，已达到优化资源使用、最大化吞吐率、最下化响应和避免过载。</li>
<li>命名服务：命名服务是分布式系统最基本的公共服务之一。在分布式系统中，被命名的实体通常可以就是集群中的机器、提供的服务地址或远程对象等–这些我们都可以统称它们的名称（Name），其中较常见的就是一些分布式服务框架（如RPC、RMI）中的服务地址列表，通过使用命名服务，客户端应用能够指定名字来获取资源的实体、服务地址和提供者的信息。</li>
<li>集群管理：随着分布式系统规模的日益扩大，集群中的机器规模也随之变大、因此集群监控与集群控制就变得很重要。</li>
<li>分布式锁：分布式锁就是控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。</li>
<li>分布式队列：利用Zookeeper的功能我们也可以实现类似于ActiveMQ、Kafka和HornetQ等的消息中间件。</li>
</ul>
<h2 id="三、构建ZooKeeper集群机及RPC服务机"><a href="#三、构建ZooKeeper集群机及RPC服务机" class="headerlink" title="三、构建ZooKeeper集群机及RPC服务机"></a>三、构建ZooKeeper集群机及RPC服务机</h2><p>在Ubuntu桌面系统下完成，利用Oracle下的虚拟机软件VirtualBox。虚拟出了５个Ubuntu 操作系统，３个ZooKeeper机，分别是ZooKeeper-1,ZooKeeper-2,ZooKeeper-3个构建出一个ZooKeeper集群。２个RPC服务机，把在宿主机编写好的程序，通过打包的方式，发布到RPC服务机的jetty下，提供RPC服务 。</p>
<h2 id="四、配置ZooKeeper"><a href="#四、配置ZooKeeper" class="headerlink" title="四、配置ZooKeeper"></a>四、配置ZooKeeper</h2><p>从官方网站下载后，解压到了虚拟机的<code>/work/</code>目录下，将<code>/work/zookeeper-3.4.8/conf/</code>目录下的<code>zoo_sample.cfg</code>重新复制一份命名为<code>zoo.cfg</code>,打开<code>zoo.cfg</code>文件。　<br>修改配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">tickTime=2000    </div><div class="line">ddataDir=/work/data/zookeeper   </div><div class="line">clientPort=2181 </div><div class="line">　   Server.1=192.168.0.3:2888:3888</div><div class="line">Server.2=192.168.0.4:2888:3888</div><div class="line">Server.3=192.168.0.5:2888:3888</div></pre></td></tr></table></figure></p>
<p>参数说明:<br><code>tickTime</code>: zookeeper中使用的基本时间单位, 毫秒值.<br><code>dataDir</code>: 数据和日志的目录. 可以是任意目录.此处我们配置到了<code>/work/data/zookeeper</code>目录下<br><code>clientPort</code>: 监听client连接的端口号.<br><code>Server.X=HOST/IP:port:port</code>　<br>     <code>Server.X</code> ：X是我们配置zookeeper集群服务每台机子的编号，需要在每台机子的<code>/work/data/zookeeper/</code>下创建<code>myid</code>文件，内容就是机子的编号。</p>
<h2 id="五、启动、关闭"><a href="#五、启动、关闭" class="headerlink" title="五、启动、关闭"></a>五、启动、关闭</h2><p>切换到<code>/work/zookeeper-3.4.8/bin</code>目录下 </p>
<h3 id="1-启动"><a href="#1-启动" class="headerlink" title="1. 启动"></a>1. 启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./zkServer.sh start</div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /work/zookeeper-3.4.8/bin/../conf/zoo.cfg</div><div class="line">Starting zookeeper ... STARTED</div></pre></td></tr></table></figure>
<h4 id="2-验证"><a href="#2-验证" class="headerlink" title="2.验证"></a>2.验证</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">./zkCli.sh</div><div class="line">[zk: localhost:2181(CONNECTED) 0]</div></pre></td></tr></table></figure>
<p>进入ZooKeeper 客户端终端命令就说明ZooKeeper启动成功了。 </p>
<h3 id="3-关闭"><a href="#3-关闭" class="headerlink" title="3. 关闭"></a>3. 关闭</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">./zkServer.sh stop</div><div class="line"></div><div class="line">ZooKeeper JMX enabled by default</div><div class="line">Using config: /work/tool/zookeeper-3.4.8/bin/../conf/zoo.cfg</div><div class="line">Stopping zookeeper ... STOPPED</div></pre></td></tr></table></figure>
<h2 id="六、利用Thrift提供RPC服务"><a href="#六、利用Thrift提供RPC服务" class="headerlink" title="六、利用Thrift提供RPC服务"></a>六、利用Thrift提供RPC服务</h2><h3 id="定义Weather-thrift文件"><a href="#定义Weather-thrift文件" class="headerlink" title="定义Weather.thrift文件"></a>定义<code>Weather.thrift</code>文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">namespace java com.rpc.weather</div><div class="line">　　　　 　　service weather&#123; </div><div class="line">    　　string getWeather(1:string city) </div><div class="line"> 　　&#125;</div></pre></td></tr></table></figure>
<h3 id="生成JAVA文件接口"><a href="#生成JAVA文件接口" class="headerlink" title="生成JAVA文件接口"></a>生成JAVA文件接口</h3><p>在windows环境下使用Thrift工具编译<code>.thrift</code>文件，就会生成相应的<code>.java</code> 文件。该文件包含了在<code>.thrift</code>文件中描述的服务类的接口定义，即<code>.Iface</code>接口，以及服务调用的底层通信细节。命令如下:　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thrift.exe -r -gen java 　weather.thrift</div></pre></td></tr></table></figure></p>
<p>该命令会自动生产相应的JAVA文件</p>
<p><code>gen-java</code>目录就是生成好代码的地方</p>
<h3 id="实现RPC接口功能"><a href="#实现RPC接口功能" class="headerlink" title="实现RPC接口功能"></a>实现RPC接口功能</h3><p>weather的接口实现比较复杂，在这里我们用简单些Hello来说明，道理是一样的。Hello接口的实现： hello只是一个简单的反馈功能，它把客户端传递过来的参数经过简单的组合一起反馈给ＲＰＣ的客户端，本例只是简单展示了一下ＲＰＣ服务处理能力，实现上面已经生产好的Hello.Iface 接口。代码如下：<br>public class HelloServiceImpl implements com.rpc.sayhello.Hello.Iface {<br>    public String helloString(String para) throws TException {<br>        System.out.println(“helloString be calling”);<br>        return “你好:” + para + “,欢迎来到”+GetIP.IP()+”服务器!”;<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>1<br>2<br>3<br>4<br>5<br>6</p>
<h2 id="七、RPC服务注册"><a href="#七、RPC服务注册" class="headerlink" title="七、RPC服务注册"></a>七、RPC服务注册</h2><p>我们在ZooKeeper注册了2个服务（2个ZNode节点），分别是sayHello及Weather。用2个IP提供RPC的服务。目录结构如图-：<br>这里写图片描述<br>在Zookeeper的每个节点，都可以分为持久节点和临时节点　持久节点是指一旦这个节点被创建了，除非主动进行删除操作，否则这个节点将一直保存在ＺooKeeper中.而临时节点就不一样了，它的生命周期和客户端回话绑定，一旦客户端回话失效，那么这个客户端创建的所有临时节点都会被移除。ZooKeeper主要是利用了“心跳检测”功能，它会定时向各个服务提供者发送一个请求，如果长期没有响应，服务中心就认为该服务提供者已经“挂了”，并将其剔除。注意临时节点下不可以在创建任何节点。</p>
<p>注册天气服务的主要代码：</p>
<p>private void createServerHost()  {<br>        Stat stat = zookeeper.exists(WeatherConstants.RPCNAME + “/“ + GetIP.IP() + “:” + WeatherConstants.WeahterPort,false);//检查节点是否存在<br>        if (stat == null) {<br>　　　　　　// 这里是临时的节点，会因服务器的宕机、网络失效而消失<br>    path = zookeeper.create(WeatherConstants.RPCNAME + “/“ + GetIP.IP() + “:” + 　　WeatherConstants.WeahterPort, “”.getBytes(),Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);//创建节点　<br>        }<br>    }<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>1<br>2<br>3<br>4<br>5<br>6<br>7</p>
<h2 id="八、RPC客戶端服务监听"><a href="#八、RPC客戶端服务监听" class="headerlink" title="八、RPC客戶端服务监听"></a>八、RPC客戶端服务监听</h2><p>Watcher(事件监听器)，是ZooKeeper的一个很重要的特性。ZooKeeper允许用户在指定的节点上注册一些Watcher，并且在一些特定的事件触发的时候，ZooKeeper服务器会将事件通知到感兴趣的客户端。利用Watcher监听2个服务节点下的IP变化，一旦我们监听的服务下的节点有变化（增加或减少）ZooKeeper就会向我们注册的监听类发送“NodeChildrenChanged”事件，我们就可以在此时更新地址列表变化，从而进行更新。<br>需要注意的是ZooKeeper服务器在向客户端发送Watcher的通知的时候，仅仅只会发出一个通知，而不会把节点的变化情况发送给客户端，客户端需要自己重新获取。另外，由于Watcher通知是一次性的，一旦触发一次通知后，该Watcher就失效了，因此客户端需要反复注册Watcher。</p>
<p>监听服务列表的变化<br>在监听WatchWeather类内我们定义了一个weatherlist的数组列表，用来存储提供天气的所有ＲＰＣ服务的地址和端口。<br>通过zookeeper.getChildren获取在zookeeper注册的所有提供天气的ＩＰ地址。并且注册了在这个节点下的监听类。</p>
<p>　　　　weatherlist = zookeeper.getChildren(WeatherConstants.RPCNAME, this);<br>　　　 //在监听的WatchWeather实现Watcher接口的process方法：<br>　　　　public void process(WatchedEvent event) {<br>        if (EventType.NodeChildrenChanged == event.getType()) { 　<br>        　　weatherlist = zookeeper.getChildren(WeatherConstants.RPCNAME, this);<br>　　　　　}  　<br>    }<br>　　<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>只要我们监听的节点下有变动就会接受到NodeChildrenChanged 事件，在这里我们再次获取了节点下的最新ＩＰ地址列表，并且重新注册了监听类。</p>
<h2 id="九、调用RPC服务"><a href="#九、调用RPC服务" class="headerlink" title="九、调用RPC服务"></a>九、调用RPC服务</h2><p>public class CallWeatherRPC {<br>    public String callWeather(String ip, int port, String city) {<br>        String retString = null;<br>        TTransport transport = new TSocket(ip, port);<br>        transport.open();<br>        TProtocol protocol = new TBinaryProtocol(transport);<br>        weather.Client client = new weather.Client(protocol);//weather为定义接口实现的文件<br>        retString = client.getWeather(city);//调用ＲＰＣ服务<br>        transport.close();<br>        return retString;<br>    }<br>}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>此处是使用了Thrift的客户端调用RPC服务端的相应程序，主要特点是IP地址不固定，可以有多地址可以调用。</p>
]]></content>
    
    <summary type="html">
    
      基于ZooKeeper和Thrift构建动态RPC调用
    
    </summary>
    
      <category term="分布式" scheme="http://jishusuishouji.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
      <category term="RPC" scheme="http://jishusuishouji.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RPC/"/>
    
      <category term="Thrift" scheme="http://jishusuishouji.github.io/categories/%E5%88%86%E5%B8%83%E5%BC%8F/RPC/Thrift/"/>
    
    
      <category term="RPC" scheme="http://jishusuishouji.github.io/tags/RPC/"/>
    
      <category term="ZoopKeeper" scheme="http://jishusuishouji.github.io/tags/ZoopKeeper/"/>
    
      <category term="Thrift" scheme="http://jishusuishouji.github.io/tags/Thrift/"/>
    
  </entry>
  
  <entry>
    <title>Apache Thrift学习之一（入门及Java实例演示）</title>
    <link href="http://jishusuishouji.github.io/2017/04/03/thrift/Apache_Thrift%E5%AD%A6%E4%B9%A0%E4%B9%8B%E4%B8%80%EF%BC%88%E5%85%A5%E9%97%A8%E5%8F%8AJava%E5%AE%9E%E4%BE%8B%E6%BC%94%E7%A4%BA%EF%BC%89/"/>
    <id>http://jishusuishouji.github.io/2017/04/03/thrift/Apache_Thrift学习之一（入门及Java实例演示）/</id>
    <published>2017-04-03T09:58:39.000Z</published>
    <updated>2017-04-04T14:33:34.955Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>Apache Thrift是Facebook实现的一种高效的、支持多种编程语言的远程服务调用的框架。Thrift是由Facebook开发的，并在2008年捐给了Apache基金会，成为了一个孵化器项目。</p>
<p>Thrift是一个软件框架，用来进行可扩展且跨语言的服务开发。它结合了功能强大的软件堆栈和代码生成引擎，</p>
<p>Thrift是一个驱动层接口，它提供了用于客户端使用多种语言实现的API。<br>Thrift是个代码生成库，支持的客户端语言包括C++, Java, Python, PHP, Ruby, Erlang, Perl, Haskell, C#, Cocoa, JavaScript, Node.js, Smalltalk, and OCaml 。它的目标是为了各种流行的语言提供便利的RPC调用机制，而不需要使用那些开销巨大的方式，比如SOAP。</p>
<p>要使用Thrift，就要使用一个语言中立的服务定义文件，描述数据类型和服务接口。这个文件会被用作引擎的输入，编译器为每种支持的语言生成代码。这种静态生成的设计让它非常容易被开发者所使用，而且因为类型验证都发生在编译期而非运行期，所以代码可以很有效率地运行。</p>
<p>Thrift的设计提供了以下这些特性：<br>1、语言无关的类型<br>因为类型是使用定义文件按照语言中立的方式规定的，所以它们可以被不同的语言分享。比如，C++的结构可以和Python的字典类型相互交换数据。<br>2、通用传输接口<br>不论你使用的是磁盘文件、内存数据还是socket流，都可以使用同一段应用代码。<br>3、协议无关<br>Thrift会对数据类型进行编码和解码，可以跨协议使用。<br>4、支持版本<br>数据类型可以加入版本信息，来支持客户端API的更新。</p>
<h2 id="二、下载配置"><a href="#二、下载配置" class="headerlink" title="二、下载配置"></a>二、下载配置</h2><h3 id="1）安装thrift：到thrift官网下载exe文件，然后将文件重命名为thrift-exe-拷贝到D-EBOOK-thrift目录下-或者任何目录下-，然后就可以在dos环境下使用了"><a href="#1）安装thrift：到thrift官网下载exe文件，然后将文件重命名为thrift-exe-拷贝到D-EBOOK-thrift目录下-或者任何目录下-，然后就可以在dos环境下使用了" class="headerlink" title="1）安装thrift：到thrift官网下载exe文件，然后将文件重命名为thrift.exe,拷贝到D:\EBOOK\thrift目录下(或者任何目录下)，然后就可以在dos环境下使用了"></a>1）安装thrift：到thrift官网下载exe文件，然后将文件重命名为<code>thrift.exe</code>,拷贝到<code>D:\EBOOK\thrift</code>目录下(或者任何目录下)，然后就可以在dos环境下使用了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\EBOOK\thrift&gt;thrift -gen java D:\work\workspace\thriftworkspace\demo1\demoHello.thrift</div></pre></td></tr></table></figure>
<p>输出的java文件默认输出到当前目录下<code>D:\EBOOK\thrift\gen-java</code>，也可以使用<code>-o</code>参数指定输出路径;</p>
<h3 id="2）下载相关依赖包"><a href="#2）下载相关依赖包" class="headerlink" title="2）下载相关依赖包"></a>2）下载相关依赖包</h3><h4 id="2-1）libthrift-jar-，下载地址：http-repo1-maven-org-maven2-org-apache-thrift-libthrift-0-9-0"><a href="#2-1）libthrift-jar-，下载地址：http-repo1-maven-org-maven2-org-apache-thrift-libthrift-0-9-0" class="headerlink" title="2.1）libthrift.jar ，下载地址：http://repo1.maven.org/maven2/org/apache/thrift/libthrift/0.9.0/"></a>2.1）<code>libthrift.jar</code> ，下载地址：<a href="http://repo1.maven.org/maven2/org/apache/thrift/libthrift/0.9.0/" target="_blank" rel="external">http://repo1.maven.org/maven2/org/apache/thrift/libthrift/0.9.0/</a></h4><h4 id="2-2）slf4j-api-jar"><a href="#2-2）slf4j-api-jar" class="headerlink" title="2.2）slf4j-api.jar"></a>2.2）<code>slf4j-api.jar</code></h4><h4 id="2-3）slf4j-simple-jar"><a href="#2-3）slf4j-simple-jar" class="headerlink" title="2.3）slf4j-simple.jar"></a>2.3）<code>slf4j-simple.jar</code></h4><p>到官网<a href="http://thrift.apache.org/download" target="_blank" rel="external">http://thrift.apache.org/download</a> 下载最新版本，截止今日（2016-05-23）最新版本为0.9.3</p>
<h3 id="3-Maven项目设置依赖包"><a href="#3-Maven项目设置依赖包" class="headerlink" title="3) Maven项目设置依赖包"></a>3) Maven项目设置依赖包</h3><p>如果是Maven构建项目的，直接在<code>pom.xml</code>中添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">  &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;</div><div class="line">  &lt;artifactId&gt;libthrift&lt;/artifactId&gt;</div><div class="line">  &lt;version&gt;0.8.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<h3 id="4-手动编译"><a href="#4-手动编译" class="headerlink" title="4).手动编译"></a>4).手动编译</h3><p>如果自己编译lib包，把下载的压缩包解压到<code>X</code>盘，然后在<code>X:\thrift-0.8.0\lib\java</code> 目录下运行<code>ant</code>进行自动编译，会在<code>X:\thrift-0.8.0\lib\java\build\</code> 目录下看到编译好的lib包：<code>libthrift-0.8.0.jar</code></p>
<h2 id="三、基本概念"><a href="#三、基本概念" class="headerlink" title="三、基本概念"></a>三、基本概念</h2><h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><h4 id="基本类型："><a href="#基本类型：" class="headerlink" title="基本类型："></a>基本类型：</h4><p><code>bool</code>：布尔值，<code>true</code>或<code>false</code>，对应Java的<code>boolean</code><br><code>byte</code>：8位有符号整数，对应Java的<code>byte</code><br><code>i16</code>：16位有符号整数，对应Java的<code>short</code><br><code>i32</code>：32位有符号整数，对应Java的<code>int</code><br><code>i64</code>：64位有符号整数，对应Java的<code>long</code><br><code>double</code>：64 位浮点数，对应Java的<code>double</code><br><code>string</code>：utf-8编码的字符串，对应Java的<code>String</code></p>
<h4 id="结构体类型："><a href="#结构体类型：" class="headerlink" title="结构体类型："></a>结构体类型：</h4><p><code>struct</code>：定义公共的对象，类似于C语言中的结构体定义，在Java中是一个JavaBean</p>
<h4 id="容器类型："><a href="#容器类型：" class="headerlink" title="容器类型："></a>容器类型：</h4><p><code>list</code>：对应Java的<code>ArrayList</code><br><code>set</code>：对应Java的<code>HashSet</code><br><code>map</code>：对应Java的<code>HashMap</code></p>
<h4 id="异常类型："><a href="#异常类型：" class="headerlink" title="异常类型："></a>异常类型：</h4><p><code>exception</code>：对应Java的<code>Exception</code></p>
<h4 id="服务类型："><a href="#服务类型：" class="headerlink" title="服务类型："></a>服务类型：</h4><p><code>service</code>：对应服务的类</p>
<h3 id="2-服务端编码基本步骤："><a href="#2-服务端编码基本步骤：" class="headerlink" title="2.服务端编码基本步骤："></a>2.服务端编码基本步骤：</h3><ul>
<li>实现服务处理接口impl</li>
<li>创建<code>TProcessor</code>(业务处理器)</li>
<li>创建<code>TServerTransport</code>()</li>
<li>创建<code>TProtocol</code>(传输协议)</li>
<li>创建<code>TServer</code></li>
<li>启动<code>Server</code></li>
</ul>
<h3 id="3-客户端编码基本步骤："><a href="#3-客户端编码基本步骤：" class="headerlink" title="3.客户端编码基本步骤："></a>3.客户端编码基本步骤：</h3><ul>
<li>创建<code>Transport</code></li>
<li>创建<code>TProtocol</code></li>
<li>基于<code>TTransport</code>和<code>TProtocol</code>创建<code>Client</code></li>
<li>调用<code>Client</code>的相应方法</li>
</ul>
<h3 id="4-数据传输协议"><a href="#4-数据传输协议" class="headerlink" title="4.数据传输协议"></a>4.数据传输协议</h3><p><code>TBinaryProtocol</code>: 二进制格式.<br><code>TCompactProtocol</code>: 压缩格式<br><code>TJSONProtocol</code>: JSON格式<br><code>TSimpleJSONProtocol</code>: 提供JSON只写协议, 生成的文件很容易通过脚本语言解析</p>
<blockquote>
<p>客户端和服务端的协议要一致</p>
</blockquote>
<p>##四、实例演示</p>
<h3 id="1-thrift生成代码"><a href="#1-thrift生成代码" class="headerlink" title="1. thrift生成代码"></a>1. thrift生成代码</h3><p>创建Thrift文件：<code>D:\work\workspace\thriftworkspace\demo1\demoHello.thrift</code> ,内容如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">namespace java com.dxz.thrift.demo</div><div class="line"> </div><div class="line">service  HelloWorldService &#123;</div><div class="line">  string sayHello(1:string username)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>thrift-0.8.0.exe是官网提供的windows下编译工具，运用这个工具生成相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">D:\EBOOK\thrift&gt;thrift-0.9.3.exe -r -gen java D:\work\workspace\thriftworkspace\demo1\demoHello.thrift</div></pre></td></tr></table></figure></p>
<p>将生成的<code>HelloWorldService.java</code>文件copy到自己测试的工程中，我的工程是用maven构建的，故在<code>pom.xml</code>中增加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.apache.thrift&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;libthrift&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;0.8.0&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div><div class="line">&lt;dependency&gt;</div><div class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</div><div class="line">    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</div><div class="line">    &lt;version&gt;1.5.8&lt;/version&gt;</div><div class="line">&lt;/dependency&gt;</div></pre></td></tr></table></figure></p>
<p>如果是ant构建的工程，将<code>libthrift-0.9.3.jar</code>加入到工程中</p>
<h3 id="2-实现接口Iface"><a href="#2-实现接口Iface" class="headerlink" title="2. 实现接口Iface"></a>2. 实现接口Iface</h3><p>java代码：<code>HelloWorldImpl.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line">import org.apache.thrift.TException;</div><div class="line">public class HelloWorldImpl implements HelloWorldService.Iface &#123;</div><div class="line">    public HelloWorldImpl() &#123;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public String sayHello(String username) throws TException &#123;</div><div class="line">        return &quot;Hi,&quot; + username + &quot; welcome to thrift world&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-TSimpleServer服务端"><a href="#3-TSimpleServer服务端" class="headerlink" title="3.TSimpleServer服务端"></a>3.<code>TSimpleServer</code>服务端</h3><h4 id="简单的单线程服务模型，一般用于测试。"><a href="#简单的单线程服务模型，一般用于测试。" class="headerlink" title="简单的单线程服务模型，一般用于测试。"></a>简单的单线程服务模型，一般用于测试。</h4><p>编写服务端server代码：<code>HelloServerDemo.java</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TProcessor;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.protocol.TJSONProtocol;</div><div class="line">import org.apache.thrift.protocol.TSimpleJSONProtocol;</div><div class="line">import org.apache.thrift.server.TServer;</div><div class="line">import org.apache.thrift.server.TSimpleServer;</div><div class="line">import org.apache.thrift.transport.TServerSocket;</div><div class="line"></div><div class="line">public class HelloServerDemo &#123;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line"></div><div class="line">    public void startServer() &#123;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;HelloWorld TSimpleServer start ....&quot;);</div><div class="line"></div><div class="line">            TProcessor tprocessor = new HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(new HelloWorldImpl());</div><div class="line">            //HelloWorldService.Processor&lt;HelloWorldService.Iface&gt; tprocessor =</div><div class="line">            new HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(new HelloWorldImpl());</div><div class="line"></div><div class="line">            // 简单的单线程服务模型，一般用于测试</div><div class="line">            TServerSocket serverTransport = new TServerSocket(SERVER_PORT);</div><div class="line">            TServer.Args tArgs = new TServer.Args(serverTransport);</div><div class="line">            tArgs.processor(tprocessor);</div><div class="line">            tArgs.protocolFactory(new TBinaryProtocol.Factory());</div><div class="line">            // tArgs.protocolFactory(new TCompactProtocol.Factory());</div><div class="line">            // tArgs.protocolFactory(new TJSONProtocol.Factory());</div><div class="line">            TServer server = new TSimpleServer(tArgs);</div><div class="line">            server.serve();</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            System.out.println(&quot;Server start error!!!&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloServerDemo server = new HelloServerDemo();</div><div class="line">        server.startServer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="编写客户端Client代码：HelloClientDemo-java"><a href="#编写客户端Client代码：HelloClientDemo-java" class="headerlink" title="编写客户端Client代码：HelloClientDemo.java"></a>编写客户端Client代码：<code>HelloClientDemo.java</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TException;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.protocol.TJSONProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocol;</div><div class="line">import org.apache.thrift.transport.TSocket;</div><div class="line">import org.apache.thrift.transport.TTransport;</div><div class="line">import org.apache.thrift.transport.TTransportException;</div><div class="line"></div><div class="line">public class HelloClientDemo &#123;</div><div class="line"></div><div class="line">    public static final String SERVER_IP = &quot;localhost&quot;;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line">    public static final int TIMEOUT = 30000;</div><div class="line"></div><div class="line">    public void startClient(String userName) &#123;</div><div class="line">        TTransport transport = null;</div><div class="line">        try &#123;</div><div class="line">            transport = new TSocket(SERVER_IP, SERVER_PORT, TIMEOUT);</div><div class="line">            // 协议要和服务端一致</div><div class="line">            TProtocol protocol = new TBinaryProtocol(transport);</div><div class="line">            // TProtocol protocol = new TCompactProtocol(transport);</div><div class="line">            // TProtocol protocol = new TJSONProtocol(transport);</div><div class="line">            HelloWorldService.Client client = new HelloWorldService.Client(protocol);</div><div class="line">            transport.open();</div><div class="line">            String result = client.sayHello(userName);</div><div class="line">            System.out.println(&quot;Thrify client result =: &quot; + result);</div><div class="line">        &#125; catch (TTransportException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (TException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (null != transport) &#123;</div><div class="line">                transport.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloClientDemo client = new HelloClientDemo();</div><div class="line">        client.startClient(&quot;china&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先运行服务端程序，日志如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">HelloWorld TSimpleServer start ....</div></pre></td></tr></table></figure></p>
<p>再运行客户端调用程序，日志如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thrify client result =: Hi,china welcome to thrift world.</div></pre></td></tr></table></figure></p>
<p>测试成功，和预期的返回信息一致。</p>
<h3 id="4-TThreadPoolServer-服务模型"><a href="#4-TThreadPoolServer-服务模型" class="headerlink" title="4.TThreadPoolServer 服务模型"></a>4.TThreadPoolServer 服务模型</h3><p>线程池服务模型，使用标准的阻塞式IO，预先创建一组线程处理请求。</p>
<h4 id="编写服务端代码：HelloServerDemo2-java"><a href="#编写服务端代码：HelloServerDemo2-java" class="headerlink" title="编写服务端代码：HelloServerDemo2.java"></a>编写服务端代码：<code>HelloServerDemo2.java</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TProcessor;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.server.TServer;</div><div class="line">import org.apache.thrift.server.TThreadPoolServer;</div><div class="line">import org.apache.thrift.transport.TServerSocket;</div><div class="line"></div><div class="line">public class HelloServerDemo2 &#123;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line"></div><div class="line">    public void startServer() &#123;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;HelloWorld TThreadPoolServer start ....&quot;);</div><div class="line"></div><div class="line">            TProcessor tprocessor = new HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(new HelloWorldImpl());</div><div class="line"></div><div class="line">            TServerSocket serverTransport = new TServerSocket(SERVER_PORT);</div><div class="line">            TThreadPoolServer.Args ttpsArgs = new TThreadPoolServer.Args(serverTransport);</div><div class="line">            ttpsArgs.processor(tprocessor);</div><div class="line">            ttpsArgs.protocolFactory(new TBinaryProtocol.Factory());</div><div class="line"></div><div class="line">            // 线程池服务模型，使用标准的阻塞式IO，预先创建一组线程处理请求。</div><div class="line">            TServer server = new TThreadPoolServer(ttpsArgs);</div><div class="line">            server.serve();</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            System.out.println(&quot;Server start error!!!&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloServerDemo2 server = new HelloServerDemo2();</div><div class="line">        server.startServer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端Client代码和之前的一样，只要数据传输的协议一致即可，客户端测试成功，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thrify client result =: Hi,china welcome to thrift world.</div></pre></td></tr></table></figure></p>
<h3 id="5-TNonblockingServer-服务模型"><a href="#5-TNonblockingServer-服务模型" class="headerlink" title="5.TNonblockingServer 服务模型"></a>5.TNonblockingServer 服务模型</h3><p>使用非阻塞式IO，服务端和客户端需要指定<code>TFramedTransport</code>数据传输的方式。</p>
<h4 id="编写服务端代码：HelloServerDemo3-java"><a href="#编写服务端代码：HelloServerDemo3-java" class="headerlink" title="编写服务端代码：HelloServerDemo3.java"></a>编写服务端代码：<code>HelloServerDemo3.java</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TProcessor;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.server.TNonblockingServer;</div><div class="line">import org.apache.thrift.server.TServer;</div><div class="line">import org.apache.thrift.server.TThreadPoolServer;</div><div class="line">import org.apache.thrift.transport.TFramedTransport;</div><div class="line">import org.apache.thrift.transport.TNonblockingServerSocket;</div><div class="line">import org.apache.thrift.transport.TServerSocket;</div><div class="line"></div><div class="line">public class HelloServerDemo3 &#123;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line"></div><div class="line">    public void startServer() &#123;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;HelloWorld TNonblockingServer start ....&quot;);</div><div class="line"></div><div class="line">            TProcessor tprocessor = new HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(new HelloWorldImpl());</div><div class="line"></div><div class="line">            TNonblockingServerSocket tnbSocketTransport = new TNonblockingServerSocket(SERVER_PORT);</div><div class="line">            TNonblockingServer.Args tnbArgs = new TNonblockingServer.Args(tnbSocketTransport);</div><div class="line">            tnbArgs.processor(tprocessor);</div><div class="line">            tnbArgs.transportFactory(new TFramedTransport.Factory());</div><div class="line">            tnbArgs.protocolFactory(new TCompactProtocol.Factory());</div><div class="line"></div><div class="line">            // 使用非阻塞式IO，服务端和客户端需要指定TFramedTransport数据传输的方式</div><div class="line">            TServer server = new TNonblockingServer(tnbArgs);</div><div class="line">            server.serve();</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            System.out.println(&quot;Server start error!!!&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloServerDemo3 server = new HelloServerDemo3();</div><div class="line">        server.startServer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="编写客户端代码：HelloClientDemo3-java"><a href="#编写客户端代码：HelloClientDemo3-java" class="headerlink" title="编写客户端代码：HelloClientDemo3.java"></a>编写客户端代码：<code>HelloClientDemo3.java</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TException;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.protocol.TJSONProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocol;</div><div class="line">import org.apache.thrift.transport.TSocket;</div><div class="line">import org.apache.thrift.transport.TTransport;</div><div class="line">import org.apache.thrift.transport.TTransportException;</div><div class="line">import org.apache.thrift.TException;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocol;</div><div class="line">import org.apache.thrift.transport.TFramedTransport;</div><div class="line">import org.apache.thrift.transport.TSocket;</div><div class="line">import org.apache.thrift.transport.TTransport;</div><div class="line">import org.apache.thrift.transport.TTransportException;</div><div class="line"></div><div class="line">public class HelloClientDemo3 &#123;</div><div class="line"></div><div class="line">    public static final String SERVER_IP = &quot;localhost&quot;;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line">    public static final int TIMEOUT = 30000;</div><div class="line"></div><div class="line">    public void startClient(String userName) &#123;</div><div class="line">        TTransport transport = null;</div><div class="line">        try &#123;</div><div class="line">            transport = new TFramedTransport(new TSocket(SERVER_IP, SERVER_PORT, TIMEOUT));</div><div class="line">            // 协议要和服务端一致</div><div class="line">            TProtocol protocol = new TCompactProtocol(transport);</div><div class="line">            HelloWorldService.Client client = new HelloWorldService.Client(protocol);</div><div class="line">            transport.open();</div><div class="line">            String result = client.sayHello(userName);</div><div class="line">            System.out.println(&quot;Thrify client result =: &quot; + result);</div><div class="line">        &#125; catch (TTransportException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (TException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (null != transport) &#123;</div><div class="line">                transport.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloClientDemo3 client = new HelloClientDemo3();</div><div class="line">        client.startClient(&quot;HelloClientDemo3&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端的测试成功，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Thrify client result =: Hi,HelloClientDemo3 welcome to thrift world.</div></pre></td></tr></table></figure></p>
<h3 id="6-THsHaServer服务模型"><a href="#6-THsHaServer服务模型" class="headerlink" title="6.THsHaServer服务模型"></a>6.THsHaServer服务模型</h3><p>半同步半异步的服务端模型，需要指定为：<code>TFramedTransport</code>数据传输的方式。</p>
<h4 id="编写服务端代码：HelloServerDemo4-java"><a href="#编写服务端代码：HelloServerDemo4-java" class="headerlink" title="编写服务端代码：HelloServerDemo4.java"></a>编写服务端代码：<code>HelloServerDemo4.java</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TProcessor;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.server.THsHaServer;</div><div class="line">import org.apache.thrift.server.TNonblockingServer;</div><div class="line">import org.apache.thrift.server.TServer;</div><div class="line">import org.apache.thrift.server.TSimpleServer;</div><div class="line">import org.apache.thrift.server.TThreadPoolServer;</div><div class="line">import org.apache.thrift.transport.TFramedTransport;</div><div class="line">import org.apache.thrift.transport.TNonblockingServerSocket;</div><div class="line">import org.apache.thrift.transport.TServerSocket;</div><div class="line"></div><div class="line">public class HelloServerDemo4 &#123;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line"></div><div class="line">    public void startServer() &#123;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;HelloWorld THsHaServer start ....&quot;);</div><div class="line"></div><div class="line">            TProcessor tprocessor = new HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(new HelloWorldImpl());</div><div class="line"></div><div class="line">            TNonblockingServerSocket tnbSocketTransport = new TNonblockingServerSocket(SERVER_PORT);</div><div class="line">            THsHaServer.Args thhsArgs = new THsHaServer.Args(tnbSocketTransport);</div><div class="line">            thhsArgs.processor(tprocessor);</div><div class="line">            thhsArgs.transportFactory(new TFramedTransport.Factory());</div><div class="line">            thhsArgs.protocolFactory(new TBinaryProtocol.Factory());</div><div class="line"></div><div class="line">            // 半同步半异步的服务模型</div><div class="line">            TServer server = new THsHaServer(thhsArgs);</div><div class="line">            server.serve();</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            System.out.println(&quot;Server start error!!!&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloServerDemo4 server = new HelloServerDemo4();</div><div class="line">        server.startServer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="客户端代码HelloClientDemo4-java"><a href="#客户端代码HelloClientDemo4-java" class="headerlink" title="客户端代码HelloClientDemo4.java"></a>客户端代码<code>HelloClientDemo4.java</code></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import java.io.IOException;</div><div class="line"></div><div class="line">import org.apache.thrift.TException;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocol;</div><div class="line">import org.apache.thrift.transport.TSocket;</div><div class="line">import org.apache.thrift.transport.TTransport;</div><div class="line">import org.apache.thrift.transport.TTransportException;</div><div class="line"></div><div class="line">public class HelloClientDemo4 &#123;</div><div class="line"></div><div class="line">    public static final String SERVER_IP = &quot;localhost&quot;;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line">    public static final int TIMEOUT = 30000;</div><div class="line"></div><div class="line">    public void startClient(String userName) &#123;</div><div class="line">        TTransport transport = null;</div><div class="line">        try &#123;</div><div class="line">            transport = new TFramedTransport(new TSocket(SERVER_IP, SERVER_PORT, TIMEOUT));</div><div class="line">            // 协议要和服务端一致</div><div class="line">            TProtocol protocol = new TBinaryProtocol(transport);</div><div class="line">            // TProtocol protocol = new TCompactProtocol(transport);</div><div class="line">            // TProtocol protocol = new TJSONProtocol(transport);</div><div class="line">            HelloWorldService.Client client = new HelloWorldService.Client(protocol);</div><div class="line">            transport.open();</div><div class="line">            String result = client.sayHello(userName);</div><div class="line">            System.out.println(&quot;Thrify client result =: &quot; + result);</div><div class="line">        &#125; catch (TTransportException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (TException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            if (null != transport) &#123;</div><div class="line">                transport.close();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloClientDemo4 client = new HelloClientDemo4();</div><div class="line">        client.startClient(&quot;HelloClientDemo4&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>结果：Thrify client result =: Hi,HelloClientDemo4 welcome to thrift world.</p>
<h3 id="7-异步客户端"><a href="#7-异步客户端" class="headerlink" title="7.异步客户端"></a>7.异步客户端</h3><p>编写服务端代码：HelloServerDemo5.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import org.apache.thrift.TProcessor;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.server.TNonblockingServer;</div><div class="line">import org.apache.thrift.server.TServer;</div><div class="line">import org.apache.thrift.transport.TFramedTransport;</div><div class="line">import org.apache.thrift.transport.TNonblockingServerSocket;</div><div class="line"></div><div class="line">public class HelloServerDemo5 &#123;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line"></div><div class="line">    public void startServer() &#123;</div><div class="line">        try &#123;</div><div class="line">            System.out.println(&quot;HelloWorld TNonblockingServer start ....&quot;);</div><div class="line"></div><div class="line">            TProcessor tprocessor = new HelloWorldService.Processor&lt;HelloWorldService.Iface&gt;(new HelloWorldImpl());</div><div class="line"></div><div class="line">            TNonblockingServerSocket tnbSocketTransport = new TNonblockingServerSocket(SERVER_PORT);</div><div class="line">            TNonblockingServer.Args tnbArgs = new TNonblockingServer.Args(tnbSocketTransport);</div><div class="line">            tnbArgs.processor(tprocessor);</div><div class="line">            tnbArgs.transportFactory(new TFramedTransport.Factory());</div><div class="line">            tnbArgs.protocolFactory(new TCompactProtocol.Factory());</div><div class="line"></div><div class="line">            // 使用非阻塞式IO，服务端和客户端需要指定TFramedTransport数据传输的方式</div><div class="line">            TServer server = new TNonblockingServer(tnbArgs);</div><div class="line">            server.serve();</div><div class="line"></div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            System.out.println(&quot;Server start error!!!&quot;);</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloServerDemo5 server = new HelloServerDemo5();</div><div class="line">        server.startServer();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编写客户端Client代码：<code>HelloAsynClientDemo.java</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line">package com.dxz.thrift.demo;</div><div class="line"></div><div class="line">import java.util.concurrent.CountDownLatch;</div><div class="line">import java.util.concurrent.TimeUnit;</div><div class="line"></div><div class="line">import org.apache.thrift.TException;</div><div class="line">import org.apache.thrift.async.AsyncMethodCallback;</div><div class="line">import org.apache.thrift.async.TAsyncClientManager;</div><div class="line">import org.apache.thrift.protocol.TCompactProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocolFactory;</div><div class="line">import org.apache.thrift.transport.TNonblockingSocket;</div><div class="line">import org.apache.thrift.transport.TNonblockingTransport;</div><div class="line">import com.dxz.thrift.demo.HelloWorldService.AsyncClient.sayHello_call;</div><div class="line"></div><div class="line">public class HelloAsynClientDemo &#123;</div><div class="line"></div><div class="line">    public static final String SERVER_IP = &quot;localhost&quot;;</div><div class="line">    public static final int SERVER_PORT = 8090;</div><div class="line">    public static final int TIMEOUT = 30000;</div><div class="line"></div><div class="line">    public void startClient(String userName) &#123;</div><div class="line">        try &#123;</div><div class="line">            TAsyncClientManager clientManager = new TAsyncClientManager();</div><div class="line">            TNonblockingTransport transport = new TNonblockingSocket(SERVER_IP, SERVER_PORT, TIMEOUT);</div><div class="line"></div><div class="line">            TProtocolFactory tprotocol = new TCompactProtocol.Factory();</div><div class="line">            HelloWorldService.AsyncClient asyncClient = new HelloWorldService.AsyncClient(tprotocol, clientManager,</div><div class="line">                    transport);</div><div class="line">            System.out.println(&quot;Client start .....&quot;);</div><div class="line"></div><div class="line">            CountDownLatch latch = new CountDownLatch(1);</div><div class="line">            AsynCallback callBack = new AsynCallback(latch);</div><div class="line">            System.out.println(&quot;call method sayHello start ...&quot;);</div><div class="line">            asyncClient.sayHello(userName, callBack);</div><div class="line">            System.out.println(&quot;call method sayHello .... end&quot;);</div><div class="line">            boolean wait = latch.await(30, TimeUnit.SECONDS);</div><div class="line">            System.out.println(&quot;latch.await =:&quot; + wait);</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.out.println(&quot;startClient end.&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public class AsynCallback implements AsyncMethodCallback&lt;sayHello_call&gt; &#123;</div><div class="line">        private CountDownLatch latch;</div><div class="line"></div><div class="line">        public AsynCallback(CountDownLatch latch) &#123;</div><div class="line">            this.latch = latch;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onComplete(sayHello_call response) &#123;</div><div class="line">            System.out.println(&quot;onComplete&quot;);</div><div class="line">            try &#123;</div><div class="line">                // Thread.sleep(1000L * 1);</div><div class="line">                System.out.println(&quot;AsynCall result =:&quot; + response.getResult().toString());</div><div class="line">            &#125; catch (TException e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; catch (Exception e) &#123;</div><div class="line">                e.printStackTrace();</div><div class="line">            &#125; finally &#123;</div><div class="line">                latch.countDown();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        @Override</div><div class="line">        public void onError(Exception exception) &#123;</div><div class="line">            System.out.println(&quot;onError :&quot; + exception.getMessage());</div><div class="line">            latch.countDown();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    /**</div><div class="line">     * @param args</div><div class="line">     */</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        HelloAsynClientDemo client = new HelloAsynClientDemo();</div><div class="line">        client.startClient(&quot;HelloAsynClientDemo&quot;);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>先运行服务程序，再运行客户端程序，测试结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Client start .....</div><div class="line">call method sayHello start ...</div><div class="line">call method sayHello .... end</div><div class="line">onComplete</div><div class="line">AsynCall result =:Hi,HelloAsynClientDemo welcome to thrift world.</div><div class="line">latch.await =:true</div><div class="line">startClient end.</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      Apache Thrift学习之一（入门及Java实例演示）
    
    </summary>
    
      <category term="RPC" scheme="http://jishusuishouji.github.io/categories/RPC/"/>
    
      <category term="Thrift" scheme="http://jishusuishouji.github.io/categories/RPC/Thrift/"/>
    
    
      <category term="facebook" scheme="http://jishusuishouji.github.io/tags/facebook/"/>
    
      <category term="RPC" scheme="http://jishusuishouji.github.io/tags/RPC/"/>
    
      <category term="Thrift" scheme="http://jishusuishouji.github.io/tags/Thrift/"/>
    
  </entry>
  
  <entry>
    <title>facebook的thriff 基于rpc的远程调用实现</title>
    <link href="http://jishusuishouji.github.io/2017/04/03/thriff/facebook%E7%9A%84thriff_%E5%9F%BA%E4%BA%8Erpc%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E5%AE%9E%E7%8E%B0/"/>
    <id>http://jishusuishouji.github.io/2017/04/03/thriff/facebook的thriff_基于rpc的远程调用实现/</id>
    <published>2017-04-03T09:05:33.000Z</published>
    <updated>2017-04-03T09:28:52.804Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RPC、RMI、JMS概念："><a href="#RPC、RMI、JMS概念：" class="headerlink" title="RPC、RMI、JMS概念："></a>RPC、RMI、JMS概念：</h2><h3 id="RPC与RMI的对比"><a href="#RPC与RMI的对比" class="headerlink" title="RPC与RMI的对比"></a>RPC与RMI的对比</h3><p>-远程过程调用 (RPC)是平台中立的，它不理会操作系统之间以及编程语言之间的差异。即RPC支持多种语言，而RMI只支持Java写的应用程序。<br>另外RMI调用远程对象方法，允许方法返回Java对象以及基本数据类型。而RPC不支持对象的概念，传送到RPC服务的消息由外部数据表示 (External Data Representation, XDR) 语言表示，这种语言抽象了字节序类和数据类型结构之间的差异。只有由XDR定义的数据类型才能被传递，RPC不允许传递对象。可以说RMI是面向对象方式的Java RPC。</p>
<h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>Java消息服务(Java Messaging Service, JMS) 是一种允许应用程序创建、发送、接受和读取消息的Java API。JMS与RMI的区别在于，采用JMS服务，对象是在物理上被异步从网络的某个JVM上直接移动到另一个JVM上。(严重怀疑)</p>
<p>而RMI对象是绑定在本地JVM中，只有函数参数和返回值是通过网络传送的。</p>
<h2 id="thrift概念"><a href="#thrift概念" class="headerlink" title="thrift概念"></a>thrift概念</h2><p>是facebook提供的一种跨平台远程通信框架，效率比较高。</p>
<h2 id="thirift用法"><a href="#thirift用法" class="headerlink" title="thirift用法"></a>thirift用法</h2><h3 id="1-编写一个thrift文件Test-thrift，用于确定连接双方的接口。"><a href="#1-编写一个thrift文件Test-thrift，用于确定连接双方的接口。" class="headerlink" title="1.编写一个thrift文件Test.thrift，用于确定连接双方的接口。"></a>1.编写一个thrift文件<code>Test.thrift</code>，用于确定连接双方的接口。</h3><p>简单例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">service Test &#123;</div><div class="line">  void  ping(1: i32 length)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="2-使用thrift编译"><a href="#2-使用thrift编译" class="headerlink" title="2.使用thrift编译"></a>2.使用thrift编译</h3><p>thrift可以用不同命令生成不同文件：</p>
<h4 id="a-生成java文件"><a href="#a-生成java文件" class="headerlink" title="a.生成java文件"></a>a.生成java文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thrift  -gen java Test.thrift</div></pre></td></tr></table></figure>
<p>完成后生成一个java文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Test &#123;                                   </div><div class="line">  public interfaceIface &#123;                   </div><div class="line">    public void ping(int length)throws org.apache.thrift.TException;             </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="b-生成node-js文件："><a href="#b-生成node-js文件：" class="headerlink" title="b.生成node.js文件："></a>b.生成node.js文件：</h4><p>thrift原生支持<code>node.js</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thrift  -gen js:node Test.thrift</div></pre></td></tr></table></figure></p>
<p>完成后生成<code>Test.js</code>和<code>Test_types.js</code>两个文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Thrift = require(&apos;thrift&apos;).Thrift;</div><div class="line">                                </div><div class="line">var ttypes = require(&apos;./Test_types&apos;);</div><div class="line">//HELPER FUNCTIONS AND STRUCTURES</div><div class="line">                                </div><div class="line">var Test_ping_args =function(args) &#123;</div><div class="line">  this.length = null;</div><div class="line">  if(args) &#123;</div><div class="line">    if(args.length !== undefined) &#123;</div><div class="line">      this.length = args.length;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过需要在node.js里加载thrift库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm intall thrift</div></pre></td></tr></table></figure></p>
<p>准备工作到此结束！</p>
<h3 id="3-实战："><a href="#3-实战：" class="headerlink" title="3.实战："></a>3.实战：</h3><p>使用java当客户端,Node.js当服务端。<br>java客户端代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">package apache.thrift;</div><div class="line">              </div><div class="line">import org.apache.thrift.TException;</div><div class="line">import org.apache.thrift.protocol.TBinaryProtocol;</div><div class="line">import org.apache.thrift.protocol.TProtocol;</div><div class="line">import org.apache.thrift.transport.TFramedTransport;</div><div class="line">import org.apache.thrift.transport.TSocket;</div><div class="line">import org.apache.thrift.transport.TTransport;</div><div class="line">import org.apache.thrift.transport.TTransportException;</div><div class="line">              </div><div class="line"></div><div class="line">public class TestUserStorage &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        TTransport transport =new TFramedTransport(new TSocket(&quot;localhost&quot;,9799));</div><div class="line">        try&#123;</div><div class="line">            transport.open();</div><div class="line">        &#125;catch(TTransportException e1) &#123;</div><div class="line">            e1.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        TProtocol protocol =new TBinaryProtocol(transport);</div><div class="line">              </div><div class="line">        UserStorage.Client client =new UserStorage.Client(protocol);</div><div class="line">        try&#123;</div><div class="line">            client.store(new UserProfile(1,&quot;&quot;,&quot;&quot;));</div><div class="line">            System.out.println(client.retrieve(1));</div><div class="line">        &#125;catch(TException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;     </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意两个地方：thrift在java中的实现很多，但是node-thrift模块目前只支持<code>TFramedTransport</code>，<code>TBinaryProtocol</code>，所以使用其他实现时server会出错。另外transport是需要先open进行连接的。</p>
<p>node服务端代码：</p>
<pre><code>var thrift = require(&apos;thrift&apos;);

var UserStorage = require(&apos;./gen-nodejs/UserStorage.js&apos;),
    ttypes = require(&apos;./gen-nodejs/user_types&apos;);

var users = {};

var server = thrift.createServer(UserStorage, {
  store:function(user, success) {
    console.log(&quot;server stored:&quot;, user.uid);
    users[user.uid] = user;
    success();
  },

  retrieve:function(uid, success) {
    console.log(&quot;server retrieved:&quot;, uid);
    success(users[uid]);
  },
});

server.listen(9799);
</code></pre><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">client: UserProfile(uid:1, name:, blurb:)</div><div class="line">server: server stored: 1</div><div class="line">server retrieved: 1</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      facebook的thriff 基于rpc的远程调用实现
    
    </summary>
    
      <category term="RPC" scheme="http://jishusuishouji.github.io/categories/RPC/"/>
    
      <category term="thriff" scheme="http://jishusuishouji.github.io/categories/RPC/thriff/"/>
    
    
      <category term="thriff" scheme="http://jishusuishouji.github.io/tags/thriff/"/>
    
      <category term="rpc" scheme="http://jishusuishouji.github.io/tags/rpc/"/>
    
      <category term="facebook" scheme="http://jishusuishouji.github.io/tags/facebook/"/>
    
  </entry>
  
  <entry>
    <title>hexo安装部署</title>
    <link href="http://jishusuishouji.github.io/2017/04/03/hexo/hexo%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    <id>http://jishusuishouji.github.io/2017/04/03/hexo/hexo安装部署/</id>
    <published>2017-04-03T02:39:14.000Z</published>
    <updated>2017-04-03T04:00:31.737Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo -g  #-g表示全局安装, npm默认为当前项目安装</div></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="Hexo博客的初始化"><a href="#Hexo博客的初始化" class="headerlink" title="Hexo博客的初始化"></a>Hexo博客的初始化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd ~/git</div><div class="line">hexo init hexo  #执行init命令初始化到你指定的hexo目录</div><div class="line">cd hexo</div><div class="line">npm install    #install before start blogging</div><div class="line">hexo generate       #自动根据当前目录下文件,生成静态网页</div><div class="line">hexo server         #运行本地服务</div></pre></td></tr></table></figure>
<p>浏览器输入<code>http://localhost:4000</code>就可以看到效果。</p>
<h2 id="Hexo博客目录结构"><a href="#Hexo博客目录结构" class="headerlink" title="Hexo博客目录结构"></a>Hexo博客目录结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── .deploy       #需要部署的文件</div><div class="line">├── node_modules  #Hexo插件</div><div class="line">├── public        #生成的静态网页文件</div><div class="line">├── scaffolds     #模板</div><div class="line">├── source        #博客正文和其他源文件, 404 favicon CNAME 等都应该放在这里</div><div class="line">|   ├── _drafts   #草稿</div><div class="line">|   └── _posts    #文章</div><div class="line">├── themes        #主题</div><div class="line">├── _config.yml   #全局配置文件</div><div class="line">└── package.json</div></pre></td></tr></table></figure>
<h2 id="安装git插件"><a href="#安装git插件" class="headerlink" title="安装git插件"></a>安装git插件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
<h2 id="自动生成分类和标签的index-html"><a href="#自动生成分类和标签的index-html" class="headerlink" title="自动生成分类和标签的index.html"></a>自动生成分类和标签的<code>index.html</code></h2><h3 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h3><ul>
<li>go to your hexo folder</li>
<li><code>hexo new page categories</code></li>
<li>in the <code>source\categories\index.md</code>, add <code>type: &quot;tags&quot;</code></li>
<li>if you don’t want to have comments on that page, also add <code>comments: false</code></li>
</ul>
<h3 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h3><ul>
<li>go to your hexo folder</li>
<li><code>hexo new page tags</code></li>
<li>in the <code>source\tags\index.md</code>, add <code>type: &quot;tags&quot;</code></li>
<li>if you don’t want to have comments on that page, also add <code>comments: false</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      hexo安装部署
    
    </summary>
    
      <category term="hexo" scheme="http://jishusuishouji.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://jishusuishouji.github.io/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Redis Cluster实现原理</title>
    <link href="http://jishusuishouji.github.io/2017/04/03/redis/Redis_Cluster%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://jishusuishouji.github.io/2017/04/03/redis/Redis_Cluster实现原理/</id>
    <published>2017-04-03T00:56:20.000Z</published>
    <updated>2017-04-05T03:07:43.744Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、Redis-Cluster主要特性和设计"><a href="#一、Redis-Cluster主要特性和设计" class="headerlink" title="一、Redis Cluster主要特性和设计"></a>一、Redis Cluster主要特性和设计</h2><h3 id="集群目标"><a href="#集群目标" class="headerlink" title="集群目标"></a>集群目标</h3><p>1）高性能和线性扩展，最大可以支撑到1000个节点；<br>Cluster架构中无Proxy层，Master与slave之间使用异步replication，且不存在操作的merge。（即操作不能跨多个nodes，不存在merge层）</p>
<p>2）一定程度上保证writes的安全性，需要客户端容忍一定程度的数据丢失;<br>集群将会尽可能（best-effort）保存客户端write操作的数据；<br>通常在<code>failover</code>期间，会有短暂时间内的数据丢失（因为异步replication引起）；<br>当客户端与少数派的节点处于网络分区时（network partition），丢失数据的可能性会更高。（因为节点有效性检测、<code>failover</code>需要更长的时间）</p>
<p>3）可用性：只要集群中大多数<code>master</code>可达、且失效的<code>master</code>至少有一个<code>slave</code>可达时，集群都可以继续提供服务；<br>同时“<code>replicas migration</code>”可以将那些拥有多个<code>slaves</code>的<code>master</code>的某个<code>slave</code>，迁移到没有<code>slave</code>的<code>master</code>下，即将整个集群相对<code>slaves</code>的分布更加平衡，尽力确保每个<code>master</code>都有一定数量的<code>slave</code>备份。</p>
<p>（Redis Cluster集群由多个shard组成，每个shard可以由一个master和多个slaves构成，数据根据hash slots配额分布在多个<code>shard</code>节点上，节点之间建立双向TCP链接用于有效性检测、<code>Failover</code>等，Client直接与<code>shard</code>节点进行通讯；<br>Cluster集群没有Proxy层，也没有中央式的Master用于协调集群状态或者state存储；<br>集群暂不提供动态reblance(再平衡)策略）</p>
<p>备注：下文中提到的query、查询等语义，泛指redis的读写操作。</p>
<h3 id="Mutli-key操作"><a href="#Mutli-key操作" class="headerlink" title="Mutli-key操作"></a>Mutli-key操作</h3><p>Redis单实例支持的命令，Cluster也都支持，但是对于“multi-key”操作（即一次RPC调用中需要进行多个key的操作）比如<code>Set</code>类型的交集、并集等，则要求这些key必须属于同一个node。Cluster不能进行跨Nodes操作，也没有nodes提供merge层代理。</p>
<p>Cluster中实现了一个称为“hash tags”的概念，每个key都可以包含一个自定义的“<code>tags</code>”，那么在存储时将根据tags计算此key应该分布在哪个nodes上（而不是使用key计算，但是存储层面仍然是key）；此特性，可以强制某些keys被保存在同一个节点上，以便于进行“multikey”操作，比如“<code>foo</code>”和“<code>{foo}.student</code>”将会被保存在同一个node上。不过在人工对slots进行resharding期间，multikey操作可能不可用。</p>
<p>我们在Redis单例中，偶尔会用到“SELECT”指令，即可以将key保存在特定的database中（默认database索引号为0）；但是在Cluster环境下，将不支持<code>SELECT</code>命令，所有的key都将保存在默认的database中。</p>
<h3 id="客户端与Server角色"><a href="#客户端与Server角色" class="headerlink" title="客户端与Server角色"></a>客户端与Server角色</h3><p>集群中nodes负责存储数据，保持集群的状态，包括keys与nodes的对应关系（内部其实为slots与nodes对应关系）。nodes也能够自动发现其他的nodes，检测失效的节点，当某个master失效时还应该能将合适的slave提升为master。</p>
<p>为了达成这些行为，集群中的每个节点都通过TCP与其他所有nodes建立连接，它们之间的通信协议和方式称为“Redis Cluster Bus”。Nodes之间使用gossip协议向其他nodes传播集群信息，以达到自动发现的特性，通过发送ping来确认其他nodes工作是否正常，也会在合适的时机发送集群的信息。当然在Failover时（包括人为failover）也会使用Bus来传播消息。<br>（gossip：最终一致性，分布式服务数据同步算法，node首先需要知道（可以读取配置）集群中至少一个seed node，此node向seed发送ping请求，此时seed节点pong返回自己已知的所有nodes列表，然后node解析nodes列表并与它们都建立tcp连接，同时也会向每个nodes发送ping，并从它们的pong结果中merge出全局nodes列表，并逐步与所有的nodes建立连接…….数据传输的方式也是类似，网络拓扑结构为full mesh）</p>
<p>因为Node并不提供Proxy机制，当Client将请求发给错误的nodes时（此node上不存在此key所属的slot），node将会反馈“MOVED”或者“ASK”错误信息，以便Client重新定向到合适的node。理论上，Client可以将请求发送给任意一个nodes，然后根据再根据错误信息转发给合适的node，客户端可以不用保存集群的状态信息，当然这种情况下性能比较低效，因为Client可能需要2次TCP调用才能获取key的结果，通常客户端会缓存集群中nodes与slots的映射关系，并在遇到“Redirected”错误反馈时，才会更新本地的缓存。</p>
<h3 id="安全写入（write-safety）"><a href="#安全写入（write-safety）" class="headerlink" title="安全写入（write safety）"></a>安全写入（write safety）</h3><p>在Master-slaves之间使用异步replication机制，在failover之后，新的Master将会最终替代其他的replicas（即slave）。在出现网络分区时（network partition），总会有一个窗口期（node timeout）可能会导致数据丢失；不过，Client与多数派的Master、少数派Master处于一个分区（网络分区，因为网络阻断问题，导致Clients与Nodes被隔离成2部分）时，这两种情况下影响并不相同。</p>
<p>1）write提交到master，master执行完毕后向Client反馈“OK”，不过此时可能数据还没有传播给slaves（异步replication）；如果此时master不可达的时间超过阀值（node timeout，参见配置参数），那么将触发slave被选举为新的Master（即Failover），这意味着那些没有replication到slaves的writes将永远丢失了！<br>2）还有一种情况导致数据丢失：<br>A）因为网络分区，此时master不可达，且Master与Client处于一个分区，且是少数派分区。<br>B）Failover机制，将其中一个slave提升为新Master。<br>C）此后网络分区消除，旧的Master再次可达，此时它将被切换成slave。<br>D）那么在网络分区期间，处于少数派分区的Client仍然将write提交到旧的Master，因为它们觉得Master仍然有效；当旧的Master再次加入集群，切换成slave之后，这些数据将永远丢失。</p>
<p>在第二种情况下，如果Master无法与其他大多数Masters通讯的时间超过阀值后，此Master也将不再接收Writes，自动切换为readonly状态。当网络分区消除后，仍然会有一小段时间，客户端的write请求被拒绝，因为此时旧的Master需要更新本地的集群状态、与其他节点建立连接、角色切换为slave等等，同时Client端的路由信息也需要更新。<br>只有当此master被大多数其他master不可达的时间达到阀值时，才会触发Failover，这个时间称为<code>NODE_TIMEOUT</code>，可以通过配置设定。所以当网络分区在此时间被消除的话，writes不会有任何丢失。反之，如果网络分区持续时间超过此值，处于“小分区”（minority）端的Master将会切换为<code>readonly</code>状态，拒绝客户端继续提交writes请求，那么“大分区”端将会进行<code>failover</code>，这意味着<code>NODE_TIMEOUT</code>期间发生在“小分区”端的writes操作将丢失（因为新的Master上没有同步到那些数据）。 </p>
<h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><p>处于“小分区”的集群节点是不可用的；“大分区”端必须持有大多数Masters，同时每个不可达的Master至少有一个slave也在“大分区”端，当<code>NODE_TIMEOUT</code>时，触发<code>failover</code>，此后集群才是可用的。Redis Cluster在小部分nodes失效后仍然可以恢复有效性，如果application希望大面积节点失效仍然有效，那么Cluster不适合这种情况。</p>
<p>比如集群有N个Master，且每个Master都有一个slave，那么集群的有效性只能容忍一个节点（master）被分区隔离（即一个master处于小分区端，其他处于大分区端），当第二个节点被分区隔离之前仍保持可用性的概率为1 - (1/(N <em> 2 - 1))（解释：当第一个节点失效后，剩余N </em> 2 -1个节点，此时没有slave的Master失效的概率为1/(N <em> 2 -1)）。比如有5个Master，每个Master有一个slave，当2个nodes被隔离出去（或者失效）后，集群可用性的概率只有1/(5 </em> 2 - 1) = 11.11%。<br>幸好Redis Cluster提供了“replicas migration”机制，在实际应用方面，可以有效的提高集群的可用性，当每次failover发生后，集群都会重新配置、平衡slaves的分布，以更好的抵御下一次失效情况的发生。</p>
<h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>Redis Cluster并没有提供Proxy层，而是告知客户端将key的请求转发给合适的nodes。Client保存集群中nodes与keys的映射关系（slots），并保持此数据的更新，所以通常Client总能够将请求直接发送到正确的nodes上。因为采用异步replication，所以master不会等待slaves也保存成功后才向客户端反馈结果，除非显式的指定了<code>WAIT</code>指令。multi-key指令仅限于单个节点内，除了resharding操作外，节点的数据不会在节点间迁移。每个操作只会在特定的一个节点上执行，所以集群的性能为master节点的线性扩展。同时，Clients与每个nodes保持链接，所以请求的延迟等同于单个节点，即请求的延迟并不会因为Cluster的规模增大而受到影响。高性能和扩展性，同时保持合理的数据安全性，是Redis Cluster的设计目标。</p>
<p>Redis Cluster没有Proxy层，Client请求的数据也无法在nodes间merge；因为Redis核心就是K-V数据存储，没有scan类型（<code>sort</code>，<code>limit</code>，<code>group by</code>）的操作，因此merge操作并不被Redis Cluster所接受，而且这种特性会极大增加了Cluster的设计复杂度。</p>
<h2 id="二、Cluster主要组件"><a href="#二、Cluster主要组件" class="headerlink" title="二、Cluster主要组件"></a>二、Cluster主要组件</h2><h3 id="keys分布模型"><a href="#keys分布模型" class="headerlink" title="keys分布模型"></a>keys分布模型</h3><p>集群将key分成16384个slots（hash 槽），slot是数据映射的单位，言外之意，Redis Cluster最多支持16384个nodes（每个nodes持有一个slot）。集群中的每个master持有16384个slots中的一部分，处于“stable”状态时，集群中没有任何slots在节点间迁移，即任意一个hash slot只会被单个node所服务（master，当然可以有多个slave用于replicas，slave也可以用来扩展read请求）。keys与slot的映射关系，是按照如下算法计算的：<code>HASH_SLOT = CRC16(key) mod 16384</code>。其中<code>CRC16</code>是一种冗余码校验和，可以将字符串转换成16位的数字。</p>
<h3 id="hash-tags"><a href="#hash-tags" class="headerlink" title="hash tags"></a>hash tags</h3><p>在计算hash slots时有一个意外的情况，用于支持“hash tags”；hash tags用于确保多个keys能够被分配在同一个hash slot中，用于支持multi-key操作。hash tags的实现比较简单，key中“<code>{}</code>”之间的字符串就是当前key的hash tags，如果存在多个“<code>{}</code>”，首个符合规则的字符串作为<code>hash tags</code>，如果“<code>{}</code>”存在多级嵌套，那么最内层首个完整的字符串作为<code>hash tags</code>，比如“<code>{foo}.student</code>”，那么“<code>foo</code>”是hash tags。如果key中存在合法的hash tags，那么在计算hash slots时，将使用hash tags，而不再使用原始的key。即“<code>foo</code>”与“<code>{foo}.student</code>”将得到相同的slot值，不过“<code>{foo}.student</code>”仍作为key来保存数据，即redis中数据的key仍为“<code>{foo}.student</code>”。</p>
<h3 id="集群节点的属性"><a href="#集群节点的属性" class="headerlink" title="集群节点的属性"></a>集群节点的属性</h3><p>集群中每个节点都有唯一的名字，称之为node ID，一个160位随机数字的16进制表示，在每个节点首次启动时创建。每个节点都将各自的ID保存在实例的配置文件中，此后将一直使用此ID，或者说只要配置文件不被删除，或者没有使用“CLUSTER RESET”指令重置集群，那么此ID将永不会修改。</p>
<p>集群通过node ID来标识节点，而不是使用IP + port，因为node可以修改它的IP和port，不过如果ID不变，我们仍然认定它是集群中合法一员。集群可以在cluster Bus中通过gossip协议来探测IP、port的变更，并重新配置。</p>
<p>node ID并不是与node相关的唯一信息，不过是唯一一个全局一致的。每个node还持有如下相关的信息，有些信息是关系集群配置的，其他的信息比如最后ping时间等。每个node也保存其他节点的IP、Port、flags（比如flags表示它是master还是slave）、最近ping的时间、最近pong接收时间、当前配置的epoch、链接的状态，最重要的是还包含此node上持有的hash slots。这些信息均可通过“CLUSTER NODES”指令开查看。</p>
<h3 id="Cluster-Bus"><a href="#Cluster-Bus" class="headerlink" title="Cluster Bus"></a>Cluster Bus</h3><p>每个Node都有一个特定的TCP端口，用来接收其他nodes的链接；此端口号为面向Client的端口号+10000，比如客户端端口号为<code>6379</code>，那么此node的BUS端口号为<code>16379</code>，客户端端口号可以在配置文件中声明。由此可见，nodes之间的交互通讯是通过Bus端口进行，使用了特定的二进制协议，此端口通常应该只对nodes可用，可以借助防火墙技术来屏蔽其他非法访问。</p>
<h3 id="集群拓扑"><a href="#集群拓扑" class="headerlink" title="集群拓扑"></a>集群拓扑</h3><p>Redis Cluster中每个node都与其他nodes的Bus端口建立TCP链接（full mesh，全网）。比如在由N个节点组成的集群中，每个node有N-1个向外发出的TCP链接，以及N-1个其他nodes发过来的TCP链接；这些TCP链接总是keepalive，不是按需创建的。如果ping发出之后，node在足够长的时间内仍然没有pong响应，那么此node将会被标记为“不可达”，那么与此node的链接将会被刷新或者重建。Nodes之间通过gossip协议和配置更新的机制，来避免每次都交互大量的消息，最终确保在nodes之间的信息传送量是可控的。</p>
<h3 id="节点间handshake"><a href="#节点间handshake" class="headerlink" title="节点间handshake"></a>节点间handshake</h3><p>Nodes通过Bus端口发送ping、pong；如果一个节点不属于集群，那么它的消息将会被其他nodes全部丢弃。一个节点被认为是集群成员的方式有2种：<br>1）如果此node在“Cluster meet”指令中引入，此命令的主要意义就是将指定node加入集群。那么对于当前节点，将认为指定的node为“可信任的”。（此后将会通过gossip协议传播给其他nodes）<br>2）当其他nodes通过gossip引入了新的nodes，这些nodes也是被认为是“可信任的”。</p>
<p>只要我们将一个节点加入集群，最终此节点将会与其他节点建立链接，即cluster可以通过信息交换来自动发现新的节点，链接拓扑仍然是full mesh。</p>
<h2 id="三、重定向与resharding"><a href="#三、重定向与resharding" class="headerlink" title="三、重定向与resharding"></a>三、重定向与resharding</h2><h3 id="MOVED重定向"><a href="#MOVED重定向" class="headerlink" title="MOVED重定向"></a>MOVED重定向</h3><p>理论上，Client可以将请求随意发给任何一个node，包括slaves，此node解析query，如果可以执行（比如语法正确，multiple keys都应该在一个node slots上），它会查看key应该属于哪个slot、以及此slot所在的nodes，如果当前node持有此slot，那么query直接执行即可，否则当前node将会向Client反馈“MOVED”错误：</p>
<pre><code>GET X  
-MOVED 3999 127.0.0.1:6381  
</code></pre><p>错误信息中包括此<code>key</code>对应的slot（3999），以及此slot所在node的ip和port，对于Client 而言，收到<code>MOVED</code>信息后，它需要将请求重新发给指定的node。不过，当node向Client返回<code>MOVED</code>之前，集群的配置也在变更（节点调整、resharding、failover等，可能会导致slot的位置发生变更），此时Client可能需要等待更长的时间，不过最终node会反馈<code>MOVED</code>信息，且信息中包含指定的新的node位置。虽然Cluster使用ID标识node，但是在<code>MOVED</code>信息中尽可能地暴露给客户端便于使用的ip + port。</p>
<p>当Client遇到“<code>MOVED</code>”错误时，将会使用“<code>CLUSTER NODES</code>”或者“<code>CLUSTER SLOTS</code>”指令获取集群的最新信息，主要是nodes与slots的映射关系；因为遇到<code>MOVED</code>，一般也不会仅仅一个slot发生的变更，通常是一个或者多个节点的slots发生了变化，所以进行一次全局刷新是有必要的；我们还应该明白，Client将会把集群的这些信息在被缓存，以便提高query的性能。</p>
<p>还有一个错误信息：“<code>ASK</code>”，它与“<code>MOVED</code>”都属于重定向错误，客户端的处理机制基本相同，只是<code>ASK</code>不会触发Client刷新本地的集群信息。</p>
<h3 id="集群运行时重新配置（live-reconfiguration）"><a href="#集群运行时重新配置（live-reconfiguration）" class="headerlink" title="集群运行时重新配置（live reconfiguration）"></a>集群运行时重新配置（live reconfiguration）</h3><p>我们可以在Cluster运行时增加、删除nodes，这两种操作都会导致：slots在nodes的迁移；当然这种机制也可用来集群数据的rebalance等等。</p>
<p>1）集群中新增一个node，我们需要将其他nodes上的部分slots迁移到此新nodes上，以实现数据负载的均衡分配。<br>2）集群中移除一个node，那么在移除节点之前，必须将此节点上（如果此节点没有任何<code>slaves</code>）的slots迁移到其他nodes。<br>3）如果数据负载不均衡，比如某些slots数据集较大、负载较大时，我们需要它们迁移到负载较小的nodes上（即手动resharding），以实现集群的负载平衡。</p>
<p>Cluster支持slots在nodes间移动；从实际的角度来看，一个slot只是一序列keys的逻辑标识，所以Cluster中slot的迁移，其实就是一序列keys的迁移，不过resharding操作只能以slot为单位（而不能仅仅迁移某些keys）。Redis提供了如下几个操作：</p>
<p>1）<code>CLUSTER ADDSLOTS [slot]</code> ….<br>2）<code>CLUSTER DELSLOTS [slot]</code> …<br>3）<code>CLUSTER SETSLOT [slot] NODE [node]</code><br>4）<code>CLUSTER SETSLOT [slot] MIGRATING [destination-node]</code><br>5）<code>CLUSTER SETSLOT [slot] IMPORTING [source-node]</code></p>
<p>前两个指令：<code>ADDSLOTS</code>和<code>DELSLOTS</code>，用于向当前node分配或者移除slots，指令可以接受多个slot值。分配slots的意思是告知指定的master（即此指令需要在某个master节点执行）此后由它接管相应slots的服务；slots分配后，这些信息将会通过gossip发给集群的其他nodes。<br><code>ADDSLOTS</code>指令通常在创建一个新的Cluster时使用，一个新的Cluster有多个空的Masters构成，此后管理员需要手动为每个master分配slots，并将16384个slots分配完毕，集群才能正常服务。简而言之，<code>ADDSLOTS</code>只能操作那些尚未分配的（即不被任何nodes持有）slots，我们通常在创建新的集群或者修复一个broken的集群（集群中某些slots因为nodes的永久失效而丢失）时使用。为了避免出错，Redis Cluster提供了一个redis-trib辅助工具，方便我们做这些事情。</p>
<p><code>DELSLOTS</code>就是将指定的slots删除，前提是这些slots必须在当前node上，被删除的slots处于“未分配”状态（当然其对应的keys数据也被clear），即尚未被任何nodes覆盖，这种情况可能导致集群处于不可用状态，此指令通常用于debug，在实际环境中很少使用。那些被删除的slots，可以通过<code>ADDSLOTS</code>重新分配。</p>
<p><code>SETSLOT</code>是个很重要的指令，对集群slots进行reshard的最重要手段；它用来将单个slot在两个nodes间迁移。根据slot的操作方式，它有两种状态“<code>MIGRATING</code>”、“<code>IMPORTING</code>”（或者说迁移的方式）<br>1）<code>MIGRATING</code>：将slot的状态设置为“<code>MIGRATING</code>”，并迁移到destination-node上，需要注意当前node必须是slot的持有者。在迁移期间，Client的查询操作仍在当前node上执行，如果key不存在，则会向Client反馈“-<code>ASK</code>”重定向信息，此后Client将会把请求重新提交给迁移的目标node。<br>2）<code>IMPORTING</code>：将slot的状态设置为“IMPORTING”，并将其从source-node迁移到当前node上，前提是source-node必须是slot的持有者。Client交互机制同上。</p>
<p>假如我们有两个节点A、B，其中slot 8在A上，我们希望将8从A迁移到B，可以使用如下方式：<br>1）在B上：<code>CLUSTER SETSLOT 8 IMPORTING A</code><br>2）在A上：<code>CLUSTER SETSLOT 8 MIGRATING B</code><br>在迁移期间，集群中其他的nodes的集群信息不会改变，即slot 8仍对应A，即此期间，Client查询仍在A上：<br>1）如果key在A上存在，则由A执行。<br>2）否则，将向客户端返回ASK，客户端将请求重定向到B。<br>这种方式下，新key的创建就不会在A上执行，而是在B上执行，这也就是ASK重定向的原因（迁移之前的keys在A，迁移期间created的keys在B上）；当上述<code>SETSLOT</code>执行完毕后，slot的状态也会被自动清除，同时将slot迁移信息传播给其他nodes，至此集群中slot的映射关系将会变更，此后slot 8的数据请求将会直接提交到B上。</p>
<h3 id="ASK重定向"><a href="#ASK重定向" class="headerlink" title="ASK重定向"></a>ASK重定向</h3><p>在上文中，我们已经介绍了<code>MOVED</code>重定向，<code>ASK</code>与其非常相似。在resharding期间，为什么不能用<code>MOVED</code>？MOVED意思为hash slots已经永久被另一个node接管、接下来的相应的查询应该与它交互，<code>ASK</code>的意思是当前query暂时与指定的node交互；在迁移期间，slot 8的keys有可能仍在A上，所以Client的请求仍然需要首先经由A，对于A上不存在的，我们才需要到B上进行尝试。迁移期间，Redis Cluster并没有粗暴的将slot 8的请求全部阻塞、直到迁移结束，这种方式尽管不再需要<code>ASK</code>，但是会影响集群的可用性。<br>1）当Client接收到<code>ASK</code>重定向，它仅仅将当前query重定向到指定的node；此后的请求仍然交付给旧的节点。<br>2）客户端并不会更新本地的slots映射，仍然保持slot 8与A的映射；直到集群迁移完毕，且遇到<code>MOVED</code>重定向。</p>
<p>一旦slot 8迁移完毕之后（集群的映射信息也已更新），如果Client再次在A上访问slot 8时，将会得到<code>MOVED</code>重定向信息，此后客户端也更新本地的集群映射信息。</p>
<h3 id="客户端首次链接以及重定向处理"><a href="#客户端首次链接以及重定向处理" class="headerlink" title="客户端首次链接以及重定向处理"></a>客户端首次链接以及重定向处理</h3><p>可能有些Cluster客户端的实现，不会在内存中保存slots映射关系（即nodes与slots的关系），每次请求都从声明的、已知的nodes中，随机访问一个node，并根据重定向（<code>MOVED</code>）信息来寻找合适的node，这种访问模式，通常是非常低效的。<br>当然，Client应该尽可能的将slots配置信息缓存在本地，不过配置信息也不需要绝对的实时更新，因为在请求时偶尔出现“重定向”，Client也能兼容此次请求的正确转发，此时再更新slots配置。（所以Client通常不需要间歇性的检测Cluster中配置信息是否已经更新）客户端通常是全量更新slots配置：<br>1）首次链接到集群的某个节点<br>2）当遇到<code>MOVED</code>重定向消息时<br>遇到<code>MOVED</code>时，客户端仅仅更新特定的slot是不够的，因为集群中的reshard通常会影响到多个slots。客户端通过向任意一个nodes发送“<code>CLUSTER NODES</code>”或者“<code>CLUSTER SLOTS</code>”指令均可以获得当前集群最新的slots映射信息；“<code>CLUSTER SLOTS</code>”指令返回的信息更易于Client解析。如果集群处于broken状态，即某些slots尚未被任何nodes覆盖，指令返回的结果可能是不完整的。</p>
<h3 id="Multikeys操作"><a href="#Multikeys操作" class="headerlink" title="Multikeys操作"></a>Multikeys操作</h3><p>前文已经介绍，基于hash tags机制，我们可以在集群中使用<code>Multikeys</code>操作。不过，在resharding期间，Multikeys操作将可能不可用，比如这些keys不存在于同一个slot（迁移会导致keys被分离）；比如<code>Multikeys</code>逻辑上属于同一个slot，但是因为resharding，它们可能暂时不处于同一个nodes，有些可能在迁移的目标节点上（比如<code>Multikeys</code>包含a、b、c三个keys，逻辑上它们都属于slot 8，但是其中c在迁移期间创建，它被存储在节点B上，a、b仍然在节点A），此时将会向客户端返回“<code>-TRYAGAIN</code>”错误，那么客户端此后将需要重试一次，或者直接返回错误（如果迁移操作被中断），无论如何最终<code>Multikeys</code>的访问逻辑是一致的，slots的状态也是最终确定的。</p>
<h3 id="slaves扩展reads请求"><a href="#slaves扩展reads请求" class="headerlink" title="slaves扩展reads请求"></a>slaves扩展reads请求</h3><p>通常情况下，read、write请求都将有持有slots的master节点处理；因为redis的slaves可以支持read操作（前提是application能够容忍stale数据），所以客户端可以使用“<code>READONLY</code>”指令来扩展read请求。<br>“<code>READONLY</code>”表明其可以访问集群的slaves节点，能够容忍stale数据，而且此次链接不会执行writes操作。当链接设定为<code>readonly</code>模式后，Cluster只有当keys不被slave的master节点持有时才会发送重定向消息（即Client的read请求总是发给slave，只有当此slave的master不持有slots时才会重定向，很好理解）：<br>1）此slave的master节点不持有相应的slots<br>2）集群重新配置，比如reshard或者slave迁移到了其他master上，此slave本身也不持有此slot。</p>
<p>此时Client更新本地的slot配置信息，同上文所述。（目前很多Client实现均基于连接池，所以不能非常便捷的设置<code>READLONLY</code>选项，非常遗憾）</p>
<h2 id="四、容错（Fault-Tolerance）"><a href="#四、容错（Fault-Tolerance）" class="headerlink" title="四、容错（Fault Tolerance）"></a>四、容错（Fault Tolerance）</h2><h3 id="心跳与gossip消息"><a href="#心跳与gossip消息" class="headerlink" title="心跳与gossip消息"></a>心跳与gossip消息</h3><p>集群中的nodes持续的交换ping、pong数据，这两种数据包的结构一样，同样都能携带集群的配置信息，唯一不同的就是<code>message</code>中的<code>type</code>字段。<br>通常，一个node发送ping消息，那么接收者将会反馈pong消息；不过有时候并非如此，或许接收者将pong信息发给其他的nodes，而不是直接反馈给发送者，比如当集群中添加新的node时。<br>通常一个node每秒都会随机向几个nodes发送ping，所以无论集群规模多大，每个nodes发送的ping数据包的总量是恒定的。每个node都确保尽可能的向那些在半个NODE_TIMEOUT时间内，尚未发送过ping或者接收到它们的pong消息的nodes发送ping。在NODE_TIMEOUT逾期之前，nodes也会尝试与那些通讯异常的nodes重新建立TCP链接，确保不能仅仅因为当前链接异常而认为它们就是不可达的。</p>
<p>当NODE_TIMEOUT值较小、集群中nodes规模较大时，那么全局交换的信息量也会非常庞大，因为每个node都尽力在半个NODE_TIMEOUT时间内，向其他nodes发送ping。比如有100个nodes，<code>NODE_TIMEOUT</code>为60秒，那么每个node在30秒内向其他99各nodes发送ping，平均每秒3.3个消息，那么整个集群全局就是每秒330个消息。这些消息量，并不会对集群的带宽带来不良问题。</p>
<h3 id="心跳数据包的内容"><a href="#心跳数据包的内容" class="headerlink" title="心跳数据包的内容"></a>心跳数据包的内容</h3><p>1）node ID<br>2）currentEpoch和configEpoch<br>3）node flags：比如表示此node是maste、slave等<br>4）hash slots：发送者持有的slots<br>5）如果发送者是slave，那么其master的ID<br>6）其他..</p>
<p>ping和pong数据包中也包含gossip部分，这部分信息包含sender持有的集群视图，不过它只包含sender已知的随机几个nodes，nodes的数量根据集群规模的大小按比例计算。gossip部分包含了nodes的ID、ip+port、flags，那么接收者将根据sender的视图，来判定节点的状态，这对故障检测、节点自动发现非常有用。</p>
<h3 id="失效检测"><a href="#失效检测" class="headerlink" title="失效检测"></a>失效检测</h3><p>集群失效检测就是，当某个master或者slave不能被大多数nodes可达时，用于故障迁移并将合适的<code>slave</code>提升为master。当slave提升未能有效实施时，集群将处于error状态且停止接收Client端查询。<br>如上所述，每个node有持有其已知nodes的列表包括flags，有2个flag状态：PFAIL和FAIL；PFAIL表示“可能失效”，是一种尚未完全确认的失效状态（即某个节点或者少数masters认为其不可达）。FAIL表示此node已经被集群大多数masters判定为失效（大多数master已认定为不可达，且不可达时间已达到设定值，需要failover）。</p>
<h3 id="PFAIL："><a href="#PFAIL：" class="headerlink" title="PFAIL："></a>PFAIL：</h3><p>一个被标记为PFAIL的节点，表示此node不可达的时间超过NODE_TIMEOUT，master和slave有可以被标记为PFAIL。所谓不可达，就是当“active ping”（发送ping且能受到pong）尚未成功的时间超过<code>NODE_TIMEOUT</code>，因此我们设定的NODE_TIMEOUT的值应该比网络交互往返的时间延迟要大一些（通常要大的多，以至于交互往返时间可以忽略）。为了避免误判，当一个node在半个NODE_TIMEOUT时间内仍未能pong，那么当前node将会尽力尝试重新建立连接进行重试，以排除pong未能接收是因为当前链接故障的问题。</p>
<h3 id="FAIL："><a href="#FAIL：" class="headerlink" title="FAIL："></a>FAIL：</h3><p>PFAIL只是当前node有关于其他nodes的本地视图，可能每个node对其他nodes的本地视图都不一样，所以PFAIL还不足以触发Failover。处于PFAIL状态下的node可以被提升到FAIL状态。如上所述，每个node在向其他nodes发送gossip消息时，都会包含本地视图中几个随机nodes的状态信息；每个node最终都会从其他nodes发送的消息中获得一组nodes的flags。因此，每个node都可以通过这种机制来通知其他nodes，它检测到的故障情况。</p>
<h3 id="PFAIL被上升为FAIL的集中情况："><a href="#PFAIL被上升为FAIL的集中情况：" class="headerlink" title="PFAIL被上升为FAIL的集中情况："></a>PFAIL被上升为FAIL的集中情况：</h3><p>1）比如A节点，认为B为PFAIL<br>2）那么A通过gossip信息，收集集群中大多数masters关于B的状态视图。<br>3）多数master都认为B为PFAIL，或者PFAIL情况持续时间为NODE_TIMEOUT * FAIL_REPORT_VALIDITY_MULT（此值当前为2）</p>
<p>如果上述条件成立，那么A将会：<br>1）将B节点设定为FAIL<br>2）将FAIL信息发送给其所有能到达的所有节点。</p>
<p>每个接收到FAIL消息的节点都会强制将此node标记为FAIL状态，不管此节点在本地视图中是否为PFAIL。FAIL状态是单向的，即PFAIL可以转换为FAIL，但是FAIL状态只能清除，不能回转为PFAIL：</p>
<p>1）当此node已经变的可达，且为slave，这种情况下FAIL状态将会被清除，因为没有发生failover。<br>2）此node已经可达，且是一个没有服务任何slots的master（空的master）；这种情况下，FAIL将会被清除，因为master没有持有slots，所以它并没有真正参与到集群中，需要等到重新配置以便它加入集群。<br>3）此node已经可达，且是master，且在较长时间内（N倍的NODE_TIMEOUT）没有检测到slave的提升，即没有slave发生failover（比如此master下没有slave），那么它只能重新加入集群且仍为master。</p>
<p>需要注意的是PFAIL-&gt;FAIL的转变，使用了“协议”（agreement）的形式：<br>1）nodes会间歇性的收集其他nodes的视图，即使大多数masters都“agree”，事实上这个状态，仅仅是我们从不同的nodes、不同的时间收集到的，我们无法确认（也不需要）在特定时刻大多数masters是否“agree”。我们丢弃较旧的故障报告，所以此故障（FAIL）是有大多数masters在一段时间内的信号。<br>2）虽然每个node在检测到FAIL情况时，都会通过FAIL消息发送给其他nodes，但是无法保证消息一定会到达所有的nodes，比如可能当前节点（发送消息的node）因为网络分区与其他部分nodes隔离了。</p>
<p>如果只有少数master认为某个node为FAIL，并不会触发相应的slave提升，即failover，因为可能是因为网络分区导致。FAIL标记只是用来触发slave 提升；在原理上，当master不可达时将会触发slave提升，不过当master仍然被大多数可达时，它会拒绝提供相应的确认。</p>
<h2 id="五、Failover相关的配置"><a href="#五、Failover相关的配置" class="headerlink" title="五、Failover相关的配置"></a>五、Failover相关的配置</h2><h3 id="集群currentEpoch"><a href="#集群currentEpoch" class="headerlink" title="集群currentEpoch"></a>集群currentEpoch</h3><p>Redis Cluster使用了类似于Raft算法“term”（任期）的概念，那么在redis Cluster中term称为epoch，用来给events增量版本号。当多个nodes提供了信息有冲突时，它可以作为node来知道哪个状态是最新的。currentEpoch为一个64位无签名数字。<br>在集群node创建时，master和slave都会将各自的currentEpoch设置为0，每次从其他node接收到数据包时，如果发现发送者的epoch值比自己的大，那么当前node将自己的currentEpoch设置为发送者的epoch。由此，最终所有的nodes都会认同集群中最大的epoch值；当集群的状态变更，或者node为了执行某个行为需求agreement时，都将需要epoch（传递或者比较）。</p>
<p>当前来说，只有在slave提升期间发生；currentEpoch为集群的逻辑时钟（logical clock），指使持有较大值的获胜。（currentEpoch，当前集群已达成认同的epoch值，通常所有的nodes应该一样）</p>
<h3 id="configEpoch"><a href="#configEpoch" class="headerlink" title="configEpoch"></a>configEpoch</h3><p>每个master总会在ping、pong数据包中携带自己的configEpoch以及它持有的slots列表。新创建的node，其configEpoch为0，slaves通过递增它们的configEpoch来替代失效的master，并尝试获得其他大多数master的授权（认同）。当slave被授权，一个新的configEpoch被生成，slave提升为master且使用此configEpoch。<br>接下来介绍configEpoch帮助解决冲突，当不同的nodes宣称有分歧的配置时。<br>slaves在ping、pong数据包中也会携带自己的configEpoch信息，不过这个epoch为它与master在最近一次数据交换时，master的configEpoch。<br>每当节点发现configEpoch值变更时，都会将新值写入nodes.conf文件，当然currentEpoch也也是如此。这两个变量在写入文件后会伴随磁盘的fsync，持久写入。严格来说，集群中所有的master都持有唯一的configEpoch值。同一组master-slaves持有相同的configEpoch。</p>
<h3 id="slave选举与提升"><a href="#slave选举与提升" class="headerlink" title="slave选举与提升"></a>slave选举与提升</h3><p>在slaves节点中进行选举，在其他masters的帮助下进行投票，选举出一个slave并提升为master。当master处于FAIL状态时，将会触发slave的选举。slaves都希望将自己提升为master，此master的所有slaves都可以开启选举，不过最终只有一个slave获胜。当如下情况满足时，slave将会开始选举：<br>1）当此slave的master处于FAIL状态<br>2）此master持有非零个slots<br>3）此slave的replication链接与master断开时间没有超过设定值，为了确保此被提升的slave的数据是新鲜的，这个时间用户可以配置。</p>
<p>为了选举，第一步，就是slave自增它的currentEpoch值，然后向其他masters请求投票（需求支持，votes）。slave通过向其他masters传播“FAILOVER_AUTH_REQUEST”数据包，然后最长等待2倍的NODE_TIMEOUT时间，来接收反馈。一旦一个master向此slave投票，将会响应“FAILOVER_AUTH_ACK”，此后在2 <em> NODE_TIMOUT时间内，它将不会向同一个master的slaves投票；虽然这对保证安全上没有必要，但是对避免多个slaves同时选举时有帮助的。slave将会丢弃那些epoch值小于自己的currentEpoch的AUTH_ACK反馈，即不会对上一次选举的投票计数（只对当前轮次的投票计数）。一旦此slave获取了大多数master的ACKs，它将在此次选举中获胜；否则如果大多数master不可达（在2 </em> NODE_TIMEOUT）或者投票额不足，那么它的选举将会被中断，那么其他的slave将会继续尝试。</p>
<h3 id="slave-rank（次序）"><a href="#slave-rank（次序）" class="headerlink" title="slave rank（次序）"></a>slave rank（次序）</h3><p>当master处于FAIL状态时，slave将会随机等待一段时间，然后才尝试选举，等待的时间：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</div></pre></td></tr></table></figure></p>
<p>一定的延迟确保我们等待FAIL状态在集群中传播，否则slave立即尝试选举（不进行等待的话），不过此时其他masters或许尚未意识到FAIL状态，可能会拒绝投票。</p>
<p>延迟的时间是随机的，这用来“去同步”（desynchronize），避免slaves同时开始选举。SLAVE_RANK表示此slave已经从master复制数据的总量的rank。当master失效时，slaves之间交换消息以尽可能的构建rank，持有replication offset最新的rank为0，第二最新的为1，依次轮推。这种方式下，持有最新数据的slave将会首先发起选举（理论上）。当然rank顺序也不是严格执行的，如果一个持有较小rank的slave选举失败，其他slaves将会稍后继续。</p>
<p>一旦，slave选举成功，它将获取一个新的、唯一的、自增的configEpoch值，此值比集群中任何masters持有的都要大，它开始宣称自己是master，并通过ping、pong数据包传播，并提供自己的新的configEpoch以及持有的slots列表。为了加快其他nodes的重新配置，pong数据包将会在集群中广播。当前node不可达的那些节点，它们可以从其他节点的ping或者pong中获知信息（gossip），并重新配置。</p>
<p>其他节点也会检测到这个新的master和旧master持有相同的slots，且持有更高的configEpoch，此时也会更新自己的配置（epoch，以及master）；旧master的slaves不仅仅更新配置信息，也会重新配置并与新的master跟进（slave of）。</p>
<h3 id="Masters响应slave的投票请求"><a href="#Masters响应slave的投票请求" class="headerlink" title="Masters响应slave的投票请求"></a>Masters响应slave的投票请求</h3><p>当Master接收到slave的“FAILOVER_AUTH_REQUEST”请求后，开始投票，不过需要满足如下条件：<br>1）此master只会对指定的epoch投票一次，并且拒绝对旧的epoch投票：每个master都持有一个lastVoteEpoch，将会拒绝AUTH_REQUEST中currentEpoch比lastVoteEpoch小的请求。当master响应投票时，将会把lastVoteEpoch保存在磁盘中。<br>2）此slave的master处于FAIL状态时，master才会投票。<br>3）如果slave的currentEpoch比此master的currentEpoch小，那么AUTH_REQUEST将会被忽略。因为master只会响应那些与自己的currentEpoch相等的请求。如果同一个slave再此请求投票，持有已经增加的currentEpoch，它（slave）将保证旧的投票响应不能参与计票。</p>
<p>比如master的currentEpoch为5，lastVoteEpoch为1：<br>1）slave的currentEpoch为3<br>2）slave在选举开始时，使用epoch为4（先自增），因为小于master的epoch，所以投票响应被延缓。<br>3）slave在一段时间后将重新选举，使用epoch为5（4 + 1，再次自增），此时master上延缓的响应发给slave，接收后视为有效。</p>
<p>1）master在2 * NODE_TIMEOUT超时之前，不会对同一个master的slave再次投票。这并不是严格需要，因为也不太可能两个slave在相同的epoch下同时赢得选举。不过，它确保当一个slave选举成功后，它（slave）有一段缓冲时间来通知其他的slaves，避免另一个slave赢得了新的一轮的选择，避免不必要的二次failover。<br>2）master并不会尽力选举最合适的slave。当slave的master处于FAIL状态，此master在当前任期（term）内并不投票，只是批准主动投票者（即master不发起选举，只批准别人的投票）。最合适的slave应该在其他slaves之前，首先发起选举。<br>3）当master拒绝一个slave投票，并不会发出一个“否决”响应，而是简单的忽略。<br>4）slave发送的configEpoch是其master的，还包括其master持有的slots；master不会向持有相同slots、但configEpoch只较低的slave投票。</p>
<h3 id="Hash-Slots配置传播"><a href="#Hash-Slots配置传播" class="headerlink" title="Hash Slots配置传播"></a>Hash Slots配置传播</h3><p>Redis Cluster中重要的一部分就是传播集群中哪些节点上持有的哪些hash slots信息；无论是启动一个新的集群，还是当master失效其slave提升后更新配置，这对它们都至关重要。有2种方式用于hash slot配置的传播：<br>1）heartbeat 消息：发送者的ping、pong消息中，总是携带自己目前持有的slots信息，不管自己是master还是slave。<br>2）UPDATE 消息：因为每个心跳消息中会包含发送者的configEpoch和其持有的slots，如果接收者发现发送者的信息已经stale（比如发送者的configEpoch值小于持有相同slots的master的值），它会向发送者反馈新的配置信息（UPDATE），强制stale节点更新它。</p>
<p>当一个新的节点加入集群，其本地的hash slots映射表将初始为NULL，即每个hash slot都没有与任何节点绑定。<br>Rule 1：如果此node本地视图中一个hash slot尚未分配（设置为NULL），并且有一个已知的node声明持有它，那么此node将会修改本地hash slot的映射表，将此slot与那个node关联。slave的failover操作、reshard操作都会导致hash slots映射的变更，新的配置信息将会通过心跳在集群中传播。<br>Rule 2：如果此node的本地视图中一个hash slot已经分配，并且一个已知的node也声明持有它，且此node的configEpoch比当前slot关联的master的configEpoch值更大，那么此node将会把slot重新绑定到新的node上。根据此规则，最终集群中所有的nodes都赞同那个持有声明持有slot、且configEpoch最大值的nodes为slot的持有者。</p>
<h3 id="nodes如何重新加入集群"><a href="#nodes如何重新加入集群" class="headerlink" title="nodes如何重新加入集群"></a>nodes如何重新加入集群</h3><p>node A被告知slot 1、2现在由node B接管，假如这两个slots目前由A持有，且A只持有这两个slots，那么此后A将放弃这2个slots，成为空的节点；此后A将会被重新配置，成为其他新master的slave。这个规则可能有些复杂，A离群一段时间后重新加入集群，此时A发现此前自己持有的slots已经被其他多个nodes接管，比如slot 1被B接管，slot 2被C接管。<br>在重新配置时，最终此节点上的slots将会被清空，那个窃取自己最后一个slot的node，将成为它的新master。<br>节点重新加入集群，通常发生在failover之后，旧的master（也可以为slave）离群，然后重新加入集群。</p>
<h3 id="Replica迁移"><a href="#Replica迁移" class="headerlink" title="Replica迁移"></a>Replica迁移</h3><p>Redis Cluster实现了一个成为“Replica migration”的概念，用来提升集群的可用性。比如集群中每个master都有一个slave，当集群中有一个master或者slave失效时，而不是master与它的slave同时失效，集群仍然可以继续提供服务。<br>1）master A，有一个slave A1<br>2）master A失效，A1被提升为master<br>3）一段时间后，A1也失效了，那么此时集群中没有其他的slave可以接管服务，集群将不能继续服务。</p>
<p>如果masters与slaves之间的映射关系是固定的（fixed），提高集群抗灾能力的唯一方式，就是给每个master增加更多的slaves，不过这种方式开支很大，需要更多的redis实例。<br>解决这个问题的方案，我们可以将集群非对称，且在运行时可以动态调整master-slaves的布局（而不是固定master-slaves的映射），比如集群中有三个master A、B、C，它们对应的slave为A1、B1、C1、C2，即C节点有2个slaves。“Replica迁移”可以自动的重新配置slave，将其迁移到某个没有slave的master下。<br>1）A失效，A1被提升为master<br>2）此时A1没有任何slave，但是C仍然有2个slave，此时C2被迁移到A1下，成为A1的slave<br>3）此后某刻，A1失效，那么C2将被提升为master。集群可以继续提供服务。</p>
<h3 id="Replica迁移算法"><a href="#Replica迁移算法" class="headerlink" title="Replica迁移算法"></a>Replica迁移算法</h3><p>迁移算法并没有使用“agree”形式，而是使用一种算法来避免大规模迁移，这个算法确保最终每个master至少有一个slave即可。起初，我们先定义哪个slave是良好的：一个良好的slave不能处于FAIL状态。触发时机为，任何一个slave检测到某个master没有一个良好slave时。参与迁移的slave必须为，持有最多slaves的master的其中一个slave，且不处于FAIL状态，且持有最小的node ID。<br>比如有10个masters都持有一个slave，有2个masters各持有5个slaves，那么迁移将会发生在持有5个slaves的masters中，且node ID最小的slave node上。我们不再使用“agreement”，不过也有可能当集群的配置不够稳定时，有一种竞争情况的发生，即多个slaves都认为它们自己的ID最小；如果这种情况发生，结果就是可能多个slaves会迁移到同一个master下，不过这并没有什么害处，但是最坏的结果是导致原来的master迁出了所有的slaves，让自己变得单一。但是迁移算法（进程）会在迁移完毕之后重新判断，如果尚未平衡，那么将会重新迁移。<br>最终，每个master最少持有一个slave；这个算法由用户配置的“cluster-migration-barrier”，此配置参数表示一个master至少保留多少个slaves，其他多余的slaves可以被迁出。此值通常为1，如果设置为2，表示一个master持有的slaves个数大于2时，多余的slaves才可以迁移到持有更少slaves的master下。</p>
<h3 id="configEpoch冲突解决算法"><a href="#configEpoch冲突解决算法" class="headerlink" title="configEpoch冲突解决算法"></a>configEpoch冲突解决算法</h3><p>在slave failover期间，会生成新的configEpoch值，需要保证唯一性。不过有2种不同的event会导致configEpoch的创建是不安全的：仅仅自增本地的currentEpoch并希望它不会发生冲突。这两个事件有系统管理员触发：<br>1）CLUSTER FAILOVER：这个指令，就是人为的将某个slave提升为master，而不需要要求大多数masters的投票参与。<br>2）slots的迁移，用于平衡集群的数据分布（reshard）；此时本地的configEpoch也会修改，因为性能的考虑，这个过程也不需要“agreement”。</p>
<p>在手动reshard期间，当一个hash slot从A迁移到B，resharding程序将强制B更新自己的配置信息、epoch值也修改为集群的最大值 + 1（除非B的configEpoch已经是最大值），这种变更则不需要其他nodes的agreement（注意与failover的原理不同）。通常每次resharding都会迁移多个slots，且有多个nodes参与，如果每个slots迁移都需要agreement，才能生成新的epoch，这种性能是很差的，也不可取。我们在首个slots迁移开始时，只会生成一个新的configEpoch，在迁移完毕后，将新的配置传播给集群即可，这种方式在生产环境中更加高效。</p>
<p>因为上述两个情况，有可能（虽然概率极小）最终多个nodes产生了相同的configEpoch；比如管理员正在进行resharding，但是此时failover发生了…无论是failover还是resharding都是将currentEpoch自增，而且resharding不使用agreement形式（即其他nodes或许不知道，而且网络传播可能延迟），这就会发生epoch值的冲突问题。</p>
<p>当持有不同slots的masters持有相同的configEpoch，这并不会有什么问题。比较遗憾的是，人工干预或者resharding会以不同的方式修改了集群的配置，Cluster要求所有的slots都应该被nodes覆盖，所以在任何情况下，我们都希望所有的master都持有不同的configEpoch。避免冲突的算法，就是用来解决当2个nodes持有相同的configEpoch：<br>1）如果一个master节点发现其他master持有相同的configEpoch。<br>2）并且此master逻辑上持有较小的node ID（字典顺序）<br>3）然后此master将自己的currentEpoch加1，并作为自己新的configEpoch。</p>
<p>如果有多个nodes持有相同的congfigEpoch，那么除了持有最大ID的节点外，其他的nodes都将往前推进（+1，直到冲突解决），最终保证每个master都持有唯一的configEpoch（slave的configEpoch与master一样）。对于新创建的cluster也是同理，所有的nodes都初始为不同的configEpoch。</p>
<h3 id="Node-resets"><a href="#Node-resets" class="headerlink" title="Node resets"></a>Node resets</h3><p>所有的nodes都可以进行软件级的reset（不需要重启、重新部署它们），reset为了重用集群（重新设定集群），必须需要将某个（些）节点重置后添加到其他集群。我们可以使用“CLUSTER RESET”指令：<br>1）CLUSTER RESET SOFT<br>2）CLUSTER RESET HARD</p>
<p>指令必须直接发给需要reset的节点，如果没有指定reset类型，默认为SOFT。<br>1）soft和hard：如果节点为slave，那么节点将会转换为master，并清空其持有的数据，成为一个空的master。如果此节点为master，且持有slots数据，那么reset操作将被中断。<br>2）soft和hard：其上持有的slots将会被释放<br>3）soft和hard：此节点上的nodes映射表将会被清除，此后此node将不会知道其他节点的存在与状态。<br>4）hard：currentEpoch、configEpoch、lastVoteEpoch值将被重置为0。<br>5）hard：此nodeID将会重新生成。</p>
<p>持有数据的（slot映射不为空的）master不能被reset（除非现将此master上的slot手动迁移到其他nodes上，或者手动failover，将其切换成slave）；在某些特定的场景下，在执行reset之前，或许需要执行FLUSHALL来清空原有的数据。</p>
<h3 id="集群中移除节点"><a href="#集群中移除节点" class="headerlink" title="集群中移除节点"></a>集群中移除节点</h3><p>我们已经知道，将node移除集群之前，首先将其上的slots迁移到其他nodes上（reshard），然后关闭它。不过这似乎还并未结束，因为其他nodes仍然记住了它的ID，仍然会尝试与它建立连接。因此，当我们确定将节点移除集群时，可以使用“CLUSTER FORGET <node-id>”指令：<br>1）将此node从nodes映射表中移除。<br>2）然后设定一个60秒的隔离时间，阻止持有相同ID的node再次加入集群。</node-id></p>
<p>之所以2）规则，因为FORGET指令将会通过gossip协议传播给其他nodes，集群中所有的节点都收到消息是需要一定的时间延迟。</p>
]]></content>
    
    <summary type="html">
    
      Redis Cluster实现原理
    
    </summary>
    
      <category term="Redis" scheme="http://jishusuishouji.github.io/categories/Redis/"/>
    
    
      <category term="Redis" scheme="http://jishusuishouji.github.io/tags/Redis/"/>
    
  </entry>
  
</feed>
