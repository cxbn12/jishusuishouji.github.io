<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术随手记</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://jishusuishouji.github.io/"/>
  <updated>2017-04-18T15:27:13.808Z</updated>
  <id>http://jishusuishouji.github.io/</id>
  
  <author>
    <name>技术随手记</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>探秘Spring的PropertyEditor</title>
    <link href="http://jishusuishouji.github.io/2017/04/18/spring/%E6%8E%A2%E7%A7%98Spring%E7%9A%84PropertyEditor/"/>
    <id>http://jishusuishouji.github.io/2017/04/18/spring/探秘Spring的PropertyEditor/</id>
    <published>2017-04-18T14:03:18.000Z</published>
    <updated>2017-04-18T15:27:13.808Z</updated>
    
    <content type="html"><![CDATA[<p><code>java.beans.PropertyEditor</code>是JDK自带的类，是提供给AWT。</p>
<p>Spring利用该接口来实现Bean的属性转换器。</p>
<p>Spring xml配置的bean属性都是字符串类型的值，但是对应到的每个具体的属性是各种类型的，Spring通过各种<code>PropertyEditor</code>来对各个属性进行类型转换。</p>
<p>Spring并不是直接实现<code>PropertyEditor</code>接口，而是继承<code>PropertyEditorSupport</code>类。</p>
<h2 id="PropertyEditorRegistry"><a href="#PropertyEditorRegistry" class="headerlink" title="PropertyEditorRegistry"></a><code>PropertyEditorRegistry</code></h2><p><code>BeanWrapperImpl</code>是<code>PropertyEditorRegistrySupport</code>的子类。<br><code>PropertyEditorRegistry</code>是一个接口，<code>PropertyEditorRegistrySupport</code>是它的实现类。<br><code>PropertyEditorRegistrySupport</code>中的方法<code>createDefaultEditors</code>，该方法初始化Spring中默认<code>PropertyEditor</code>。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * Actually register the default editors for this registry instance.</div><div class="line"> */</div><div class="line">private void createDefaultEditors() &#123;</div><div class="line">    this.defaultEditors = new HashMap&lt;&gt;(64);</div><div class="line"></div><div class="line">    // Simple editors, without parameterization capabilities.</div><div class="line">    // The JDK does not contain a default editor for any of these target types.</div><div class="line">    this.defaultEditors.put(Charset.class, new CharsetEditor());</div><div class="line">    this.defaultEditors.put(Class.class, new ClassEditor());</div><div class="line">    this.defaultEditors.put(Class[].class, new ClassArrayEditor());</div><div class="line">    this.defaultEditors.put(Currency.class, new CurrencyEditor());</div><div class="line">    this.defaultEditors.put(File.class, new FileEditor());</div><div class="line">    this.defaultEditors.put(InputStream.class, new InputStreamEditor());</div><div class="line">    this.defaultEditors.put(InputSource.class, new InputSourceEditor());</div><div class="line">    this.defaultEditors.put(Locale.class, new LocaleEditor());</div><div class="line">    this.defaultEditors.put(Path.class, new PathEditor());</div><div class="line">    this.defaultEditors.put(Pattern.class, new PatternEditor());</div><div class="line">    this.defaultEditors.put(Properties.class, new PropertiesEditor());</div><div class="line">    this.defaultEditors.put(Reader.class, new ReaderEditor());</div><div class="line">    this.defaultEditors.put(Resource[].class, new ResourceArrayPropertyEditor());</div><div class="line">    this.defaultEditors.put(TimeZone.class, new TimeZoneEditor());</div><div class="line">    this.defaultEditors.put(URI.class, new URIEditor());</div><div class="line">    this.defaultEditors.put(URL.class, new URLEditor());</div><div class="line">    this.defaultEditors.put(UUID.class, new UUIDEditor());</div><div class="line">    this.defaultEditors.put(ZoneId.class, new ZoneIdEditor());</div><div class="line"></div><div class="line">    // Default instances of collection editors.</div><div class="line">    // Can be overridden by registering custom instances of those as custom editors.</div><div class="line">    this.defaultEditors.put(Collection.class, new CustomCollectionEditor(Collection.class));</div><div class="line">    this.defaultEditors.put(Set.class, new CustomCollectionEditor(Set.class));</div><div class="line">    this.defaultEditors.put(SortedSet.class, new CustomCollectionEditor(SortedSet.class));</div><div class="line">    this.defaultEditors.put(List.class, new CustomCollectionEditor(List.class));</div><div class="line">    this.defaultEditors.put(SortedMap.class, new CustomMapEditor(SortedMap.class));</div><div class="line"></div><div class="line">    // Default editors for primitive arrays.</div><div class="line">    this.defaultEditors.put(byte[].class, new ByteArrayPropertyEditor());</div><div class="line">    this.defaultEditors.put(char[].class, new CharArrayPropertyEditor());</div><div class="line"></div><div class="line">    // The JDK does not contain a default editor for char!</div><div class="line">    this.defaultEditors.put(char.class, new CharacterEditor(false));</div><div class="line">    this.defaultEditors.put(Character.class, new CharacterEditor(true));</div><div class="line"></div><div class="line">    // Spring&apos;s CustomBooleanEditor accepts more flag values than the JDK&apos;s default editor.</div><div class="line">    this.defaultEditors.put(boolean.class, new CustomBooleanEditor(false));</div><div class="line">    this.defaultEditors.put(Boolean.class, new CustomBooleanEditor(true));</div><div class="line"></div><div class="line">    // The JDK does not contain default editors for number wrapper types!</div><div class="line">    // Override JDK primitive number editors with our own CustomNumberEditor.</div><div class="line">    this.defaultEditors.put(byte.class, new CustomNumberEditor(Byte.class, false));</div><div class="line">    this.defaultEditors.put(Byte.class, new CustomNumberEditor(Byte.class, true));</div><div class="line">    this.defaultEditors.put(short.class, new CustomNumberEditor(Short.class, false));</div><div class="line">    this.defaultEditors.put(Short.class, new CustomNumberEditor(Short.class, true));</div><div class="line">    this.defaultEditors.put(int.class, new CustomNumberEditor(Integer.class, false));</div><div class="line">    this.defaultEditors.put(Integer.class, new CustomNumberEditor(Integer.class, true));</div><div class="line">    this.defaultEditors.put(long.class, new CustomNumberEditor(Long.class, false));</div><div class="line">    this.defaultEditors.put(Long.class, new CustomNumberEditor(Long.class, true));</div><div class="line">    this.defaultEditors.put(float.class, new CustomNumberEditor(Float.class, false));</div><div class="line">    this.defaultEditors.put(Float.class, new CustomNumberEditor(Float.class, true));</div><div class="line">    this.defaultEditors.put(double.class, new CustomNumberEditor(Double.class, false));</div><div class="line">    this.defaultEditors.put(Double.class, new CustomNumberEditor(Double.class, true));</div><div class="line">    this.defaultEditors.put(BigDecimal.class, new CustomNumberEditor(BigDecimal.class, true));</div><div class="line">    this.defaultEditors.put(BigInteger.class, new CustomNumberEditor(BigInteger.class, true));</div><div class="line"></div><div class="line">    // Only register config value editors if explicitly requested.</div><div class="line">    if (this.configValueEditorsActive) &#123;</div><div class="line">        StringArrayPropertyEditor sae = new StringArrayPropertyEditor();</div><div class="line">        this.defaultEditors.put(String[].class, sae);</div><div class="line">        this.defaultEditors.put(short[].class, sae);</div><div class="line">        this.defaultEditors.put(int[].class, sae);</div><div class="line">        this.defaultEditors.put(long[].class, sae);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可能上面能够转换的类型还不能满足需求，那么可以通过另一种方式将<code>PropertyEditor</code>注入到Spring中。</p>
<h2 id="PropertyEditorRegistrar"><a href="#PropertyEditorRegistrar" class="headerlink" title="PropertyEditorRegistrar"></a><code>PropertyEditorRegistrar</code></h2><p>该接口只有一个方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">void registerCustomEditors(PropertyEditorRegistry registry)</div></pre></td></tr></table></figure></p>
<p>实现该方法就可以往传入的registry添加自定义的<code>PropertyEditor</code>，一般情况下传入的registry是<code>BeanWrapperImpl</code>的实例，即将自定义的<code>PropertyEditor</code>注入到<code>BeanWrapperImpl</code>。</p>
<h2 id="CustomEditorConfigurer"><a href="#CustomEditorConfigurer" class="headerlink" title="CustomEditorConfigurer"></a><code>CustomEditorConfigurer</code></h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123;</div><div class="line">    if (this.propertyEditorRegistrars != null) &#123;</div><div class="line">        for (PropertyEditorRegistrar propertyEditorRegistrar : this.propertyEditorRegistrars) &#123;</div><div class="line">            beanFactory.addPropertyEditorRegistrar(propertyEditorRegistrar);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把<code>PropertyEditorRegistrar</code>添加到<code>BeanFactory</code>。</p>
<p>它是实现了<code>BeanFactoryPostProcessor</code>接口，即在构造完<code>BeanDefinition</code>之后会调用方法<code>postProcessBeanFactory</code>。</p>
<p>注入一个<code>CustomEditorConfigurerBean</code>(设置<code>propertyEditorRegistrars</code>和<code>customEditors属性</code>)就可以将自定义的<code>PropertyEditor</code>注入到Spring中了。</p>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="自定义PropertyEditor"><a href="#自定义PropertyEditor" class="headerlink" title="自定义PropertyEditor"></a>自定义<code>PropertyEditor</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class CustomPropertyEditor extends PropertyEditorSupport &#123;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void setAsText(String text) throws IllegalArgumentException &#123;</div><div class="line">        super.setAsText(text);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public Object getValue() &#123;</div><div class="line">        return super.getValue();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="将这个PropertyEditor注入到Spring里面中"><a href="#将这个PropertyEditor注入到Spring里面中" class="headerlink" title="将这个PropertyEditor注入到Spring里面中"></a>将这个<code>PropertyEditor</code>注入到Spring里面中</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;&gt;</div><div class="line">    &lt;property name=&quot;customEditors&quot;&gt;</div><div class="line">        &lt;map&gt;</div><div class="line">            &lt;entry key=&quot;com.xx.foo.FooPojo&quot; value=&quot;com.xx.foo.CustomPropertyEditor&quot;/&gt;</div><div class="line">        &lt;/map&gt;</div><div class="line">    &lt;/property&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<h2 id="ClassEditor的实现"><a href="#ClassEditor的实现" class="headerlink" title="ClassEditor的实现"></a><code>ClassEditor</code>的实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class ClassEditor extends PropertyEditorSupport &#123;</div><div class="line"></div><div class="line">    private final ClassLoader classLoader;</div><div class="line">    public ClassEditor() &#123;</div><div class="line">        this(null);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public ClassEditor(ClassLoader classLoader) &#123;</div><div class="line">        this.classLoader = (classLoader != null ? classLoader : ClassUtils.getDefaultClassLoader());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void setAsText(String text) throws IllegalArgumentException &#123;</div><div class="line">        if (StringUtils.hasText(text)) &#123;</div><div class="line">            setValue(ClassUtils.resolveClassName(text.trim(), this.classLoader));</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            setValue(null);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public String getAsText() &#123;</div><div class="line">        Class clazz = (Class) getValue();</div><div class="line">        if (clazz != null) &#123;</div><div class="line">            return ClassUtils.getQualifiedName(clazz);</div><div class="line">        &#125;</div><div class="line">        else &#123;</div><div class="line">            return &quot;&quot;;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      探秘Spring的PropertyEditor
    
    </summary>
    
      <category term="Spring" scheme="http://jishusuishouji.github.io/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://jishusuishouji.github.io/tags/Spring/"/>
    
      <category term="PropertyEditor" scheme="http://jishusuishouji.github.io/tags/PropertyEditor/"/>
    
  </entry>
  
  <entry>
    <title>ServletContext总结</title>
    <link href="http://jishusuishouji.github.io/2017/04/17/ServletContext%E6%80%BB%E7%BB%93.md/ServletContext%E6%80%BB%E7%BB%93/"/>
    <id>http://jishusuishouji.github.io/2017/04/17/ServletContext总结.md/ServletContext总结/</id>
    <published>2017-04-17T14:23:11.000Z</published>
    <updated>2017-04-17T14:23:11.349Z</updated>
    
    <summary type="html">
    
      ServletContext总结
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于Keepalived+Haproxy搭建四层负载均衡器</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/jiqun/%E5%9F%BA%E4%BA%8EKeepalived_Haproxy%E6%90%AD%E5%BB%BA%E5%9B%9B%E5%B1%82%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/jiqun/基于Keepalived_Haproxy搭建四层负载均衡器/</id>
    <published>2017-04-07T05:07:53.000Z</published>
    <updated>2017-04-07T05:13:34.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>Haproxy是稳定、高性能、高可用性的负载均衡解决方案，支持HTTP及TCP代理后端服务器池，因支持强大灵活的7层acl规则，广泛作为HTTP反向代理。本文则详细介绍如何利用它的四层交换与Keepalived实现一个负载均衡器，适用于Socket、ICE、mail、mysql、私有通讯等任意TCP服务。系统架构图如下：</p>
<p>点击在新窗口中浏览此图片</p>
<p>二、平台环境</p>
<p>OS:Centos5.4(64X)<br>MASTER:192.168.0.20<br>BACKUP:192.168.0.21<br>VIP:192.168.0.100<br>Serivce Port:11231<br>三、平台安装配置</p>
<p>1、添加非本机ip邦定支持</p>
<p>#vi /etc/sysctl.conf<br>net.ipv4.ip_nonlocal_bind=1</p>
<p>#sysctl –p<br>2、配置平台日志支持</p>
<p>#vi /etc/syslog.conf<br>添加：<br>local3.<em>        /var/log/haproxy.log<br>local0.</em>        /var/log/haproxy.log</p>
<p>#vi /etc/sysconfig/syslog<br>修改：<br>SYSLOGD_OPTIONS=”-r -m 0”</p>
<p>#/etc/init.d/syslog restart<br>3、关闭SELINUX</p>
<p>vi /etc/sysconfig/selinux<br>修改：<br>SELINUX=disabled</p>
<p>#setenforce 0<br>4、配置iptables，添加VRRP通讯支持</p>
<p>iptables -A INPUT -d 224.0.0.18 -j accept<br>5、Keepalived的安装、配置</p>
<p>#mkdir -p /home/install/keepalivedha</p>
<p>#cd /home/install/keepalivedha</p>
<p>#wget <a href="http://www.keepalived.org/software/keepalived-1.2.2.tar.gz" target="_blank" rel="external">http://www.keepalived.org/software/keepalived-1.2.2.tar.gz</a></p>
<p>#tar zxvf keepalived-1.2.2.tar.gz</p>
<p>#cd keepalived-1.2.2</p>
<p>#./configure</p>
<p>#make &amp;&amp; make install</p>
<p>#cp /usr/local/etc/rc.d/init.d/keepalived /etc/rc.d/init.d/</p>
<p>#cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/</p>
<p>#mkdir /etc/keepalived</p>
<p>#cp /usr/local/etc/keepalived/keepalived.conf /etc/keepalived/</p>
<p>#cp /usr/local/sbin/keepalived /usr/sbin/</p>
<p>#vi /etc/keepalived/keepalived.conf</p>
<p>! Configuration file for keepalived  </p>
<p>global_defs {<br>   notification_email {<br>         liutiansi@gmail.com<br>   }<br>   notification_email_from liutiansi@gmail.com<br>   smtp_connect_timeout 3<br>   smtp_server 127.0.0.1<br>   router_id LVS_DEVEL<br>}<br>vrrp_script chk_haproxy {<br>    script “killall -0 haproxy”<br>    interval 2<br>    weight 2<br>}<br>vrrp_instance VI_1 {<br>    interface eth1<br>    state MASTER # 从为BACKUP<br>    priority 101 # 从为100<br>    virtual_router_id 50 #路由ID，可通过#tcpdump vrrp查看。<br>    garp_master_delay 1 #主从切换时间，单位为秒。  </p>
<pre><code>authentication {  
    auth_type PASS  
    auth_pass KJj23576hYgu23IP  
}  
track_interface {  
   eth0  
   eth1  
}  
virtual_ipaddress {  
    192.168.0.100  
}  
track_script {  
    chk_haproxy  
}  

#状态通知  
notify_master &quot;/etc/keepalived/Mailnotify.py master&quot;  
notify_backup &quot;/etc/keepalived/Mailnotify.py backup&quot;  
notify_fault &quot;/etc/keepalived/Mailnotify.py fault&quot;  
</code></pre><p>}<br>6、Haproxy的安装与配置</p>
<p>#cd /home/install/keepalivedha</p>
<p>#wget <a href="http://haproxy.1wt.eu/download/1.4/src/haproxy-1.4.11.tar.gz" target="_blank" rel="external">http://haproxy.1wt.eu/download/1.4/src/haproxy-1.4.11.tar.gz</a></p>
<p>#tar -zxvf haproxy-1.4.11.tar.gz</p>
<p>#cd haproxy-1.4.11</p>
<p>#make install</p>
<p>#mkdir -p /usr/local/haproxy/etc</p>
<p>#mkdir -p /usr/local/haproxy/sbin</p>
<p>#cp examples/haproxy.cfg /usr/local/haproxy/etc</p>
<p>#ln -s /usr/local/sbin/haproxy /usr/local/haproxy/sbin/haproxy </p>
<p>#vi /usr/local/haproxy/etc/haproxy.cfg</p>
<h1 id="this-config-needs-haproxy-1-1-28-or-haproxy-1-2-1"><a href="#this-config-needs-haproxy-1-1-28-or-haproxy-1-2-1" class="headerlink" title="this config needs haproxy-1.1.28 or haproxy-1.2.1"></a>this config needs haproxy-1.1.28 or haproxy-1.2.1</h1><p>global  </p>
<h1 id="log-127-0-0-1-local0"><a href="#log-127-0-0-1-local0" class="headerlink" title="log 127.0.0.1   local0"></a>log 127.0.0.1   local0</h1><pre><code>log 127.0.0.1   local1 notice  
maxconn 5000  
uid 99  
gid 99  

daemon  
pidfile /usr/local/haproxy/haproxy.pid  
</code></pre><p>defaults<br>        log     global<br>        mode    http  </p>
<pre><code>#option httplog  
 option  dontlognull  
 retries 3  
 option redispatch  
 maxconn 2000  
 contimeout      5000  
 clitimeout      50000  
 srvtimeout      50000  
</code></pre><p>listen  ICE01   192.168.0.100:11231<br>        mode tcp #配置TCP模式<br>        maxconn 2000<br>        balance roundrobin<br>        server  ice-192.168.0.128 192.168.0.128:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.129 192.168.0.129:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.130 192.168.0.130:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.131 192.168.0.131:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.132 192.168.0.132:11231 check inter 5000 fall 1 rise 2<br>        server  ice-192.168.0.34 192.168.0.34:11231 check inter 5000 fall 1 rise 2<br>        srvtimeout      20000  </p>
<p>listen stats_auth 192.168.0.20:80  </p>
<h1 id="listen-stats-auth-192-168-0-21-80-backup-config"><a href="#listen-stats-auth-192-168-0-21-80-backup-config" class="headerlink" title="listen stats_auth 192.168.0.21:80 # backup config"></a>listen stats_auth 192.168.0.21:80 # backup config</h1><pre><code>stats enable  
stats uri  /admin-status #管理地址  
stats auth  admin:123456 #管理帐号:管理密码  
stats admin if TRUE  
</code></pre><p>7、邮件通知程序(python实现)</p>
<p>#vi /etc/keepalived/Mailnotify.py</p>
<p>#!/usr/local/bin/python  </p>
<p>#coding: utf-8<br>from email.MIMEMultipart import MIMEMultipart<br>from email.MIMEText import MIMEText<br>from email.MIMEImage import MIMEImage<br>from email.header import Header<br>import sys<br>import smtplib  </p>
<p>#—————————————————————  </p>
<h1 id="Name-Mailnotify-py"><a href="#Name-Mailnotify-py" class="headerlink" title="Name:        Mailnotify.py"></a>Name:        Mailnotify.py</h1><h1 id="Purpose-Mail-notify-to-SA"><a href="#Purpose-Mail-notify-to-SA" class="headerlink" title="Purpose:     Mail notify to SA"></a>Purpose:     Mail notify to SA</h1><h1 id="Author-Liutiansi"><a href="#Author-Liutiansi" class="headerlink" title="Author:      Liutiansi"></a>Author:      Liutiansi</h1><h1 id="Email-liutiansi-gamil-com"><a href="#Email-liutiansi-gamil-com" class="headerlink" title="Email:       liutiansi@gamil.com"></a>Email:       liutiansi@gamil.com</h1><h1 id="Created-2011-03-09"><a href="#Created-2011-03-09" class="headerlink" title="Created:     2011/03/09"></a>Created:     2011/03/09</h1><h1 id="Copyright-c-2011"><a href="#Copyright-c-2011" class="headerlink" title="Copyright:   (c) 2011"></a>Copyright:   (c) 2011</h1><p>#————————————————————–<br>strFrom = ‘admin@domain.com’<br>strTo = ‘liutiansi@gmail.com’<br>smtp_server=’smtp.domain.com’<br>smtp_pass=’123456’  </p>
<p>if sys.argv[1]!=”master” and sys.argv[1]!=”backup”  and sys.argv[1]!=”fault”:<br>    sys.exit()<br>else:<br>    notify_type=sys.argv[1]  </p>
<p>mail_title=’[紧急]负载均衡器邮件通知’<br>mail_body_plain=notify_type+’被激活，请做好应急处理。’<br>mail_body_html=’<b><font color="red">‘+notify_type+’被激活，请做好应急处理。</font></b>‘  </p>
<p>msgRoot = MIMEMultipart(‘related’)<br>msgRoot[‘Subject’] =Header(mail_title,’utf-8’)<br>msgRoot[‘From’] = strFrom<br>msgRoot[‘To’] = strTo  </p>
<p>msgAlternative = MIMEMultipart(‘alternative’)<br>msgRoot.attach(msgAlternative)  </p>
<p>msgText = MIMEText(mail_body_plain, ‘plain’, ‘utf-8’)<br>msgAlternative.attach(msgText)  </p>
<p>msgText = MIMEText(mail_body_html, ‘html’,’utf-8’)<br>msgAlternative.attach(msgText)  </p>
<p>smtp = smtplib.SMTP()<br>smtp.connect(smtp_server)<br>smtp.login(smtp_user,smtp_pass)<br>smtp.sendmail(strFrom, strTo, msgRoot.as_string())<br>smtp.quit()<br>注：修改成系统python实际路径“#!/usr/local/bin/python”(第一行)</p>
<p>#chmod +x /etc/keepalived/Mailnotify.py</p>
<p>#/usr/local/haproxy/sbin/haproxy -f /usr/local/haproxy/etc/haproxy.cfg</p>
<p>#service keepalived start<br>8、查看VRRP通讯记录</p>
<p>#tcpdump vrrp<br>tcpdump: verbose output suppressed, use -v or -vv for full protocol decode<br>listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes<br>15:49:05.270017 IP 192.168.0.20 &gt; VRRP.MCAST.NET: VRRPv2, Advertisement, vrid 50, prio 100, authtype simple, intvl 1s, length 20<br>四、Haproxy界面</p>
<p>访问<a href="http://192.168.0.20/admin-status，输入帐号admin密码123456进入管理监控平台。" target="_blank" rel="external">http://192.168.0.20/admin-status，输入帐号admin密码123456进入管理监控平台。</a></p>
<p>点击在新窗口中浏览此图片</p>
<p>haproxy-1.4.9以后版本最大的亮点是添加了手工启用/禁用功能，对升级变更应用时非常有用。</p>
<p>五、邮件通知</p>
<p>点击在新窗口中浏览此图片</p>
]]></content>
    
    <summary type="html">
    
      基于Keepalived+Haproxy搭建四层负载均衡器
    
    </summary>
    
      <category term="集群" scheme="http://jishusuishouji.github.io/categories/%E9%9B%86%E7%BE%A4/"/>
    
    
      <category term="集群" scheme="http://jishusuishouji.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>nginx+keepalive主从双机热备+自动切换解决方案</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/jiqun/nginx_keepalive%E4%B8%BB%E4%BB%8E%E5%8F%8C%E6%9C%BA%E7%83%AD%E5%A4%87_%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/jiqun/nginx_keepalive主从双机热备_自动切换解决方案/</id>
    <published>2017-04-07T04:42:10.000Z</published>
    <updated>2017-04-07T04:50:23.322Z</updated>
    
    <content type="html"><![CDATA[<p>cenots 6.3 64位</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yum install -y make wget</div></pre></td></tr></table></figure>
<h2 id="1-安装keepalive"><a href="#1-安装keepalive" class="headerlink" title="1.安装keepalive"></a>1.安装keepalive</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar zxvf keepalived-1.2.7.tar.gz</div><div class="line">cd keepalived-1.2.7</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">yum install -y gcc openssl-devel popt-devel</div><div class="line">./configure</div><div class="line">make &amp;&amp; make install </div><div class="line"></div><div class="line">cp /usr/local/etc/rc.d/init.d/keepalived /etc/init.d/</div><div class="line">cp /usr/local/etc/sysconfig/keepalived /etc/sysconfig/</div><div class="line">chmod +x /etc/init.d/keepalived</div><div class="line">chkconfig --add keepalived</div><div class="line">chkconfig keepalived on</div><div class="line">mkdir /etc/keepalived</div><div class="line">ln -s /usr/local/sbin/keepalived /usr/sbin/</div></pre></td></tr></table></figure>
<h2 id="2-安装Nginx"><a href="#2-安装Nginx" class="headerlink" title="2.安装Nginx"></a>2.安装Nginx</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">tar zxvf  nginx-1.2.5.tar.gz</div><div class="line">cd nginx-1.2.5</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">yum install -y pcre-devel</div><div class="line">./configure --prefix=/usr/local/nginx --user=www --group=www  --with-http_stub_status_module --with-http_ssl_module</div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure>
<h2 id="3-配置keepalive"><a href="#3-配置keepalive" class="headerlink" title="3.配置keepalive"></a>3.配置keepalive</h2><p>两台服务器端<code>keepalived.conf</code>内容如下，都设置为<code>backup</code>，不抢占，注意修改优先级不同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">! Configuration file for keepalived</div><div class="line">global_defs &#123;</div><div class="line">   notification_email &#123;</div><div class="line">    admin@lvtao.net</div><div class="line">   &#125;</div><div class="line">   notification_email_from admin@lvtao.net</div><div class="line">   smtp_server 127.0.0.1</div><div class="line">   smtp_connect_timeout 30</div><div class="line">   router_id LVS_DEVEL</div><div class="line">&#125;</div><div class="line">#监控服务.NGINX mysql等</div><div class="line">vrrp_script chk_nginx &#123;</div><div class="line">    script &quot;/home/check_nginx.sh&quot;</div><div class="line">    interval 2</div><div class="line">    weight 2</div><div class="line">&#125;</div><div class="line"></div><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    state BACKUP  #主从设置 MASTER</div><div class="line">    interface eth2  #网卡名</div><div class="line">    virtual_router_id 51</div><div class="line">    mcast_src_ip 10.0.1.133 #本机ip</div><div class="line">    priority 50  #从机小于主机</div><div class="line">    advert_int 1</div><div class="line">    authentication &#123;</div><div class="line">        auth_type PASS</div><div class="line">        auth_pass chtopnet</div><div class="line">    &#125;</div><div class="line">    virtual_ipaddress &#123;</div><div class="line">        10.0.1.2  #VIP 的IP</div><div class="line">    &#125;</div><div class="line">    track_script &#123;</div><div class="line">        chk_nginx  #检测脚本</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">virtual_server 10.0.1.2 80 &#123;</div><div class="line">    delay_loop 6</div><div class="line">    lb_algo rr</div><div class="line">    lb_kind DR</div><div class="line">    persistence_timeout 50</div><div class="line">    protocol TCP</div><div class="line"></div><div class="line">    real_server 10.0.1.132 80 &#123;</div><div class="line">        weight 3</div><div class="line">        TCP_CHECK &#123;</div><div class="line">            connect_timeout 10</div><div class="line">            nb_get_retry 3</div><div class="line">            delay_before_retry 3</div><div class="line">            connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    real_server 10.0.1.133 80 &#123;</div><div class="line">        weight 3</div><div class="line">        TCP_CHECK &#123;</div><div class="line">            connect_timeout 10</div><div class="line">            nb_get_retry 3</div><div class="line">            delay_before_retry 3</div><div class="line">            connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>启动相关服务。我在这儿使用的是nginx ，每个上面开了一个站点，通过IP可以直接访问的。启动keepalive后，就可以通过VIP的虚拟IP 10.0.1.2来访问站点了，测试方法就是 停止任何其中一个站点，看它是否能自动切换到从服务器上。</p>
<p>上面代码中nginx的检测脚本如下 ：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">if [ &quot;$(ps -ef | grep &quot;nginx: master process&quot;| grep -v grep )&quot; == &quot;&quot; ]</div><div class="line">then</div><div class="line"> /usr/local/nginx/sbin/nginx</div><div class="line"> sleep 5</div><div class="line"> if [ &quot;$(ps -ef | grep &quot;nginx: master process&quot;| grep -v grep )&quot; == &quot;&quot; ]</div><div class="line"> then</div><div class="line">     killall keepalived</div><div class="line"> fi</div><div class="line">fi</div></pre></td></tr></table></figure></p>
<p>在两台Web Server上执行<code>realserver.sh</code>脚本，为lo:0绑定VIP地址10.0.1.2、抑制arp广播。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">#description: Config realserver</div><div class="line"></div><div class="line">VIP=10.0.1.2</div><div class="line"> </div><div class="line">/etc/rc.d/init.d/functions</div><div class="line"> </div><div class="line">case &quot;$1&quot; in</div><div class="line">start)</div><div class="line">       /sbin/ifconfig lo:0 $VIP netmask 255.255.255.255 broadcast $VIP</div><div class="line">       /sbin/route add -host $VIP dev lo:0</div><div class="line">       echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</div><div class="line">       echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</div><div class="line">       echo &quot;1&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</div><div class="line">       echo &quot;2&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce</div><div class="line">       sysctl -p &gt;/dev/null 2&gt;&amp;1</div><div class="line">       echo &quot;RealServer Start OK&quot;</div><div class="line">       ;;</div><div class="line">stop)</div><div class="line">       /sbin/ifconfig lo:0 down</div><div class="line">       /sbin/route del $VIP &gt;/dev/null 2&gt;&amp;1</div><div class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_ignore</div><div class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/lo/arp_announce</div><div class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_ignore</div><div class="line">       echo &quot;0&quot; &gt;/proc/sys/net/ipv4/conf/all/arp_announce</div><div class="line">       echo &quot;RealServer Stoped&quot;</div><div class="line">       ;;</div><div class="line">*)</div><div class="line">       echo &quot;Usage: $0 &#123;start|stop&#125;&quot;</div><div class="line">       exit 1</div><div class="line">esac</div><div class="line"> </div><div class="line">exit 0</div></pre></td></tr></table></figure></p>
<p>分别在主从机上执行<code>sh realserver.sh start</code>就可实现负载均衡及高可用集群了；</p>
<p>keepalive相关参数说明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"> ! Configuration File for keepalived</div><div class="line"></div><div class="line">global_defs &#123;</div><div class="line">   notification_email &#123;</div><div class="line">     admin@lvtao.net             #设置报警邮件地址，可以设置多个，每行一个。 需开启本机的sendmail服务</div><div class="line">   &#125;</div><div class="line">   notification_email_from  admin@lvtao.net        #设置邮件的发送地址</div><div class="line">   smtp_server 127.0.0.1                                #设置smtp server地址</div><div class="line">   smtp_connect_timeout 30                              #设置连接smtp server的超时时间</div><div class="line">   router_id LVS_DEVEL                                  #表示运行keepalived服务器的一个标识。发邮件时显示在邮件主题的信息</div><div class="line">&#125;</div><div class="line"></div><div class="line">vrrp_instance VI_1 &#123;</div><div class="line">    state MASTER              #指定keepalived的角色，MASTER表示此主机是主服务器，BACKUP表示此主机是备用服务器</div><div class="line">    interface eth0            #指定HA监测网络的接口</div><div class="line">    virtual_router_id 51      #虚拟路由标识，这个标识是一个数字，同一个vrrp实例使用唯一的标识。即同一vrrp_instance下，MASTER和BACKUP必须是一致的</div><div class="line">    priority 100              #定义优先级，数字越大，优先级越高，在同一个vrrp_instance下，MASTER的优先级必须大于BACKUP的优先级</div><div class="line">    advert_int 1              #设定MASTER与BACKUP负载均衡器之间同步检查的时间间隔，单位是秒</div><div class="line">    authentication &#123;          #设置验证类型和密码</div><div class="line">        auth_type PASS        #设置验证类型，主要有PASS和AH两种</div><div class="line">        auth_pass 1111        #设置验证密码，在同一个vrrp_instance下，MASTER与BACKUP必须使用相同的密码才能正常通信</div><div class="line">    &#125;</div><div class="line">    virtual_ipaddress &#123;       #设置虚拟IP地址，可以设置多个虚拟IP地址，每行一个</div><div class="line">        10.0.0.148</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">virtual_server 10.0.0.148 80 &#123;      #设置虚拟服务器，需要指定虚拟IP地址和服务端口，IP与端口之间用空格隔开</div><div class="line">    delay_loop 6                    #设置运行情况检查时间，单位是秒</div><div class="line">    lb_algo rr                      #设置负载调度算法，这里设置为rr，即轮询算法</div><div class="line">    lb_kind DR                      #设置LVS实现负载均衡的机制，有NAT、TUN、DR三个模式可选</div><div class="line">    persistence_timeout 50          #会话保持时间，单位是秒。这个选项对动态网页是非常有用的，为集群系统中的session共享提供了一个很好的解决方案。</div><div class="line">                                    #有了这个会话保持功能，用户的请求会被一直分发到某个服务节点，直到超过这个会话的保持时间。</div><div class="line">                                    #需要注意的是，这个会话保持时间是最大无响应超时时间，也就是说，用户在操作动态页面时，如果50秒内没有执行任何操作，</div><div class="line">                                    #那么接下来的操作会被分发到另外的节点，但是如果用户一直在操作动态页面，则不受50秒的时间限制</div><div class="line">    protocol TCP                    #指定转发协议类型，有TCP和UDP两种</div><div class="line"></div><div class="line">    real_server 10.0.0.137 80 &#123;     #配置服务节点1，需要指定real server的真实IP地址和端口，IP与端口之间用空格隔开</div><div class="line">        weight 3                    #配置服务节点的权值，权值大小用数字表示，数字越大，权值越高，设置权值大小可以为不同性能的服务器</div><div class="line">                                    #分配不同的负载，可以为性能高的服务器设置较高的权值，而为性能较低的服务器设置相对较低的权值，这样才能合理地利用和分配系统资源</div><div class="line">        TCP_CHECK &#123;                 #realserver的状态检测设置部分，单位是秒</div><div class="line">            connect_timeout 10      #表示3秒无响应超时</div><div class="line">            nb_get_retry 3          #表示重试次数</div><div class="line">            delay_before_retry 3    #表示重试间隔</div><div class="line">            connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    real_server 10.0.0.139 80 &#123;</div><div class="line">        weight 3</div><div class="line">        TCP_CHECK &#123;</div><div class="line">            connect_timeout 10</div><div class="line">            nb_get_retry 3</div><div class="line">            delay_before_retry 3</div><div class="line">            connect_port 80</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      nginx+keepalive主从双机热备+自动切换解决方案
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>反向代理为何叫反向代理？</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/fangxiangdaili/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%BA%E4%BD%95%E5%8F%AB%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9F/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/fangxiangdaili/反向代理为何叫反向代理？/</id>
    <published>2017-04-07T04:19:19.000Z</published>
    <updated>2017-04-07T04:29:06.606Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>A同学准备找马云借钱，但是马云不同意；于是他通过马云的亲戚向马云借钱，事情成了。这里马云并不知道钱是谁借的，马云借给了自己的亲戚，亲戚最后转交给A同学。亲戚在这个过程中扮演了代理的角色(正向代理)。如果马云是服务器，大家访问它(跟他借钱)，而马云又不可能随随便便借钱给别人，那么那些马云的亲戚就是正向代理，代理客户端(A同学们)向马云借钱。  </p>
<p>常说的代理也就是指正向代理，它隐藏了真实的请求客户端，服务端不知道真实的客户端是谁，客户端的都被代理服务器代替来请求。</p>
<p>科学上网工具扮演的就是正向代理角色。</p>
<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>拨打10086客服电话，一个地区的10086客服有几个或者几十个，你拨通了10086的总机号码，电话那头总会有人会回答你。这里的10086总机号码就是起了反向代理的作用。客户并不知道真正提供服务人的是谁。</p>
<p>反向代理隐藏了真实的服务端。</p>
<h2 id="正向代理和反向代理的区别"><a href="#正向代理和反向代理的区别" class="headerlink" title="正向代理和反向代理的区别"></a>正向代理和反向代理的区别</h2><p>正向代理代理的对象是客户端，反向代理代理的对象是服务端</p>
]]></content>
    
    <summary type="html">
    
      反向代理为何叫反向代理？
    
    </summary>
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/categories/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>反向代理</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/jiqun/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/jiqun/反向代理/</id>
    <published>2017-04-07T03:55:17.000Z</published>
    <updated>2017-04-07T04:18:22.553Z</updated>
    
    <content type="html"><![CDATA[<p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>
<h2 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h2><h3 id="通常的代理服务器-内部网络对Internet的连接请求"><a href="#通常的代理服务器-内部网络对Internet的连接请求" class="headerlink" title="通常的代理服务器(内部网络对Internet的连接请求)"></a>通常的代理服务器(内部网络对Internet的连接请求)</h3><p>通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送到代理服务器中。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>外部网络上的主机并不会配置并使用这个代理服务器，普通代理服务器也被设计为在Internet上搜寻多个不确定的服务器,而不是针对客户机的请求访问某一个固定的服务器，因此普通的Web代理服务器不支持外部对内部网络的访问请求。</p>
<h3 id="方向代理服务器"><a href="#方向代理服务器" class="headerlink" title="方向代理服务器"></a>方向代理服务器</h3><p>当一个代理服务器代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。此时代理服务器对外就表现为一个Web服务器，外部网络就可以简单把它当作一个标准的Web服务器而不需要特定的配置。不同之处在于，这个服务器没有保存任何网页的真实数据，所有的静态网页或者CGI程序，都保存在内部的Web服务器上。因此对反向代理服务器的攻击并不会使得网页信息遭到破坏，这样就增强了Web服务器的安全性。</p>
<p>反向代理方式和包过滤方式或普通代理方式并无冲突，因此可以在防火墙设备中同时使用这两种方式，其中反向代理用于外部网络访问内部网络时使用，正向代理或包过滤方式用于拒绝其他外部访问方式并提供内部网络对外部网络的访问能力。因此可以结合这些方式提供最佳的安全访问方式。</p>
<h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输得更快、更稳定。通过在网络各处放置反向代理服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决Internet网络拥挤的状况，提高用户访问网站的响应速度。</p>
<h2 id="代理服务器"><a href="#代理服务器" class="headerlink" title="代理服务器"></a>代理服务器</h2><p>如果您的内容服务器具有必须保持安全的敏感信息，如信用卡号数据库，可在防火墙外部设置一个代理服务器作为内容服务器的替身。当外部客户机尝试访问内容服务器时，会将其送到代理服务器。实际内容位于内容服务器上，在内部受到防火墙安全保护。代理服务器位于防火墙外部，在外部客户机看来就像是内容服务器。<br>当客户机向站点提出请求时，请求将转到代理服务器。然后，代理服务器通过防火墙中的特定通路，将客户机的请求发送到内容服务器。内容服务器再通过该通道将结果回传给代理服务器。代理服务器将检索到的信息发送给客户机，好像代理服务器就是实际的内容服务器。如果内容服务器返回错误消息，代理服务器会先行截取该消息并更改标头中列出的任何URL，然后再将消息发送给客户机。如此可防止外部客户机获取内部内容服务器的重定向URL。<br>这样，代理服务器就在安全数据库和可能的恶意攻击之间提供了又一道屏障。与有权访问整个数据库的情况相对比，就算是侥幸攻击成功，作恶者充其量也仅限于访问单个事务中所涉及的信息。未经授权的用户无法访问到真正的内容服务器，因为防火墙通路只允许代理服务器有权进行访问。<br><img src="/img/反向代理服务器就像是真正的内容服务器.jpg" alt="图1 反向代理服务器就像是真正的内容服务器"></p>
<p>可以配置防火墙路由器，使其只允许特定端口上的特定服务器有权通过防火墙进行访问，而不允许其他任何机器进出。</p>
<h2 id="安全反向代理"><a href="#安全反向代理" class="headerlink" title="安全反向代理"></a>安全反向代理</h2><p>当代理服务器与其他机器之间有一个或多个连接使用安全套接字层(SSL) 协议加密数据时，即会进行安全反向代理。</p>
<h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>可以提供从防火墙外部代理服务器到防火墙内部安全内容服务器的加密连接。<br>可以允许客户机安全地连接到代理服务器，从而有利于安全地传输信息（如信用卡号）。<br>安全反向代理会造成各安全连接因加密数据所涉及的系统开销而变慢。但是，由于 SSL 提供了高速缓存机制，所以连接双方可以重复使用先前协商的安全参数，从而大大降低后续连接的系统开销。</p>
<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><p>配置安全反向代理服务器的方法有三种：</p>
<h3 id="Secure-client-to-proxy"><a href="#Secure-client-to-proxy" class="headerlink" title="Secure client to proxy"></a>Secure client to proxy</h3><p>如果未经授权的用户很少或根本没有机会访问代理服务器与内容服务器之间交换的信息，则此方案很有效。<br><img src="/img/图 2 客户机安全连接到代理服务器.jpg" alt="图 2 客户机安全连接到代理服务器"></p>
<h3 id="Secure-proxy-to-content-server"><a href="#Secure-proxy-to-content-server" class="headerlink" title="Secure proxy to content server"></a>Secure proxy to content server</h3><p>如果客户机在防火墙外部而内容服务器在防火墙内部，则此方案很有效。在此方案中，代理服务器可以充当站点之间的安全通道<br><img src="/img/图 3 代理服务器安全连接到内容服务器.jpg" alt="图 3 代理服务器安全连接到内容服务器"></p>
<h3 id="Secure-client-to-proxy-and-secure-proxy-to-content-server"><a href="#Secure-client-to-proxy-and-secure-proxy-to-content-server" class="headerlink" title="Secure client to proxy and secure proxy to content server"></a>Secure client to proxy and secure proxy to content server</h3><p>如果需要保护服务器、代理服务器和客户机三者间所交换信息的安全，则此方案很有效。在此方案中，代理服务器既可起到站点间安全通道的作用，又可增加客户机验证的安全性。<br><img src="/img/Secure client to proxy and secure proxy to content server.jpg" alt="图 4 客户机安全连接到代理服务器并且代理服务器安全连接到内容服务器"></p>
<p>除了SSL之外，代理服务器还可以使用客户机验证，这种方法要求向代理服务器提出请求的计算机提供证书（或标识表单）以核实其身份。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><h3 id="标准的代理缓冲服务器"><a href="#标准的代理缓冲服务器" class="headerlink" title="标准的代理缓冲服务器"></a>标准的代理缓冲服务器</h3><p>一个标准的代理缓冲服务被用于缓存静态的网页（例如：html文件和图片文件等）到本地网络上的一台主机上（即代理服务器）。当被缓存的页面被第二次访问的时候，浏览器将直接从本地代理服务器那里请求数据而不再向原web站点请求数据。这样就节省了宝贵的网络带宽，而且提高了访问速度。但是，要想实现这种方式，必须在每一个内部主机的浏览器上明确指明代理服务器的IP地址和端口号。客户端上网时，每次都把请求送给代理服务器处理，代理服务器根据请求确定是否连接到远程web服务器获取数据。如果在本地缓冲区有目标文件，则直接将文件传给用户即可。如果没有的话则先取回文件，先在本地保存一份缓冲，然后将文件发给客户端浏览器。</p>
<h3 id="透明代理缓冲服务器"><a href="#透明代理缓冲服务器" class="headerlink" title="透明代理缓冲服务器"></a>透明代理缓冲服务器</h3><p>透明代理缓冲服务和标准代理服务器的功能完全相同。但是，代理操作对客户端的浏览器是透明的（即不需指明代理服务器的IP和端口）。透明代理服务器阻断网络通信，并且过滤出访问外部的HTTP（80端口）流量。如果客户端的请求在本地有缓冲则将缓冲的数据直接发给用户，如果在本地没有缓冲则向远程web服务器发出请求，其余操作和标准的代理服务器完全相同。对于Linux操作系统来说，透明代理使用Iptables或者Ipchains实现。因为不需要对浏览器作任何设置，所以，透明代理对于ISP（Internet服务器提供商）特别有用。</p>
<h3 id="反向代理缓冲服务器"><a href="#反向代理缓冲服务器" class="headerlink" title="反向代理缓冲服务器"></a>反向代理缓冲服务器</h3><p>反向代理是和前两种代理完全不同的一种代理服务。使用它可以降低原始WEB服务器的负载。反向代理服务器承担了对原始WEB服务器的静态页面的请求，防止原始服务器过载。它位于本地WEB服务器和Internet之间，处理所有对WEB服务器的请求，阻止了WEB服务器和Internet的直接通信。如果互联网用户请求的页面在代理服务器上有缓冲的话，代理服务器直接将缓冲内容发送给用户。如果没有缓冲则先向WEB服务器发出请求，取回数据，本地缓存后再发送给用户。这种方式通过降低了向WEB服务器的请求数从而降低了WEB服务器的负载。</p>
]]></content>
    
    <summary type="html">
    
      反向代理
    
    </summary>
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/categories/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="反向代理" scheme="http://jishusuishouji.github.io/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Nginx/LVS/HAProxy负载均衡软件的优缺点详解</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/fuzaijunheng/Nginx_LVS_HAProxy%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E8%AF%A6%E8%A7%A3/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/fuzaijunheng/Nginx_LVS_HAProxy负载均衡软件的优缺点详解/</id>
    <published>2017-04-07T03:42:08.000Z</published>
    <updated>2017-04-07T04:40:13.638Z</updated>
    
    <content type="html"><![CDATA[<p>根据网站规模不同使用不同的技术。中小型的Web应用(日PV小于1000万,平均下来一秒也就处理一百多个请求)用Nginx就可以了；如果机器不少，可以用DNS轮询，LVS需要的机器比较多；大型网站或重要的服务，且服务器比较多时，可以考虑用LVS。</p>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><p>F5和Array等商用的负载均衡器</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>有专业的维护团队进行维护</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>花销太大</p>
<h2 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h2><p>Nginx/LVS/HAProxy等基于Linux的开源免费的负载均衡软件，通过软件级别来实现，费用非常低廉。</p>
<h2 id="合理流行的架构方案"><a href="#合理流行的架构方案" class="headerlink" title="合理流行的架构方案"></a>合理流行的架构方案</h2><h3 id="web"><a href="#web" class="headerlink" title="web"></a>web</h3><p>Nginx/HAProxy+Keepalived作负载均衡器</p>
<h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h3><p>MySQL数据库一主多从和读写分离，采用LVS+Keepalived的架构。</p>
<h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>1、工作在网络协议的第7层，可以针对http应用做一些分流的策略，比如针对域名、目录结构，它的正则规则比HAProxy更为强大和灵活，这也是它目前广泛流行的主要原因之一，Nginx单凭这点可利用的场合就远多于LVS了。<br>2、Nginx对网络稳定性的依赖非常小，理论上能ping通就就能进行负载功能，这个也是它的优势之一；相反LVS对网络稳定性依赖比较大；<br>3、Nginx安装和配置比较简单，测试起来比较方便，日志功能很强大。LVS的配置、测试就要花比较长的时间了，LVS对网络依赖比较大。<br>3、可以承担高负载压力且稳定，在硬件不差的情况下一般能支撑几万次的并发量，负载度比LVS相对小些。<br>4、Nginx可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点，不过其中缺点就是不支持url检测。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而不满。<br>5、Nginx不仅仅是一款优秀的负载均衡器/反向代理软件，它同时也是功能强大的Web应用服务器。LNMP也是近几年非常流行的web架构，在高流量的环境中稳定性也很好。<br>6、Nginx现在作为Web反向加速缓存越来越成熟了，速度比传统的Squid服务器更快，可以考虑用其作为反向代理加速器。<br>7、Nginx可作为中层反向代理使用，这一层面Nginx基本上无对手，唯一可以对比Nginx的就只有lighttpd了，不过lighttpd目前还没有做到Nginx完全的功能，配置也不那么清晰易读，社区资料也远远没Nginx活跃。<br>8、Nginx也可作为静态网页和图片服务器，这方面的性能也无对手。还有Nginx社区非常活跃，第三方模块也很多。</p>
<p>淘宝的前端使用的Tengine就是基于nginx做的二次开发定制版。</p>
<p>Nginx常规的HTTP请求和响应流程图：</p>
<p>nginx</p>
<h3 id="Nginx的缺点是："><a href="#Nginx的缺点是：" class="headerlink" title="Nginx的缺点是："></a>Nginx的缺点是：</h3><p>1、Nginx仅支持http、https和Email协议，适用范围比较小。<br>2、对后端服务器的健康检查，只支持通过端口来检测，不支持通过url来检测。不支持Session的直接保持，但能通过<code>ip_hash</code>来解决。</p>
<h2 id="二、LVS"><a href="#二、LVS" class="headerlink" title="二、LVS"></a>二、LVS</h2><p>使用Linux内核集群实现一个高性能、高可用的负载均衡服务器，它具有很好的可伸缩性（Scalability)、可靠性（Reliability)和可管理性（Manageability)。</p>
<h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p>1、抗负载能力强、工作在网络协议第四层，仅作分发之用，没有流量的产生，这个特点也决定了它在负载均衡软件里的性能最强的，对内存和cpu资源消耗比较低。<br>2、配置性比较低，这是一个缺点也是一个优点，因为没有可太多配置的东西，所以并不需要太多接触，大大减少了人为出错的几率。<br>3、工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案，如LVS+Keepalived，不过在项目实施中用得最多的还是LVS/DR+Keepalived。<br>4、无流量，LVS只分发请求，而流量并不从它本身出去，这点保证了均衡器IO的性能不会收到大流量的影响。<br>5、应用范围比较广，因为LVS工作在4层，所以它几乎可以对所有应用做负载均衡，包括http、数据库、在线聊天室等等。</p>
<p>LVS DR(Direct Routing)模式的网络流程图：</p>
<p>lvs_dr</p>
<h2 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h2><p>1、软件本身不支持正则表达式处理，不能做动静分离；而现在许多网站在这方面都有较强的需求，这个是Nginx/HAProxy+Keepalived的优势所在。<br>2、如果是网站应用比较庞大的话，LVS/DR+Keepalived实施起来就比较复杂了，特别后面有Windows Server的机器的话，实施、配置、维护比较复杂了，相对而言，Nginx/HAProxy+Keepalived简单多了。</p>
<h2 id="三、HAProxy"><a href="#三、HAProxy" class="headerlink" title="三、HAProxy"></a>三、HAProxy</h2><p>###特点</p>
<p>1、HAProxy也是支持虚拟主机的。<br>2、HAProxy的优点能够补充Nginx的一些缺点，比如支持Session的保持，Cookie的引导；同时支持通过获取指定的url来检测后端服务器的状态。<br>3、HAProxy跟LVS类似，本身就只是一款负载均衡软件；单纯从效率上来讲HAProxy会比Nginx有更出色的负载均衡速度，在并发处理上也是优于Nginx的。<br>4、HAProxy支持TCP协议的负载均衡转发，可以对MySQL读进行负载均衡，对后端的MySQL节点进行检测和负载均衡，可以用LVS+Keepalived对MySQL主从做负载均衡。<br>5、HAProxy负载均衡策略非常多，HAProxy的负载均衡算法现在具体有如下8种：<br>① roundrobin，表示轮询；<br>② static-rr，表示根据权重，建议关注；<br>③ leastconn，表示最少连接者先处理，建议关注；<br>④ source，表示根据请求源IP，这个跟Nginx的IP_hash机制类似，我们用其作为解决session问题的一种方法，建议关注；<br>⑤ ri，表示根据请求的URI；<br>⑥ rl_param，表示根据请求的URl参数’balance url_param’ requires an URL parameter name；<br>⑦ hdr(name)，表示根据HTTP请求头来锁定每一次HTTP请求；<br>⑧ rdp-cookie(name)，表示根据据cookie(name)来锁定并哈希每一次TCP请求。</p>
<h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><h3 id="Nginx和LVS对比："><a href="#Nginx和LVS对比：" class="headerlink" title="Nginx和LVS对比："></a>Nginx和LVS对比：</h3><p>1、Nginx工作在网络的7层，所以它可以针对http应用本身来做分流策略，比如针对域名、目录结构等，相比之下LVS并不具备这样的功能，所以Nginx单凭这点可利用的场合就远多于LVS了；但Nginx配置灵活，配置人员易出错。<br>2、Nginx对网络稳定性的依赖较小，理论上只要ping得通，网页访问正常，Nginx就能连得通，这是Nginx的一大优势！Nginx同时还能区分内外网，如果是同时拥有内外网的节点，就相当于单机拥有了备份线路；LVS就比较依赖于网络环境，目前来看服务器在同一网段内并且LVS使用direct方式分流，效果较能得到保证。另外注意，LVS需要向托管商至少申请多一个ip来做Visual IP，貌似是不能用本身的IP来做VIP的。要做好LVS管理员，确实得跟进学习很多有关网络通信方面的知识，就不再是一个HTTP那么简单了。<br>3、Nginx安装和配置比较简单，测试起来也很方便，因为它基本能把错误用日志打印出来。LVS的安装和配置、测试就要花比较长的时间了；LVS对网络依赖比较大，很多时候不能配置成功都是因为网络问题而不是配置问题，出了问题要解决也相应的会麻烦得多。<br>4、Nginx也同样能承受很高负载且稳定，但负载度和稳定度差LVS还有几个等级：Nginx处理所有流量所以受限于机器IO和配置；本身的bug也还是难以避免的。<br>5、Nginx可以检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点。目前LVS中 ldirectd也能支持针对服务器内部的情况来监控，但LVS的原理使其不能重发请求。比如用户正在上传一个文件，而处理该上传的节点刚好在上传过程中出现故障，Nginx会把上传切到另一台服务器重新处理，而LVS就直接断掉了，如果是上传一个很大的文件或者很重要的文件的话，用户可能会因此而恼火。<br>6、Nginx对请求的异步处理可以帮助节点服务器减轻负载，假如使用apache直接对外服务，那么出现很多的窄带链接时apache服务器将会占用大量内存而不能释放，使用多一个Nginx做apache代理的话，这些窄带链接会被Nginx挡住，apache上就不会堆积过多的请求，这样就减少了相当多的资源占用。这点使用squid也有相同的作用，即使squid本身配置为不缓存，对apache还是有很大帮助的。<br>7、Nginx能支持http、https和email（email的功能比较少用），LVS所支持的应用会比Nginx多。在使用上，一般最前端所采取的策略应是LVS，也就是DNS的指向应为LVS均衡器，LVS的优点令它非常适合做这个任务。重要的ip地址，最好交由LVS托管，比如数据库的 ip、webservice服务器的ip等等，这些ip地址随着时间推移，使用面会越来越大，如果更换ip则故障会接踵而至。所以将这些重要ip交给LVS托管是最为稳妥的，这样做的唯一缺点是需要的VIP数量会比较多。Nginx可作为LVS节点机器使用，一是可以利用Nginx的功能，二是可以利用Nginx的性能。当然这一层面也可以直接使用squid，squid的功能方面就比Nginx弱不少了，性能上也有所逊色于Nginx。Nginx也可作为中层代理使用，这一层面Nginx基本上无对手，唯一可以撼动Nginx的就只有lighttpd了，不过lighttpd目前还没有能做到 Nginx完全的功能，配置也不那么清晰易读。另外，中层代理的IP也是重要的，所以中层代理也拥有一个VIP和LVS是最完美的方案了。具体的应用还得具体分析，如果是比较小的网站（日PV小于1000万），用Nginx就完全可以了，如果机器也不少，可以用DNS轮询，LVS所耗费的机器还是比较多的；大型网站或者重要的服务，机器不发愁的时候，要多多考虑利用LVS。</p>
<p>现在对网络负载均衡的使用是随着网站规模的提升根据不同的阶段来使用不同的技术：</p>
<p>第一阶段：利用Nginx或HAProxy进行单点的负载均衡，这一阶段服务器规模刚脱离开单服务器、单数据库的模式，需要一定的负载均衡，但是仍然规模较小没有专业的维护团队来进行维护，也没有需要进行大规模的网站部署。这样利用Nginx或HAproxy就是第一选择，此时这些东西上手快， 配置容易，在七层之上利用HTTP协议就可以。这时是第一选择。</p>
<p>第二阶段：随着网络服务进一步扩大，这时单点的Nginx已经不能满足，这时使用LVS或者商用Array就是首要选择，Nginx此时就作为LVS或者Array的节点来使用，具体LVS或Array的是选择是根据公司规模和预算来选择，Array的应用交付功能非常强大，本人在某项目中使用过，性价比也远高于F5，商用首选！但是一般来说这阶段相关人才跟不上业务的提升，所以购买商业负载均衡已经成为了必经之路。</p>
<p>第三阶段：这时网络服务已经成为主流产品，此时随着公司知名度也进一步扩展，相关人才的能力以及数量也随之提升，这时无论从开发适合自身产品的定制，以及降低成本来讲开源的LVS，已经成为首选，这时LVS会成为主流。<br>最终形成比较理想的基本架构为：Array/LVS — Nginx/Haproxy — Squid/Varnish — AppServer。</p>
]]></content>
    
    <summary type="html">
    
      Nginx/LVS/HAProxy负载均衡软件的优缺点详解
    
    </summary>
    
      <category term="负载均衡" scheme="http://jishusuishouji.github.io/categories/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
      <category term="负载均衡" scheme="http://jishusuishouji.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java集群--大型网站是怎样解决多用户高并发访问的</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/jiqun/Java%E9%9B%86%E7%BE%A4--%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%98%AF%E6%80%8E%E6%A0%B7%E8%A7%A3%E5%86%B3%E5%A4%9A%E7%94%A8%E6%88%B7%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%9A%84/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/jiqun/Java集群--大型网站是怎样解决多用户高并发访问的/</id>
    <published>2017-04-07T00:06:33.000Z</published>
    <updated>2017-04-07T00:13:07.645Z</updated>
    
    <content type="html"><![CDATA[<p>为了解决大型网站的访问量大、并发量高、海量数据的问题，一般会考虑业务拆分和分布式部署。可以把那些关联不太大的业务独立出来，部署到不同的机器上，从而实现大规模的分布式系统。但这之中也有一个问题，那就是用户如何选择相应的机器的问题，这也被称为访问统一入口问题，而解决的方法是我们可以在集群机器的前面增加负载均衡设备，实现流量分发。<br><img src="/img/负载均衡.png" alt="负载均衡"><br>负载均衡:将负载（工作任务、访问请求等）进行平衡、分摊到多个操作单元（服务器、组件等）上进行执行，是解决高性能，单点故障（高可用，如果你是单机版网络，一旦服务器挂掉了，那么用户就无法请求了，但对于集群来说，一台服务器挂掉了，负载均衡器会把用户的请求发送给其他的服务器进行处理），扩展性（这里主要是指水平伸缩）的终极解决方案。<br>负载均衡设备为Nginx(F5太贵了，不过比较稳定)，这是一款轻量级的Web服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，具有占用内存少、并发能力强等，中国大陆使用nginx网站用户有：百度、网易、新浪、腾讯等。<br>1.nginx的负载均衡配置中默认是采用轮询的方式，这种方式中，每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除，但存在各个服务器的session共享问题。<br>2.另外一种方式是ip_hash:每个请求按访问的ip的hash结果分配，如果访问的IP是固定的，那么在正常情况下，该用户的请求都会分配到后台的同一台服务器去处理，但是如果用户每次请求的IP都不同呢？所以这种方式也同1的方式一样都存在这么一个问题：session在各个服务器上的共享问题。<br>3.如果集群中的服务器的性能不一，可以通过配置各个服务器的权值来实现资源利用率的最大化，即性能好的优先选择</p>
<p>也许你会问，既然IP可能变化，那么用户用页面请求时的cookie的ID应该是确定的吧！那么我们可以用cookie_id来进行hash，然后在通过负载均衡器分发到对应的服务器上，这样就可以解决session问题了，其实当初本人也有想到这个方案，但最后本人也放弃这个方案了，因为是根据cookid_id确实可以把该用户的请求唯一的分发到那台独一无二的服务器上，那如果这台服务器挂掉了，那么根据这种分发策略，岂不是在这服务器上请求资源的用户都不能访问了。<br>解决服务器共享session问题：使用redis来共享各个服务器的session，并同时通过redis来缓存一些常用的资源，加快用户获得请求资源的速度（memcache不能做到持久化，这样这台服务器一挂掉，那么所有的资源也都没有了）。</p>
<p>进行集群部署，最好配上数据库的主从部署，因为如果在集群中只分配一个数据库服务器，那么这个系统的瓶颈将会出现在数据库的操作上，虽然redis能减轻这种负担，但对于数据量大的还是有一定影响的，而且数据库的主从部署也可以防止因某个数据库服务器的挂掉而丢失用户的信息。</p>
]]></content>
    
    <summary type="html">
    
      Java集群--大型网站是怎样解决多用户高并发访问的
    
    </summary>
    
      <category term="集群" scheme="http://jishusuishouji.github.io/categories/%E9%9B%86%E7%BE%A4/"/>
    
    
      <category term="集群" scheme="http://jishusuishouji.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>浅谈web应用的负载均衡、集群、高可用(HA)解决方案</title>
    <link href="http://jishusuishouji.github.io/2017/04/07/web/%E6%B5%85%E8%B0%88web%E5%BA%94%E7%94%A8%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E3%80%81%E9%9B%86%E7%BE%A4%E3%80%81%E9%AB%98%E5%8F%AF%E7%94%A8_HA_%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://jishusuishouji.github.io/2017/04/07/web/浅谈web应用的负载均衡、集群、高可用_HA_解决方案/</id>
    <published>2017-04-06T23:31:58.000Z</published>
    <updated>2017-04-07T00:05:49.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、几个组件"><a href="#1、几个组件" class="headerlink" title="1、几个组件"></a>1、几个组件</h2><h3 id="1-1、apache"><a href="#1-1、apache" class="headerlink" title="1.1、apache"></a>1.1、apache</h3><p>Apache软件基金会开放源代码的跨平台网页服务器，属于老牌的web服务器了，支持基于Ip或者域名的虚拟主机，支持代理服务器，支持安全Socket层(SSL)等等，目前主要用它做静态资源服务器，也可以做代理服务器转发请求(如：图片链等)，结合tomcat等servlet容器。</p>
<h3 id="1-2、ngnix"><a href="#1-2、ngnix" class="headerlink" title="1.2、ngnix"></a>1.2、ngnix</h3><p>俄罗斯人开发的一个高性能的HTTP和反向代理服务器。由于Nginx超越Apache的高性能和稳定性，使得国内使用Nginx作为Web服务器的网站也越来越多，其中包括新浪博客、新浪播客、网易新闻、腾讯网、搜狐博客等门户网站频道等，在3w以上的高并发环境下，ngnix处理能力相当于apache的10倍。</p>
<h3 id="1-3、lvs"><a href="#1-3、lvs" class="headerlink" title="1.3、lvs"></a>1.3、lvs</h3><p>Linux Virtual Server的简写，意即Linux虚拟服务器，是一个虚拟的服务器集群系统。由毕业于国防科技大学的章文嵩博士于1998年5月创立，可以实现LINUX平台下的简单负载均衡。</p>
<h3 id="1-4、HAProxy"><a href="#1-4、HAProxy" class="headerlink" title="1.4、HAProxy"></a>1.4、HAProxy</h3><p>HAProxy提供高可用性、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。HAProxy特别适用于那些负载特大的web站点， 这些站点通常又需要会话保持或七层处理。HAProxy运行在当前的硬件上，完全可以支持数以万计的并发连接。并且它的运行模式使得它可以很简单安全地整合进您当前的架构中，同时可以保护你的web服务器不被暴露到网络上.</p>
<h3 id="1-5、keepalived"><a href="#1-5、keepalived" class="headerlink" title="1.5、keepalived"></a>1.5、keepalived</h3><p>可以实现web服务器的高可用(HA high availably)。它可以检测web服务器的工作状态，如果该服务器出现故障被检测到，将其剔除服务器群中，直至正常工作后，keepalive会自动检测到并加入到服务器群里面。实现主备服务器发生故障时ip瞬时无缝交接。它是LVS集群节点健康检测的一个用户空间守护进程，也是LVS的引导故障转移模块（director failover）。Keepalived守护进程可以检查LVS池的状态。如果LVS服务器池当中的某一个服务器宕机了。keepalived会通过一个setsockopt呼叫通知内核将这个节点从LVS拓扑图中移除。</p>
<h3 id="1-6、memcached"><a href="#1-6、memcached" class="headerlink" title="1.6、memcached"></a>1.6、memcached</h3><p>一个高性能分布式内存对象缓存系统。当初是Danga Interactive为了LiveJournal快速发展开发的系统，用于对业务查询数据缓存，减轻数据库的负载。其守护进程(daemon)是用C写的，但是客户端支持几乎所有语言(客户端基本上有3种版本[memcache client for java;spymemcached;xMecache])，服务端和客户端通过简单的协议通信；在memcached里面缓存的数据必须序列化。</p>
<h3 id="1-7、terracotta"><a href="#1-7、terracotta" class="headerlink" title="1.7、terracotta"></a>1.7、terracotta</h3><p>是一款由美国Terracotta公司开发的著名开源Java集群平台。它在JVM与Java应用之间实现了一个专门处理集群功能的抽象层，允许用户在不改变系统代码的情况下实现java应用的集群。支持数据的持久化、session的复制以及高可用(HA)。</p>
<h2 id="2、关键术语"><a href="#2、关键术语" class="headerlink" title="2、关键术语"></a>2、关键术语</h2><h3 id="2-1、负载均衡（load-balance）"><a href="#2-1、负载均衡（load-balance）" class="headerlink" title="2.1、负载均衡（load balance）"></a>2.1、负载均衡（load balance）</h3><p>如何处理高并发带来的系统性能问题，最终大家都会使用负载均衡机制。它是根据某种负载策略把请求分发到集群中的每一台服务器上，让整个服务器群来处理网站的请求。<br>公司比较有钱的，可以购买专门负责负载均衡的硬件（如：F5）,效果肯定会很好。对于大部分公司，会选择廉价有效的方法扩展整个系统的架构，来增加服务器的吞吐量和处理能力，以及承载能力。</p>
<h3 id="2-2、集群（Cluster）"><a href="#2-2、集群（Cluster）" class="headerlink" title="2.2、集群（Cluster）"></a>2.2、集群（Cluster）</h3><p>用N台服务器构成一个松耦合的多处理器系统(对外来说，他们就是一个服务器)，它们之间通过网络实现通信。让N台服务器之间相互协作，共同承载一个网站的请求压力。</p>
<h3 id="2-3、高可用（HA）"><a href="#2-3、高可用（HA）" class="headerlink" title="2.3、高可用（HA）"></a>2.3、高可用（HA）</h3><p>在集群服务器架构中，当主服务器故障时，备份服务器能够自动接管主服务器的工作，并及时切换过去，以实现对用户的不间断服务。ps：这里我感觉它跟故障转移(failover)是一个意思。</p>
<h3 id="2-4、session复制-共享"><a href="#2-4、session复制-共享" class="headerlink" title="2.4、session复制/共享"></a>2.4、session复制/共享</h3><p>在访问系统的会话过程中，用户登录系统后，不管访问系统的任何资源地址都不需要重复登录，这里面servlet容易保存了该用户的会话(session)。如果两个tomcat(A、B)提供集群服务时候，用户在A-tomcat上登录，接下来的请求web服务器根据策略分发到B-tomcat，因为B-tomcat没有保存用户的会话(session)信息，不知道其登录，会跳转到登录界面。<br>这时候我们需要让B-tomcat也保存有A-tomcat的会话，我们可以使用tomcat的session复制实现或者通过其他手段让session共享。</p>
<h2 id="3、常用web集群"><a href="#3、常用web集群" class="headerlink" title="3、常用web集群"></a>3、常用web集群</h2><h3 id="3-1、tomcat集群方案"><a href="#3-1、tomcat集群方案" class="headerlink" title="3.1、tomcat集群方案"></a>3.1、tomcat集群方案</h3><p>apache+tomcat；ngnix+tomcat；lvs+ngnix+tomcat。(lvs负责集群调度，nginx负责静态文件处理，tomcat负责动态文件处理[最优选择])。 以apache+tomcat集群为例：<br>1、他们之间的通信有三种方式：ajp_proxy、mod_jk链接器、http_proxy。<br>2、apache的分发策略有4种。权重(默认)、流量(bytraffic)、请求次数(byRequests)、繁忙程度(byBusyness根据活跃请求数的多少)<br>3、apache支持stickysession(粘性session)，即为：访问用户访问了A-tomcat，那么他的所有请求都会转发到A-tomcat，而不会到B-tomcat。[这样的负载均衡效果不好，适用于小型网站，下面说非粘性session]<br>4、它们之间的架构如图1：<br><img src="/img/apache+tomcat.jpg" alt="apache+tomcat"></p>
<p>问题1：只有一个web服务器，明显的单点故障。如果该apache出现问题，整个网站就会瘫痪。</p>
<h3 id="3-2、session复制"><a href="#3-2、session复制" class="headerlink" title="3.2、session复制"></a>3.2、session复制</h3><p>如果不采用stickysession(粘性session)，那么我们可以采用tomcat的session复制使所有节点tomcat的会话相同，tomcat使用组播技术，只要集群中一个tomcat节点的session发生改变，会广播通知所有tomcat节点发生改变。</p>
<p>问题2：据网友测试，当tomcat节点数达到4个以上时候，集群性能呈线性下滑；另外当用户访问量大到一定程度，会话内容随之增多，tomcat节点相互之间通信产生大量的网络消耗，产生网络阻塞，整个集群的吞吐量不能再上升。</p>
<h2 id="4、高可用-HA-和session共享-解决上面提到的两个问题"><a href="#4、高可用-HA-和session共享-解决上面提到的两个问题" class="headerlink" title="4、高可用(HA)和session共享(解决上面提到的两个问题)"></a>4、高可用(HA)和session共享(解决上面提到的两个问题)</h2><h3 id="4-1、使用lvs-keepalive实现集群高可用，达到更健壮的LB"><a href="#4-1、使用lvs-keepalive实现集群高可用，达到更健壮的LB" class="headerlink" title="4.1、使用lvs+keepalive实现集群高可用，达到更健壮的LB"></a>4.1、使用lvs+keepalive实现集群高可用，达到更健壮的LB</h3><p>可以前端使用lvs来做负载均衡，根据lvs的8种调度算法(可设置)，分发请求到对应的web服务器集群上。lvs做双机热备，通过keepalived模块能够达到故障自动转移到备份服务器，不间断提供服务，结构如图2：</p>
<p> <img src="/img/使用lvs+keepalive实现集群高可用，达到更健壮的LB.jpg" alt="使用lvs+keepalive实现集群高可用，达到更健壮的LB"></p>
<p> 说明：据查询了解，一般在WEB端使用的负载均衡比较多的是HAProxy+keepalived+nginx；数据库mysql集群使用Lvs+keepalived+mysql实现。因为HAProxy和nginx一样是工作在网络7层之上，并且前者弥补了nginx的一些缺点如session的保持，cookie的引导等，且它本身是个负责均衡软件，处理负载均衡上面必然优于nginx；lvs比较笨重，对于比较庞大的网络应用实施比较复杂，虽然它运行在网络4层之上，仅做分发没有流量产生，但是它不能做正则处理也不能也不能做动静分离，所以一般用lvs+keepalived或heatbeat做数据库层的负载均衡。</p>
<h3 id="4-2、使用terracotta或者memcached使session共享"><a href="#4-2、使用terracotta或者memcached使session共享" class="headerlink" title="4.2、使用terracotta或者memcached使session共享"></a>4.2、使用terracotta或者memcached使session共享</h3><h4 id="4-2-1、terracotta是jvm级别的session共享"><a href="#4-2-1、terracotta是jvm级别的session共享" class="headerlink" title="4.2.1、terracotta是jvm级别的session共享"></a>4.2.1、terracotta是jvm级别的session共享</h4><p>它基本原理是对于集群间共享的数据，当在一个节点发生变化的时候，Terracotta只把变化的部分发送给Terracotta服务器，然后由服务器把它转发给真正需要这个数据的节点，并且共享的数据对象不需要序列化。</p>
<h3 id="4-2-2、通过memcached实现内存级session共享"><a href="#4-2-2、通过memcached实现内存级session共享" class="headerlink" title="4.2.2、通过memcached实现内存级session共享"></a>4.2.2、通过memcached实现内存级session共享</h3><p>通过memcached-session-manager（msm）插件，通过tomcat上一定的配置，即可实现把session存储到memcached服务器上。注意：tomcat支持tomcat6+，并且memcached可以支持分布式内存，msm同时支持黏性session（sticky sessions）或者非黏性session（non-sticky sessions）两种模式，在memcached内存中共享的对象需要序列化。结构如图3：<br><img src="/img/通过memcached实现内存级session共享.jpg" alt="通过memcached实现内存级session共享"></p>
<p>通过一定的配置，可以实现故障转移(只支持对非粘性session)。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;Context&gt;    </div><div class="line">      ...    </div><div class="line">      &lt;Manager className=&quot;de.javakaffee.web.msm.MemcachedBackupSessionManager&quot;    </div><div class="line">        memcachedNodes=&quot;n1:host1.yourdomain.com:11211,n2:host2.yourdomain.com:11211&quot;    </div><div class="line">        failoverNodes=&quot;n1&quot;    </div><div class="line">        requestUriIgnorePattern=&quot;.*\.(ico|png|gif|jpg|css|js)$&quot;    </div><div class="line">        transcoderFactoryClass=&quot;de.javakaffee.web.msm.serializer.kryo.KryoTranscoderFactory&quot;    </div><div class="line">        /&gt;    </div><div class="line">&lt;/Context&gt;</div></pre></td></tr></table></figure></p>
<p>说明：<code>failoverNodes</code>：故障转移节点，对非粘性session不可用。属性<code>failoverNodes=&quot;n1&quot;</code>的作用是告诉msm最好是把session保存在memcached “n2”节点上，只有在n2节点不可用的情况下才把session保存在n1节点。这样即使host2上的tomcat宕机，仍然可以通过host1上的tomcat访问存放在memcached “n1” 节点中的session。</p>
<h3 id="4-2-3、其他方案"><a href="#4-2-3、其他方案" class="headerlink" title="4.2.3、其他方案"></a>4.2.3、其他方案</h3><p>通过cookie保存用户信息(一般是登录信息)，每一个请求到达web应用的时候，web应用从cookie中取出数据进行处理（这里尽量对cookie做加密处理）；<br>另外一种是把用户信息的关键属性保存到数据库，这样就不需要session了。请求过来从数据库查询关键属性数据，做相应处理。缺点：加大了数据库的负载，使数据库成为集群的瓶颈。</p>
]]></content>
    
    <summary type="html">
    
      浅谈web应用的负载均衡、集群、高可用(HA)解决方案
    
    </summary>
    
      <category term="负载均衡" scheme="http://jishusuishouji.github.io/categories/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    
      <category term="负载均衡" scheme="http://jishusuishouji.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
      <category term="集群" scheme="http://jishusuishouji.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
      <category term="高可用" scheme="http://jishusuishouji.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>js如何把相对路基的url转换为绝对路径</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/js/js%E5%A6%82%E4%BD%95%E6%8A%8A%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%9F%BA%E7%9A%84url%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/js/js如何把相对路基的url转换为绝对路径/</id>
    <published>2017-04-06T13:50:53.000Z</published>
    <updated>2017-04-06T13:52:11.631Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var absolutePath = function(href) &#123;</div><div class="line">    var link = document.createElement(&quot;a&quot;);</div><div class="line">    link.href = href;</div><div class="line">    return (link.protocol+&quot;//&quot;+link.host+link.pathname+link.search+link.hash);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      js如何把相对路基的url转换为绝对路径
    
    </summary>
    
      <category term="javascript" scheme="http://jishusuishouji.github.io/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://jishusuishouji.github.io/tags/javascript/"/>
    
      <category term="js" scheme="http://jishusuishouji.github.io/tags/js/"/>
    
      <category term="相对路径" scheme="http://jishusuishouji.github.io/tags/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    
      <category term="绝对路径" scheme="http://jishusuishouji.github.io/tags/%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
    
  </entry>
  
  <entry>
    <title>设计模式六大原则</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/shejiyuanze/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/shejiyuanze/设计模式六大原则/</id>
    <published>2017-04-05T23:43:16.000Z</published>
    <updated>2017-04-06T23:28:59.846Z</updated>
    
    <content type="html"><![CDATA[<p>开闭原则<br>单一职责原则<br>迪米特原则<br>面向对象的： 接口隔离原则<br>             依赖倒转原则<br>             里氏替换原则</p>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><p>定义：<strong>不要存在多于一个导致类变更的原因</strong>。</p>
<p>问题由来：类<code>T</code>负责两个不同的职责：职责<code>P1</code>，职责<code>P2</code>。当由于职责<code>P1</code>需求发生改变而需要修改类<code>T</code>时，有可能会导致原本运行正常的职责<code>P2</code>功能发生故障。</p>
<p>解决方案：遵循单一职责原则。分别建立两个类<code>T1</code>、<code>T2</code>，使<code>T1</code>完成职责<code>P1</code>功能，<code>T2</code>完成职责<code>P2</code>功能。这样，当修改类<code>T1</code>时，不会使职责P2发生故障风险；同理，当修改<code>T2</code>时，也不会使职责P1发生故障风险。</p>
<p>遵循单一职责原则可以避免因为修改了一个功能导致其他功能发生异常。</p>
<h3 id="职责扩散"><a href="#职责扩散" class="headerlink" title="职责扩散"></a>职责扩散</h3><p>职责扩散：因为某种原因，职责P被分化为粒度更细的职责P1和P2。<br>比如：类<code>T</code>只负责一个职责P，这样设计是符合单一职责原则的。后来由于需求变更了，需要将职责P细分为粒度更细的职责P1，P2，这时如果要使程序遵循单一职责原则，需要将类<code>T</code>分解为两个类<code>T1</code>和<code>T2</code>，分别负责P1、P2两个职责。但是在程序已经写好的情况下，这样做简直太费时间了。所以，简单的修改类<code>T</code>，用它来负责两个职责是一个比较不错的选择，虽然这样做有悖于单一职责原则。（这样做的风险在于职责扩散的不确定性，因为我们不会想到这个职责P，在未来可能会扩散为P1，P2，P3，P4……Pn。所以记住，在职责扩散到我们无法控制的程度之前，立刻对代码进行重构。）</p>
<h3 id="职责扩散例子说明，用一个类描述动物呼吸这个场景："><a href="#职责扩散例子说明，用一个类描述动物呼吸这个场景：" class="headerlink" title="职责扩散例子说明，用一个类描述动物呼吸这个场景："></a>职责扩散例子说明，用一个类描述动物呼吸这个场景：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Animal&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸空气&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal animal = new Animal();</div><div class="line">        animal.breathe(&quot;牛&quot;);</div><div class="line">        animal.breathe(&quot;羊&quot;);</div><div class="line">        animal.breathe(&quot;猪&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">牛呼吸空气</div><div class="line">羊呼吸空气</div><div class="line">猪呼吸空气</div></pre></td></tr></table></figure>
<p>程序上线后，发现问题了，并不是所有的动物都呼吸空气的，比如鱼就是呼吸水的。修改时如果遵循单一职责原则，需要将<code>Animal</code>类细分为陆生动物类<code>Terrestrial</code>，水生动物<code>Aquatic</code>，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Terrestrial&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸空气&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Aquatic&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸水&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Terrestrial terrestrial = new Terrestrial();</div><div class="line">        terrestrial.breathe(&quot;牛&quot;);</div><div class="line">        terrestrial.breathe(&quot;羊&quot;);</div><div class="line">        terrestrial.breathe(&quot;猪&quot;);</div><div class="line">        </div><div class="line">        Aquatic aquatic = new Aquatic();</div><div class="line">        aquatic.breathe(&quot;鱼&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">牛呼吸空气</div><div class="line">羊呼吸空气</div><div class="line">猪呼吸空气</div><div class="line">鱼呼吸水</div></pre></td></tr></table></figure></p>
<p>我们会发现如果这样修改花销是很大的，除了将原来的类分解之外，还需要修改客户端。而直接修改类<code>Animal</code>来达成目的虽然违背了单一职责原则，但花销却小得多，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Animal&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        if(&quot;鱼&quot;.equals(animal))&#123;</div><div class="line">            System.out.println(animal+&quot;呼吸水&quot;);</div><div class="line">        &#125;else&#123;</div><div class="line">            System.out.println(animal+&quot;呼吸空气&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal animal = new Animal();</div><div class="line">        animal.breathe(&quot;牛&quot;);</div><div class="line">        animal.breathe(&quot;羊&quot;);</div><div class="line">        animal.breathe(&quot;猪&quot;);</div><div class="line">        animal.breathe(&quot;鱼&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这种修改方式要简单得多。但是却存在着隐患：有一天需要将鱼分为呼吸淡水的鱼和呼吸海水的鱼，则又需要修改<code>Animal</code>类的<code>breathe</code>方法，而对原有代码的修改会对调用“猪”“牛”“羊”等相关功能带来风险，也许某一天你会发现程序运行的结果变为“牛呼吸水”了。(不要认为这是不可能的，这是绝对可能的，修改代码本来就应该认为是极其危险的，你可以扩展但是最好不要修改，修改了就一定要好好测试！)这种修改方式直接在代码级别上违背了单一职责原则，虽然修改起来最简单，但隐患却是最大的。还有一种修改方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class Animal&#123;</div><div class="line">    public void breathe(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸空气&quot;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void breathe2(String animal)&#123;</div><div class="line">        System.out.println(animal+&quot;呼吸水&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Animal animal = new Animal();</div><div class="line">        animal.breathe(&quot;牛&quot;);</div><div class="line">        animal.breathe(&quot;羊&quot;);</div><div class="line">        animal.breathe(&quot;猪&quot;);</div><div class="line">        animal.breathe2(&quot;鱼&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，这种修改方式没有改动原来的方法，而是在类中新加了一个方法，这样虽然也违背了单一职责原则，但在方法级别上却是符合单一职责原则的，因为它并没有动原方法的代码。这三种方式各有优缺点，那么在实际编程中，采用哪一种呢？这需要根据实际情况来确定。原则是：只有逻辑足够简单，才可以在代码级别上违反单一职责原则；只有类中方法数量足够少，才可以在方法级别上违反单一职责原则；</p>
<p>例如本文所举的这个例子，它太简单了，它只有一个方法，所以，无论是在代码级别上违反单一职责原则，还是在方法级别上违反，都不会造成太大的影响。实际应用中的类要复杂得多，一旦发生职责扩散而需要修改类时，除非这个类本身非常简单，否则还是遵循单一职责原则的好。</p>
<h3 id="遵循单一职责原的优点有："><a href="#遵循单一职责原的优点有：" class="headerlink" title="遵循单一职责原的优点有："></a>遵循单一职责原的优点有：</h3><ul>
<li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多；</li>
<li>提高类的可读性，提高系统的可维护性；</li>
<li>降低变更引起的风险，变更是必然的，如果单一职责原则遵守得好，当修改一个功能时，可以显著降低对其他功能的影响。</li>
</ul>
<p>需要说明的一点是单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>在1988年麻省理工学院的一位姓里的女士（Barbara Liskov）提出来的。</p>
<p>定义1：如果对每一个类型为<code>T1</code>的对象<code>o1</code>，都有类型为<code>T2</code>的对象<code>o2</code>,使得在程序中所有的对象<code>o1</code>都代换成<code>o2</code>时，程序P的行为没有发生变化，那么类型<code>T2</code>是类型<code>T1</code>的子类型。</p>
<p>定义2：所有引用基类的地方必须能透明地使用其子类的对象。</p>
<p>问题由来：有一功能P1，由类<code>A</code>完成。现需要将功能P1进行扩展，扩展后的功能为P，其中P由原有功能P1与新功能P2组成。新功能P由类<code>A</code>的子类<code>B</code>来完成，则子类<code>B</code>在完成新功能P2的同时，有可能会导致原有功能P1发生故障。</p>
<p>解决方案：当使用继承时，遵循里氏替换原则。类<code>B</code>继承类<code>A</code>时，除添加新的方法完成新增功能P2外，尽量不要重写父类<code>A</code>的方法，也尽量不要重载父类<code>A</code>的方法。</p>
<p>继承包含这样一层含义：父类中凡是已经实现好的方法（相对于抽象方法而言），实际上是在设定一系列的规范和契约，虽然它不强制要求所有的子类必须遵从这些契约，但是如果子类对这些非抽象方法任意修改，就会对整个继承体系造成破坏。而里氏替换原则就是表达了这一层含义。</p>
<p>继承作为面向对象三大特性之一，在给程序设计带来巨大便利的同时，也带来了弊端。比如使用继承会给程序带来侵入性，程序的可移植性降低，增加了对象间的耦合性，如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，并且父类修改后，所有涉及到子类的功能都有可能会产生故障。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>一个两数相减的功能由类A来负责。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">    public int func1(int a, int b)&#123;</div><div class="line">        return a-b;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        A a = new A();</div><div class="line">        System.out.println(&quot;100-50=&quot;+a.func1(100, 50));</div><div class="line">        System.out.println(&quot;100-80=&quot;+a.func1(100, 80));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">100-50=50</div><div class="line"></div><div class="line">100-80=20</div></pre></td></tr></table></figure></p>
<p>后来，需要增加一个新的功能：完成两数相加，然后再与100求和，由类<code>B</code>来负责。即类<code>B</code>需要完成两个功能：</p>
<ul>
<li>两数相减。</li>
<li>两数相加，然后再加100。</li>
</ul>
<p>由于类<code>A</code>已经实现了第一个功能，所以类<code>B</code>继承类<code>A</code>后，只需要再完成第二个功能就可以了，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class B extends A&#123;</div><div class="line">    public int func1(int a, int b)&#123;</div><div class="line">        return a+b;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public int func2(int a, int b)&#123;</div><div class="line">        return func1(a,b)+100;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        B b = new B();</div><div class="line">        System.out.println(&quot;100-50=&quot;+b.func1(100, 50));</div><div class="line">        System.out.println(&quot;100-80=&quot;+b.func1(100, 80));</div><div class="line">        System.out.println(&quot;100+20+100=&quot;+b.func2(100, 20));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>类<code>B</code>完成后，运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">100-50=150</div><div class="line">100-80=180</div><div class="line">100+20+100=220</div></pre></td></tr></table></figure></p>
<p>我们发现原本运行正常的相减功能发生了错误。原因就是类<code>B</code>在给方法起名时无意中重写了父类的方法，造成所有运行相减功能的代码全部调用了类<code>B</code>重写后的方法，造成原本运行正常的功能出现了错误。在本例中，引用基类<code>A</code>完成的功能，换成子类<code>B</code>之后，发生了异常。在实际编程中，我们常常会通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的几率非常大。如果非要重写父类的方法，比较通用的做法是：原来的父类和子类都继承一个更通俗的基类，原有的继承关系去掉，采用依赖、聚合，组合等关系代替。</p>
<p>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。它包含以下4层含义：</p>
<ul>
<li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li>
<li>子类中可以增加自己特有的方法。</li>
<li>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</li>
<li>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</li>
<li>看上去很不可思议，因为我们会发现在自己编程中常常会违反里氏替换原则，程序照样跑的好好的。所以大家都会产生这样的疑问，假如我非要不遵循里氏替换原则会有什么后果？</li>
</ul>
<p>后果就是：你写的代码出问题的几率将会大大增加。</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>定义：<br>高层模块不应该依赖低层模块，二者都应该依赖其抽象；<br>抽象不应该依赖细节；细节应该依赖抽象。</p>
<p>问题由来：类<code>A</code>直接依赖类<code>B</code>，假如要将类<code>A</code>改为依赖类<code>C</code>，则必须通过修改类<code>A</code>的代码来达成。这种场景下，类<code>A</code>一般是高层模块，负责复杂的业务逻辑；类<code>B</code>和类<code>C</code>是低层模块，负责基本的原子操作；假如修改类<code>A</code>，会给程序带来不必要的风险。</p>
<p>解决方案：将类<code>A</code>修改为依赖接口<code>I</code>，类<code>B</code>和类<code>C</code>各自实现接口<code>I</code>，类<code>A</code>通过接口<code>I</code>间接与类<code>B</code>或者类<code>C</code>发生联系，则会大大降低修改类<code>A</code>的几率。</p>
<p>依赖倒置原则基于这样一个事实：<strong>相对于细节的多变性，抽象的东西要稳定得多。</strong>以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定得多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把细节的任务交给他们的实现类去完成。</p>
<p>依赖倒置原则的核心思想是面向接口编程。<br>Spring Ioc的好处在小项目是体会不到的，当你的项目大了，你就能体会到了。比如有一个项目有30多个maven子模块，在某个子模块中你根本就不知道服务层注入的到底是那个对象，你只知道那些接口，这样接口的实现可以随意变动，另一个人不会影响到你。</p>
<p>场景是这样的，母亲给孩子讲故事，只要给她一本书，她就可以照着书给孩子讲故事了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Book&#123;</div><div class="line">    public String getContent()&#123;</div><div class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Mother&#123;</div><div class="line">    public void narrate(Book book)&#123;</div><div class="line">        System.out.println(&quot;妈妈开始讲故事&quot;);</div><div class="line">        System.out.println(book.getContent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Mother mother = new Mother();</div><div class="line">        mother.narrate(new Book());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">妈妈开始讲故事</div><div class="line">很久很久以前有一个阿拉伯的故事……</div></pre></td></tr></table></figure></p>
<p>运行良好，假如有一天，需求变成这样：不是给书而是给一份报纸，让这位母亲讲一下报纸上的故事，报纸的代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Newspaper&#123;</div><div class="line">    public String getContent()&#123;</div><div class="line">        return &quot;林书豪38+7领导尼克斯击败湖人……&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这位母亲却办不到，因为她居然不会读报纸上的故事，这太荒唐了，只是将书换成报纸，居然必须要修改<code>Mother</code>才能读。假如以后需求换成杂志呢？换成网页呢？还要不断地修改<code>Mother</code>，这显然不是好的设计。原因就是<code>Mother</code>与<code>Book</code>之间的耦合性太高了，必须降低他们之间的耦合度才行。</p>
<p>我们引入一个抽象的接口<code>IReader</code>。读物，只要是带字的都属于读物：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">interface IReader&#123;</div><div class="line">    public String getContent();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>Mother</code>类与接口<code>IReader</code>发生依赖关系，而<code>Book</code>和<code>Newspaper</code>都属于读物的范畴，他们各自都去实现<code>IReader</code>接口，这样就符合依赖倒置原则了，代码修改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Newspaper implements IReader &#123;</div><div class="line">    public String getContent()&#123;</div><div class="line">        return &quot;林书豪17+9助尼克斯击败老鹰……&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">class Book implements IReader&#123;</div><div class="line">    public String getContent()&#123;</div><div class="line">        return &quot;很久很久以前有一个阿拉伯的故事……&quot;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class Mother&#123;</div><div class="line">    public void narrate(IReader reader)&#123;</div><div class="line">        System.out.println(&quot;妈妈开始讲故事&quot;);</div><div class="line">        System.out.println(reader.getContent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        Mother mother = new Mother();</div><div class="line">        mother.narrate(new Book());</div><div class="line">        mother.narrate(new Newspaper());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">妈妈开始讲故事</div><div class="line">很久很久以前有一个阿拉伯的故事……</div><div class="line">妈妈开始讲故事</div><div class="line">林书豪17+9助尼克斯击败老鹰……</div></pre></td></tr></table></figure></p>
<p>这样修改后，无论以后怎样扩展<code>Client</code>类，都不需要再修改<code>Mother</code>类了。这只是一个简单的例子，实际情况中，代表高层模块的<code>Mother</code>类将负责完成主要的业务逻辑，一旦需要对它进行修改，引入错误的风险极大。所以遵循依赖倒置原则可以降低类之间的耦合性，提高系统的稳定性，降低修改程序造成的风险。</p>
<p>采用依赖倒置原则给多人并行开发带来了极大的便利，比如上例中，原本<code>Mother</code>类与<code>Book</code>类直接耦合时，<code>Mother</code>类必须等<code>Book</code>类编码完成后才可以进行编码，因为<code>Mother</code>类依赖于<code>Book</code>类。修改后的程序则可以同时开工，互不影响，因为<code>Mother</code>与<code>Book</code>类一点关系也没有。参与协作开发的人越多、项目越庞大，采用依赖导致原则的意义就越重大。现在很流行的TDD开发模式就是依赖倒置原则最成功的应用。</p>
<p>传递依赖关系有三种方式，以上的例子中使用的方法是<strong>接口传递</strong>，另外还有两种传递方式：<strong>构造方法传递</strong>和<strong>setter方法传递</strong>，相信用过Spring框架的，对依赖的传递方式一定不会陌生。</p>
<p>在实际编程中，我们一般需要做到如下3点：</p>
<ul>
<li>低层模块尽量都要有抽象类或接口，或者两者都有。</li>
<li>变量的声明类型尽量是抽象类或接口。</li>
<li>使用继承时遵循里氏替换原则。</li>
</ul>
<p>依赖倒置原则的核心就是要我们面向接口编程，理解了面向接口编程，也就理解了依赖倒置。</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p>定义：<br>客户端不应该依赖它不需要的接口；<br>一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>问题由来：类<code>A</code>通过接口<code>I</code>依赖类<code>B</code>，类<code>C</code>通过接口<code>I</code>依赖类<code>D</code>，如果接口<code>I</code>对于类<code>A</code>和类<code>C</code>来说不是最小接口，则类<code>B</code>和类<code>D</code>必须去实现他们不需要的方法。</p>
<p>解决方案：将臃肿的接口<code>I</code>拆分为独立的几个接口，类<code>A</code>和类<code>C</code>分别与它们需要的接口建立依赖关系。也就是采用接口隔离原则。</p>
<p>举例来说明接口隔离原则：<br><img src="/img/未遵循接口隔离原则的设计.jpg" alt="未遵循接口隔离原则的设计"></p>
<p>这个图的意思是：类<code>A</code>依赖接口<code>I</code>中的方法1、方法2、方法3，类<code>B</code>是对类<code>A</code>依赖的实现。类<code>C</code>依赖接口<code>I</code>中的方法1、方法4、方法5，类<code>D</code>是对类<code>C</code>依赖的实现。对于类<code>B</code>和类<code>D</code>来说，虽然它们都存在着用不到的方法（也就是图中红色字体标记的方法），但由于实现了接口<code>I</code>，所以也必须要实现这些用不到的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">interface I &#123;</div><div class="line">    public void method1();</div><div class="line">    public void method2();</div><div class="line">    public void method3();</div><div class="line">    public void method4();</div><div class="line">    public void method5();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">    public void depend1(I i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I i)&#123;</div><div class="line">        i.method2();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I i)&#123;</div><div class="line">        i.method3();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class B implements I&#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method2() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I的方法2&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method3() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I的方法3&quot;);</div><div class="line">    &#125;</div><div class="line">    //对于类B来说，method4和method5不是必需的，但是由于接口A中有这两个方法，</div><div class="line">    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</div><div class="line">    public void method4() &#123;&#125;</div><div class="line">    public void method5() &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class C&#123;</div><div class="line">    public void depend1(I i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I i)&#123;</div><div class="line">        i.method4();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I i)&#123;</div><div class="line">        i.method5();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">class D implements I&#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    //对于类D来说，method2和method3不是必需的，但是由于接口A中有这两个方法，</div><div class="line">    //所以在实现过程中即使这两个方法的方法体为空，也要将这两个没有作用的方法进行实现。</div><div class="line">    public void method2() &#123;&#125;</div><div class="line">    public void method3() &#123;&#125;</div><div class="line"></div><div class="line">    public void method4() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I的方法4&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method5() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I的方法5&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        A a = new A();</div><div class="line">        a.depend1(new B());</div><div class="line">        a.depend2(new B());</div><div class="line">        a.depend3(new B());</div><div class="line">        </div><div class="line">        C c = new C();</div><div class="line">        c.depend1(new D());</div><div class="line">        c.depend2(new D());</div><div class="line">        c.depend3(new D());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，如果接口过于臃肿，只要接口中出现的方法，不管对依赖于它的类有没有用处，实现类中都必须去实现这些方法，这显然不是好的设计。如果将这个设计修改为符合接口隔离原则，就必须对接口<code>I</code>进行拆分。在这里我们将原有的接口<code>I</code>拆分为三个接口，拆分后的设计如图2所示：</p>
<p><img src="/img/图2 遵循接口隔离原则的设计.jpg" alt="图2 遵循接口隔离原则的设计"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> interface I1 &#123;</div><div class="line">    public void method1();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface I2 &#123;</div><div class="line">    public void method2();</div><div class="line">    public void method3();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">interface I3 &#123;</div><div class="line">    public void method4();</div><div class="line">    public void method5();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class A&#123;</div><div class="line">    public void depend1(I1 i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I2 i)&#123;</div><div class="line">        i.method2();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I2 i)&#123;</div><div class="line">        i.method3();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class B implements I1, I2&#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I1的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method2() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I2的方法2&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method3() &#123;</div><div class="line">        System.out.println(&quot;类B实现接口I2的方法3&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class C&#123;</div><div class="line">    public void depend1(I1 i)&#123;</div><div class="line">        i.method1();</div><div class="line">    &#125;</div><div class="line">    public void depend2(I3 i)&#123;</div><div class="line">        i.method4();</div><div class="line">    &#125;</div><div class="line">    public void depend3(I3 i)&#123;</div><div class="line">        i.method5();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class D implements I1, I3&#123;</div><div class="line">    public void method1() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I1的方法1&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method4() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I3的方法4&quot;);</div><div class="line">    &#125;</div><div class="line">    public void method5() &#123;</div><div class="line">        System.out.println(&quot;类D实现接口I3的方法5&quot;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p>
<p>说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p>
<p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p>
<ul>
<li>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</li>
<li>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</li>
<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>
<li>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</li>
</ul>
<h2 id="迪米特法则-最少知道原则"><a href="#迪米特法则-最少知道原则" class="headerlink" title="迪米特法则(最少知道原则)"></a>迪米特法则(最少知道原则)</h2><p>定义：一个对象应该对其他对象保持最少的了解。</p>
<p>问题由来：类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大。</p>
<p>解决方案：尽量降低类与类之间的耦合。</p>
<p>低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量得低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</p>
<p>一个类对自己依赖的类知道得越少越好。也就是说，对于被依赖的类来说，无论逻辑多么复杂，都尽量地将逻辑封装在类的内部，对外除了提供的<code>public</code>方法，不对外泄漏任何信息。迪米特法则还有一个更简单的定义：只与直接的朋友通信。首先来解释一下什么是直接的朋友：每个对象都会与其他对象有耦合关系，只要两个对象之间有耦合关系，我们就说这两个对象之间是朋友关系。耦合的方式很多，依赖、关联、组合、聚合等。其中，我们称出现成员变量、方法参数、方法返回值中的类为直接的朋友，而出现在局部变量中的类则不是直接的朋友。也就是说，<strong>陌生的类最好不要作为局部变量的形式出现在类的内部</strong>。</p>
<p>举一个例子：有一个集团公司，下属单位有分公司和直属部门，现在要求打印出所有下属单位的员工ID。先来看一下违反迪米特法则的设计。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> //总公司员工</div><div class="line">class Employee&#123;</div><div class="line">    private String id;</div><div class="line">    public void setId(String id)&#123;</div><div class="line">        this.id = id;</div><div class="line">    &#125;</div><div class="line">    public String getId()&#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//分公司员工</div><div class="line">class SubEmployee&#123;</div><div class="line">    private String id;</div><div class="line">    public void setId(String id)&#123;</div><div class="line">        this.id = id;</div><div class="line">    &#125;</div><div class="line">    public String getId()&#123;</div><div class="line">        return id;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class SubCompanyManager&#123;</div><div class="line">    public List&lt;SubEmployee&gt; getAllEmployee()&#123;</div><div class="line">        List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;();</div><div class="line">        for(int i=0; i&lt;100; i++)&#123;</div><div class="line">            SubEmployee emp = new SubEmployee();</div><div class="line">            //为分公司人员按顺序分配一个ID</div><div class="line">            emp.setId(&quot;分公司&quot;+i);</div><div class="line">            list.add(emp);</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">class CompanyManager&#123;</div><div class="line"></div><div class="line">    public List&lt;Employee&gt; getAllEmployee()&#123;</div><div class="line">        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();</div><div class="line">        for(int i=0; i&lt;30; i++)&#123;</div><div class="line">            Employee emp = new Employee();</div><div class="line">            //为总公司人员按顺序分配一个ID</div><div class="line">            emp.setId(&quot;总公司&quot;+i);</div><div class="line">            list.add(emp);</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void printAllEmployee(SubCompanyManager sub)&#123;</div><div class="line">        List&lt;SubEmployee&gt; list1 = sub.getAllEmployee();</div><div class="line">        for(SubEmployee e:list1)&#123;</div><div class="line">            System.out.println(e.getId());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        List&lt;Employee&gt; list2 = this.getAllEmployee();</div><div class="line">        for(Employee e:list2)&#123;</div><div class="line">            System.out.println(e.getId());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public class Client&#123;</div><div class="line">    public static void main(String[] args)&#123;</div><div class="line">        CompanyManager e = new CompanyManager();</div><div class="line">        e.printAllEmployee(new SubCompanyManager());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在这个设计的主要问题出在<code>CompanyManager</code>中，根据迪米特法则，只与直接的朋友发生通信，而<code>SubEmployee</code>类并不是<code>CompanyManager</code>类的直接朋友（以局部变量出现的耦合不属于直接朋友），从逻辑上讲总公司只与他的分公司耦合就行了，与分公司的员工并没有任何联系，这样设计显然是增加了不必要的耦合。按照迪米特法则，应该避免类中出现这样非直接朋友关系的耦合。修改后的代码如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">class SubCompanyManager&#123;</div><div class="line">    public List&lt;SubEmployee&gt; getAllEmployee()&#123;</div><div class="line">        List&lt;SubEmployee&gt; list = new ArrayList&lt;SubEmployee&gt;();</div><div class="line">        for(int i=0; i&lt;100; i++)&#123;</div><div class="line">            SubEmployee emp = new SubEmployee();</div><div class="line">            //为分公司人员按顺序分配一个ID</div><div class="line">            emp.setId(&quot;分公司&quot;+i);</div><div class="line">            list.add(emp);</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">    public void printEmployee()&#123;</div><div class="line">        List&lt;SubEmployee&gt; list = this.getAllEmployee();</div><div class="line">        for(SubEmployee e:list)&#123;</div><div class="line">            System.out.println(e.getId());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">class CompanyManager&#123;</div><div class="line">    public List&lt;Employee&gt; getAllEmployee()&#123;</div><div class="line">        List&lt;Employee&gt; list = new ArrayList&lt;Employee&gt;();</div><div class="line">        for(int i=0; i&lt;30; i++)&#123;</div><div class="line">            Employee emp = new Employee();</div><div class="line">            //为总公司人员按顺序分配一个ID</div><div class="line">            emp.setId(&quot;总公司&quot;+i);</div><div class="line">            list.add(emp);</div><div class="line">        &#125;</div><div class="line">        return list;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public void printAllEmployee(SubCompanyManager sub)&#123;</div><div class="line">        sub.printEmployee();</div><div class="line">        List&lt;Employee&gt; list2 = this.getAllEmployee();</div><div class="line">        for(Employee e:list2)&#123;</div><div class="line">            System.out.println(e.getId());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改后，为分公司增加了打印人员ID的方法，总公司直接调用来打印，从而避免了与分公司的员工发生耦合。</p>
<p>迪米特法则的初衷是降低类之间的耦合，由于每个类都减少了不必要的依赖，因此的确可以降低耦合关系。但是凡事都有度，虽然可以避免与非直接的类通信，但是要通信，必然会通过一个“中介”来发生联系，例如本例中，总公司就是通过分公司这个“中介”来与分公司的员工发生联系的。过分地使用迪米特原则，会产生大量这样的中介和传递类，导致系统复杂度变大。所以在采用迪米特法则时要反复权衡，既做到结构清晰，又要高内聚低耦合。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><p>定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。</p>
<p>问题由来：在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。</p>
<p>解决方案：当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。</p>
<p>开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确地告诉我们。以前，如果有人告诉我“你进行设计的时候一定要遵守开闭原则”，我会觉得他什么都没说，但貌似又什么都说了。因为开闭原则真得太虚了。</p>
<p>在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守得好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的“平均得分”，前面5项原则遵守得好，平均分自然就高，说明软件设计开闭原则遵守得好；如果前面5项原则遵守得不好，则说明开闭原则遵守得不好。</p>
<p>其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象得合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p>
<p>说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：单一职责原则告诉我们实现类要职责单一；里氏替换原则告诉我们不要破坏继承体系；依赖倒置原则告诉我们要面向接口编程；接口隔离原则告诉我们在设计接口的时候要精简单一；迪米特法则告诉我们要降低耦合。而开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭。</p>
<p>最后说明一下如何去遵守这六个原则。对这六个原则的遵守并不是是和否的问题，而是多和少的问题，也就是说，我们一般不会说有没有遵守，而是说遵守程度的多少。任何事都是过犹不及，设计模式的六个设计原则也是一样，制定这六个原则的目的并不是要我们刻板地遵守他们，而需要根据实际情况灵活运用。对他们的遵守程度只要在一个合理的范围内，就算是良好的设计。</p>
<p><img src="/img/如何去遵守这六个原则.jpg" alt="如何去遵守这六个原则"></p>
<p>图中的每一条维度各代表一项原则，我们依据对这项原则的遵守程度在维度上画一个点，则如果对这项原则遵守得合理的话，这个点应该落在红色的同心圆内部；如果遵守得差，点将会在小圆内部；如果过度遵守，点将会落在大圆外部。一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。<br><img src="/img/一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。.jpg" alt="一个良好的设计体现在图中，应该是六个顶点都在同心圆中的六边形。"></p>
<p>在上图中，设计1、设计2属于良好的设计，他们对六项原则的遵守程度都在合理的范围内；设计3、设计4设计虽然有些不足，但也基本可以接受；设计5则严重不足，对各项原则都没有很好的遵守；而设计6则遵守过渡了，设计5和设计6都是迫切需要重构的设计。</p>
]]></content>
    
    <summary type="html">
    
      设计模式六大原则
    
    </summary>
    
      <category term="设计原则" scheme="http://jishusuishouji.github.io/categories/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="设计原则" scheme="http://jishusuishouji.github.io/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Java 类的加载机制</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/java/Java_%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/java/Java_类的加载机制/</id>
    <published>2017-04-05T23:05:01.000Z</published>
    <updated>2017-04-05T23:38:16.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h2><p>类的加载:将类的<code>.class</code>文件的二进制数据读入到内存中，将其放在方法区内，然后在堆区创建一个<code>java.lang.Class</code>对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的<code>Class</code>对象，<code>Class</code>对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。</p>
<p>类加载器并不需要等到某个类被“首次主动使用”时再加载它，JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了<code>.class</code>文件缺失或存在错误，类加载器在程序首次主动使用该类时才报告错误（<code>LinkageError</code>错误）,否则如果这个类一直没有被程序主动使用，那么类加载器就不会报告错误</p>
<h2 id="加载-class文件的方式"><a href="#加载-class文件的方式" class="headerlink" title="加载.class文件的方式"></a>加载.class文件的方式</h2><p>– 从本地系统中直接加载<br>– 通过网络下载<code>.class</code>文件<br>– 从zip，jar等归档文件中加载<code>.class</code>文件<br>– 从专有数据库中提取<code>.class</code>文件<br>– 将Java源文件动态编译为<code>.class</code>文件</p>
<h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p>类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定（也成为动态绑定或晚期绑定）。另外注意这里的几个阶段是按顺序开始，而不是按顺序进行或完成，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p>
<h3 id="加载：查找并加载类的二进制数据"><a href="#加载：查找并加载类的二进制数据" class="headerlink" title="加载：查找并加载类的二进制数据"></a>加载：查找并加载类的二进制数据</h3><p>加载是类加载过程的第一个阶段，在加载阶段，虚拟机需要完成以下三件事情：<br>1、通过一个类的全限定名来获取其定义的二进制字节流。<br>2、将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。<br>3、在Java堆中生成一个代表这个类的<code>java.lang.Class</code>对象，作为对方法区中这些数据的访问入口。</p>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个<code>java.lang.Class</code>类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证：确保被加载的类的正确性"><a href="#验证：确保被加载的类的正确性" class="headerlink" title="验证：确保被加载的类的正确性"></a>验证：确保被加载的类的正确性</h4><p>验证是连接阶段的第一步，这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成4个阶段的检验动作：</p>
<ol>
<li>文件格式验证：验证字节流是否符合Class文件格式的规范；例如：是否以<code>0xCAFEBABE</code>开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li>元数据验证：对字节码描述的信息进行语义分析（注意：对比<code>javac</code>编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有除了<code>java.lang.Object</code>之外的父类。</li>
<li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li>符号引用验证：确保解析动作能正确执行。</li>
</ol>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用<code>-Xverifynone</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h4 id="准备：为类的静态变量分配内存，并将其初始化为默认值"><a href="#准备：为类的静态变量分配内存，并将其初始化为默认值" class="headerlink" title="准备：为类的静态变量分配内存，并将其初始化为默认值"></a>准备：为类的静态变量分配内存，并将其初始化为默认值</h4><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：<br>1、这时候进行内存分配的仅包括类变量（<code>static</code>），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。<br>2、这里所设置的初始值通常情况下是数据类型默认的零值（如<code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code>等），而不是被在Java代码中被显式地赋予的值。</p>
<p>假设一个类变量的定义为：<code>public static int value = 3</code>；<br>那么变量<code>value</code>在准备阶段过后的初始值为<code>0</code>，而不是<code>3</code>，因为这时候尚未开始执行任何Java方法，而把<code>value</code>赋值为3的<code>put static</code>指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;()</code>方法之中的，所以把<code>value</code>赋值为3的动作将在初始化阶段才会执行。</p>
<p>这里还需要注意如下几点：</p>
<p>· 对基本数据类型来说，对于类变量（<code>static</code>）和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。<br>· 对于同时被<code>static</code>和<code>final</code>修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被<code>final</code>修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。<br>· 对于引用数据类型reference来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的零值，即<code>null</code>。<br>· 如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的零值。<br>3、如果类字段的字段属性表中存在<code>ConstantValue</code>属性，即同时被<code>final</code>和<code>static</code>修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。</p>
<p>假设上面的类变量value被定义为： <code>public static final int value = 3</code>；</p>
<p>编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。我们可以理解为<code>static final</code>常量在编译期就将其结果放入了调用它的类的常量池中</p>
<h4 id="解析：把类中的符号引用转换为直接引用"><a href="#解析：把类中的符号引用转换为直接引用" class="headerlink" title="解析：把类中的符号引用转换为直接引用"></a>解析：把类中的符号引用转换为直接引用</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。</p>
<p>直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化，为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。在Java中对类变量进行初始值设定有两种方式：</p>
<p>①声明类变量是指定初始值</p>
<p>②使用静态代码块为类变量指定初始值</p>
<h4 id="JVM初始化步骤"><a href="#JVM初始化步骤" class="headerlink" title="JVM初始化步骤"></a>JVM初始化步骤</h4><p>1、假如这个类还没有被加载和连接，则程序先加载并连接该类<br>2、假如该类的直接父类还没有被初始化，则先初始化其直接父类<br>3、假如类中有初始化语句，则系统依次执行这些初始化语句</p>
<p>类初始化时机：只有当对类的主动使用的时候才会导致类的初始化，类的主动使用包括以下六种：<br>– 创建类的实例，也就是new的方式<br>– 访问某个类或接口的静态变量，或者对该静态变量赋值<br>– 调用类的静态方法<br>– 反射（如Class.forName(“com.shengsiyuan.Test”)）<br>– 初始化某个类的子类，则其父类也会被初始化<br>– Java虚拟机启动时被标明为启动类的类（Java Test），直接使用java.exe命令来运行某个主类</p>
<h3 id="结束生命周期"><a href="#结束生命周期" class="headerlink" title="结束生命周期"></a>结束生命周期</h3><p>•在如下几种情况下，Java虚拟机将结束生命周期</p>
<p>– 执行了System.exit()方法<br>– 程序正常执行结束<br>– 程序在执行过程中遇到了异常或错误而异常终止<br>– 由于操作系统出现错误而导致Java虚拟机进程终止</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class ClassLoaderTest &#123;</div><div class="line">     public static void main(String[] args) &#123;</div><div class="line">        ClassLoader loader = Thread.currentThread().getContextClassLoader();</div><div class="line">        System.out.println(loader);</div><div class="line">        System.out.println(loader.getParent());</div><div class="line">        System.out.println(loader.getParent().getParent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后，输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sun.misc.Launcher$AppClassLoader@64fef26a</div><div class="line">sun.misc.Launcher$ExtClassLoader@1ddd40f3</div><div class="line">null</div></pre></td></tr></table></figure></p>
<p>从上面的结果可以看出，并没有获取到<code>ExtClassLoader</code>的父<code>Loader</code>，原因是Bootstrap Loader（引导类加载器）是用C语言实现的，找不到一个确定的返回父Loader的方式，于是就返回null。</p>
<p>这几种类加载器的层次关系如下图所示：<br><img src="/img/类加载器的层次关系.jpg" alt="类加载器的层次关系"><br>注意：这里父类加载器并不是通过继承关系来实现的，而是采用组合实现的。<br>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分；所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类<code>java.lang.ClassLoader</code>，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</p>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<ul>
<li><p>启动类加载器：Bootstrap ClassLoader，负责加载存放在<code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被<code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.*开头的类均被Bootstrap ClassLoader加载）。启动类加载器是无法被Java程序直接引用的。</p>
</li>
<li><p>扩展类加载器：Extension ClassLoader，该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>DK\jre\lib\ext</code>目录中，或者由<code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.*开头的类），开发者可以直接使用扩展类加载器。</p>
</li>
<li><p>应用程序类加载器：Application ClassLoader，该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<p>1）在执行非置信代码之前，自动验证数字签名。<br>2）动态地创建符合用户特定需要的定制化构建类。<br>3）从特定的场所取得java class，例如数据库中和网络中。</p>
<h2 id="JVM类加载机制"><a href="#JVM类加载机制" class="headerlink" title="JVM类加载机制"></a>JVM类加载机制</h2><p>•全盘负责，当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入<br>•父类委托，先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类<br>•缓存机制，缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效</p>
<h2 id="4、类的加载"><a href="#4、类的加载" class="headerlink" title="4、类的加载"></a>4、类的加载</h2><p>类加载有三种方式：</p>
<p>1、命令行启动应用时候由JVM初始化加载<br>2、通过<code>Class.forName()</code>方法动态加载<br>3、通过<code>ClassLoader.loadClass()</code>方法动态加载</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public class loaderTest &#123; </div><div class="line">        public static void main(String[] args) throws ClassNotFoundException &#123; </div><div class="line">                ClassLoader loader = HelloWorld.class.getClassLoader(); </div><div class="line">                System.out.println(loader); </div><div class="line">                //使用ClassLoader.loadClass()来加载类，不会执行初始化块 </div><div class="line">                loader.loadClass(&quot;Test2&quot;); </div><div class="line">                //使用Class.forName()来加载类，默认会执行初始化块 </div><div class="line">                Class.forName(&quot;Test2&quot;); </div><div class="line">                //使用Class.forName()来加载类，并指定ClassLoader，初始化时不执行静态块 </div><div class="line">                Class.forName(&quot;Test2&quot;, false, loader); </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>demo类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">public class Test2 &#123; </div><div class="line">        static &#123; </div><div class="line">                System.out.println(&quot;静态初始化块执行了！&quot;); </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>分别切换加载方式，会有不同的输出结果。</p>
<h3 id="Class-forName-和ClassLoader-loadClass-区别"><a href="#Class-forName-和ClassLoader-loadClass-区别" class="headerlink" title="Class.forName()和ClassLoader.loadClass()区别"></a>Class.forName()和ClassLoader.loadClass()区别</h3><p><code>Class.forName()</code>：将类的<code>.class</code>文件加载到jvm中之外，还会对类进行解释，执行类中的static块；<br><code>ClassLoader.loadClass()</code>：只干一件事情，就是将<code>.class</code>文件加载到jvm中，不会执行static中的内容,只有在new Instance才会去执行static块。</p>
<p>注：<br><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了new Instance()方法采用调用构造函数，创建类的对象 。</p>
<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，依次向上，因此，所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器在它的搜索范围中没有找到所需的类时，即无法完成该加载，子加载器才会尝试自己去加载该类。</p>
<p>双亲委派机制:<br>1、当AppClassLoader加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器ExtClassLoader去完成。<br>2、当ExtClassLoader加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader去完成。<br>3、如果BootStrapClassLoader加载失败（例如在$JAVA_HOME/jre/lib里未查找到该class），会使用ExtClassLoader来尝试加载；<br>4、若ExtClassLoader也加载失败，则会使用AppClassLoader来加载，如果AppClassLoader也加载失败，则会报出异常ClassNotFoundException。</p>
<p>ClassLoader源码分析：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">public Class&lt;?&gt; loadClass(String name)throws ClassNotFoundException &#123;</div><div class="line">            return loadClass(name, false);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    protected synchronized Class&lt;?&gt; loadClass(String name, boolean resolve)throws ClassNotFoundException &#123;</div><div class="line">            // 首先判断该类型是否已经被加载</div><div class="line">            Class c = findLoadedClass(name);</div><div class="line">            if (c == null) &#123;</div><div class="line">                //如果没有被加载，就委托给父类加载或者委派给启动类加载器加载</div><div class="line">                try &#123;</div><div class="line">                    if (parent != null) &#123;</div><div class="line">                         //如果存在父类加载器，就委派给父类加载器加载</div><div class="line">                        c = parent.loadClass(name, false);</div><div class="line">                    &#125; else &#123;</div><div class="line">                    //如果不存在父类加载器，就检查是否是由启动类加载器加载的类，通过调用本地方法native Class findBootstrapClass(String name)</div><div class="line">                        c = findBootstrapClass0(name);</div><div class="line">                    &#125;</div><div class="line">                &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">                 // 如果父类加载器和启动类加载器都不能完成加载任务，才调用自身的加载功能</div><div class="line">                    c = findClass(name);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            if (resolve) &#123;</div><div class="line">                resolveClass(c);</div><div class="line">            &#125;</div><div class="line">            return c;</div><div class="line">        &#125;</div></pre></td></tr></table></figure></p>
<p>双亲委派模型意义：</p>
<p>-系统类防止内存中出现多份同样的字节码<br>-保证Java程序安全稳定运行</p>
<h2 id="6、自定义类加载器"><a href="#6、自定义类加载器" class="headerlink" title="6、自定义类加载器"></a>6、自定义类加载器</h2><p>应用是通过网络来传输Java类的字节码，为保证安全性，这些字节码经过了加密处理，这时系统类加载器就无法对其进行加载，这样则需要自定义类加载器来实现。自定义类加载器一般都是继承自<code>ClassLoader</code>类，从上面对loadClass方法来分析来看，我们只需要重写<code>findClass</code> 方法即可。下面我们通过一个示例来演示自定义类加载器的流程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line">import java.io.*;</div><div class="line"> </div><div class="line">public class MyClassLoader extends ClassLoader &#123;</div><div class="line"> </div><div class="line">    private String root;</div><div class="line"> </div><div class="line">    protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</div><div class="line">        byte[] classData = loadClassData(name);</div><div class="line">        if (classData == null) &#123;</div><div class="line">            throw new ClassNotFoundException();</div><div class="line">        &#125; else &#123;</div><div class="line">            return defineClass(name, classData, 0, classData.length);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    private byte[] loadClassData(String className) &#123;</div><div class="line">        String fileName = root + File.separatorChar</div><div class="line">                + className.replace(&apos;.&apos;, File.separatorChar) + &quot;.class&quot;;</div><div class="line">        try &#123;</div><div class="line">            InputStream ins = new FileInputStream(fileName);</div><div class="line">            ByteArrayOutputStream baos = new ByteArrayOutputStream();</div><div class="line">            int bufferSize = 1024;</div><div class="line">            byte[] buffer = new byte[bufferSize];</div><div class="line">            int length = 0;</div><div class="line">            while ((length = ins.read(buffer)) != -1) &#123;</div><div class="line">                baos.write(buffer, 0, length);</div><div class="line">            &#125;</div><div class="line">            return baos.toByteArray();</div><div class="line">        &#125; catch (IOException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        return null;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public String getRoot() &#123;</div><div class="line">        return root;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void setRoot(String root) &#123;</div><div class="line">        this.root = root;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public static void main(String[] args)  &#123;</div><div class="line"> </div><div class="line">        MyClassLoader classLoader = new MyClassLoader();</div><div class="line">        classLoader.setRoot(&quot;E:\\temp&quot;);</div><div class="line"> </div><div class="line">        Class&lt;?&gt; testClass = null;</div><div class="line">        try &#123;</div><div class="line">            testClass = classLoader.loadClass(&quot;com.neo.classloader.Test2&quot;);</div><div class="line">            Object object = testClass.newInstance();</div><div class="line">            System.out.println(object.getClass().getClassLoader());</div><div class="line">        &#125; catch (ClassNotFoundException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; catch (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自定义类加载器的核心在于对字节码文件的获取，如果是加密的字节码则需要在该类中对文件进行解密。由于这里只是演示，我并未对class文件进行加密，因此没有解密的过程。这里有几点需要注意：</p>
<p>1、这里传递的文件名需要是类的全限定性名称，即com.paddx.test.classloading.Test格式的，因为 defineClass 方法是按这种格式进行处理的。</p>
<p>2、最好不要重写loadClass方法，因为这样容易破坏双亲委托模式。</p>
<p>3、这类Test 类本身可以被 AppClassLoader 类加载，因此我们不能把 com/paddx/test/classloading/Test.class 放在类路径下。否则，由于双亲委托机制的存在，会直接导致该类由AppClassLoader 加载，而不会通过我们自定义类加载器来加载。</p>
]]></content>
    
    <summary type="html">
    
      Java 类的加载机制
    
    </summary>
    
      <category term="jav" scheme="http://jishusuishouji.github.io/categories/jav/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>启动ActiveMQ的Broker</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/activemq/%E5%90%AF%E5%8A%A8ActiveMQ%E7%9A%84Broker/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/activemq/启动ActiveMQ的Broker/</id>
    <published>2017-04-05T22:57:20.000Z</published>
    <updated>2017-04-05T23:56:22.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、直接运行安装目录的bin-activemq-bat"><a href="#1、直接运行安装目录的bin-activemq-bat" class="headerlink" title="1、直接运行安装目录的bin\activemq.bat"></a>1、直接运行安装目录的<code>bin\activemq.bat</code></h2><h2 id="2、可以通过在应用程序中以编码的方式启动broker，例如："><a href="#2、可以通过在应用程序中以编码的方式启动broker，例如：" class="headerlink" title="2、可以通过在应用程序中以编码的方式启动broker，例如："></a>2、可以通过在应用程序中以编码的方式启动broker，例如：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BrokerService broker =new BrokerService();  </div><div class="line">broker.setBrokerName(&quot;testName&quot;);//如果启动多个Broker时，必须为Broker设置一个名称  </div><div class="line">broker.addConnector(&quot;tcp://localhost:61616&quot;);  </div><div class="line">broker.start();</div></pre></td></tr></table></figure>
<h2 id="3、可以通过BrokerFactory来创建broker，例如："><a href="#3、可以通过BrokerFactory来创建broker，例如：" class="headerlink" title="3、可以通过BrokerFactory来创建broker，例如："></a>3、可以通过<code>BrokerFactory</code>来创建<code>broker</code>，例如：</h2><pre><code>BrokerService broker =BrokerFactory.createBroker(new URI(&quot;broker:tcp://localhost:61616&quot;));  
broker.start();  
</code></pre><h2 id="4、测代码"><a href="#4、测代码" class="headerlink" title="4、测代码"></a>4、测代码</h2><pre><code>import java.net.URI;  
import org.apache.activemq.broker.BrokerFactory;  
import org.apache.activemq.broker.BrokerService;  

/** 
 * 启动ActiveMQ的代理Broker 
 */  
public class RunningBroker {  
    public static void main(String[] args){  
        try {  
            codeByRunning() ;  //启动Broker  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  

    /** 
     * 应用程序中以编码的方式启动 
     */  
    public static void codeByRunning() throws Exception{  
        BrokerService broker =new BrokerService();  
        broker.setBrokerName(&quot;testName&quot;);//如果启动多个Broker时，必须为Broker设置一个名称  
        broker.addConnector(&quot;tcp://localhost:61616&quot;);  
        broker.start();  
    }  

    /** 
     * 以BrokerFactory的方式启动 
     */  
    public static void factoryByRunning()throws Exception{  
        BrokerService broker =BrokerFactory.createBroker(new URI(&quot;broker:tcp://localhost:61616&quot;));  
        broker.start();  
    }  
}
</code></pre>]]></content>
    
    <summary type="html">
    
      启动ActiveMQ的Broker
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActiveMQ/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ实现负载均衡+高可用部署方案</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/activemq/ActiveMQ%E5%AE%9E%E7%8E%B0%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1_%E9%AB%98%E5%8F%AF%E7%94%A8%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/activemq/ActiveMQ实现负载均衡_高可用部署方案/</id>
    <published>2017-04-05T22:29:04.000Z</published>
    <updated>2017-04-05T22:55:23.477Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、架构和技术介绍"><a href="#一、架构和技术介绍" class="headerlink" title="一、架构和技术介绍"></a>一、架构和技术介绍</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>ActiveMQ完全支持JMS1.1和J2EE 1.4规范的JMS Provider实现。</p>
<h3 id="2、activemq的特性"><a href="#2、activemq的特性" class="headerlink" title="2、activemq的特性"></a>2、activemq的特性</h3><ol>
<li>多种语言和协议编写客户端。语言: Java, C, C++, C#, Ruby, Perl, Python,PHP。应用协议: OpenWire,Stomp REST,WS Notification,XMPP,AMQP</li>
<li>完全支持JMS1.1和J2EE 1.4规范 (持久化,XA消息,事务)</li>
<li>对Spring的支持,ActiveMQ可以很容易内嵌到使用Spring的系统里面去,而且也支持Spring2.0的特性</li>
<li>通过了常见J2EE服务器(如 Geronimo,JBoss 4, GlassFish,WebLogic)的测试,其中通过JCA 1.5 resourceadaptors的配置,可以让ActiveMQ可以自动地部署到任何兼容J2EE1.4商业服务器上</li>
<li>支持多种传送协议:in-VM,TCP,SSL,NIO,UDP,JGroups,JXTA</li>
<li>支持通过JDBC和journal提供高速的消息持久化</li>
<li>从设计上保证了高性能的集群,客户端-服务器,点对点</li>
<li>支持Ajax</li>
<li>支持与Axis的整合</li>
<li>可以很容易得调用内嵌JMS provider,进行测试</li>
</ol>
<h3 id="3、下载和安装ActiveMQ"><a href="#3、下载和安装ActiveMQ" class="headerlink" title="3、下载和安装ActiveMQ"></a>3、下载和安装ActiveMQ</h3><h4 id="1、下载"><a href="#1、下载" class="headerlink" title="1、下载"></a>1、下载</h4><h4 id="2、安装"><a href="#2、安装" class="headerlink" title="2、安装"></a>2、安装</h4><p>如果是在windows系统中运行，可以直接解压apache-activemq-5.9.0-bin.zip，并运行bin目录下的activemq.bat文件，此时使用的是默认的服务端口：61616和默认的console端口：8161。</p>
<p>如果是在linux或unix下运行，在bin目录下执行命令：<code>./activemq setup</code></p>
<h4 id="3、修改ActiveMQ的服务端口和console端口"><a href="#3、修改ActiveMQ的服务端口和console端口" class="headerlink" title="3、修改ActiveMQ的服务端口和console端口"></a>3、修改ActiveMQ的服务端口和console端口</h4><p>A、修改服务端口：打开<code>conf/activemq.xml</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"> &lt;transportConnectors&gt;</div><div class="line">    &lt;transportConnector name=&quot;openwire&quot; uri=&quot;tcp://10.42.220.72:61618&quot;discoveryUri=&quot;multicast://default&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure></p>
<p>B、修改console的地址和端口:打开<code>conf/jetty.xml</code>文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   &lt;bean id=&quot;jettyPort&quot;class=&quot;org.apache.activemq.web.WebConsolePort&quot;init-method=&quot;start&quot;&gt;</div><div class="line">      &lt;property name=&quot;port&quot; value=&quot;8162&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h4 id="4、通过客户端代码试用ActiveMQ"><a href="#4、通过客户端代码试用ActiveMQ" class="headerlink" title="4、通过客户端代码试用ActiveMQ"></a>4、通过客户端代码试用ActiveMQ</h4><p>需要提前将activemq解压包中的lib目录下的相关包引入到工程中，再进行如下编码：</p>
<h5 id="1、发送端的代码："><a href="#1、发送端的代码：" class="headerlink" title="1、发送端的代码："></a>1、发送端的代码：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line">importjavax.jms.Connection;</div><div class="line">importjavax.jms.ConnectionFactory;</div><div class="line">importjavax.jms.DeliveryMode;</div><div class="line">importjavax.jms.Destination;</div><div class="line">importjavax.jms.MessageProducer;</div><div class="line">importjavax.jms.Session;</div><div class="line">importjavax.jms.TextMessage;</div><div class="line">importorg.apache.activemq.ActiveMQConnection;</div><div class="line">importorg.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"></div><div class="line">publicclass Sender &#123;</div><div class="line">    private static finalint SEND_NUMBER = 5;</div><div class="line"></div><div class="line">    publicstaticvoid main(String[] args) &#123;</div><div class="line">        // ConnectionFactory：连接工厂，JMS用它创建连接</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        // Connection：JMS客户端到JMS Provider的连接</div><div class="line">        Connection connection = null;</div><div class="line">        // Session：一个发送或接收消息的线程</div><div class="line">        Session session;</div><div class="line">        // Destination：消息的目的地;消息发送给谁.</div><div class="line">        Destination destination;</div><div class="line">        // MessageProducer：消息发送者</div><div class="line">        MessageProducer producer;</div><div class="line">        TextMessage message;</div><div class="line">    </div><div class="line">        //构造ConnectionFactory实例对象，此处采用ActiveMq的实现jar</div><div class="line">        connectionFactory = new ActiveMQConnectionFactory(</div><div class="line">                ActiveMQConnection.DEFAULT_USER,</div><div class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</div><div class="line">                &quot;failover:(tcp://10.42.220.72:61617,tcp://10.42.220.72:61618)&quot;);</div><div class="line">        try &#123;</div><div class="line">            //构造从工厂得到连接对象</div><div class="line">            connection =connectionFactory.createConnection();</div><div class="line">            //启动</div><div class="line">            connection.start();</div><div class="line">            //获取操作连接</div><div class="line">            session = connection.createSession(true, Session.AUTO_ACKNOWLEDGE);</div><div class="line">            //获取session</div><div class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</div><div class="line">            //得到消息生成者【发送者】</div><div class="line">            producer =session.createProducer(destination);</div><div class="line">            //设置不持久化，此处学习，实际根据项目决定</div><div class="line">            producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</div><div class="line">            //构造消息，此处写死，项目就是参数，或者方法获取</div><div class="line">            sendMessage(session, producer);</div><div class="line">            session.commit();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (null != connection)</div><div class="line">                    connection.close();</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    publicstaticvoid sendMessage(Session session,MessageProducer producer)</div><div class="line">            throws Exception &#123;</div><div class="line">        for (int i = 1; i &lt;=SEND_NUMBER; i++) &#123;</div><div class="line">            TextMessage message = session</div><div class="line">                    .createTextMessage(&quot;ActiveMq发送的消息&quot; + i);</div><div class="line">            //发送消息到目的地方</div><div class="line">            System.out.println(&quot;发送消息：&quot; + &quot;ActiveMq 发送的消息&quot; + i);</div><div class="line">            producer.send(message);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="2、接收端代码："><a href="#2、接收端代码：" class="headerlink" title="2、接收端代码："></a>2、接收端代码：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">importjavax.jms.Connection;</div><div class="line">importjavax.jms.ConnectionFactory;</div><div class="line">importjavax.jms.Destination;</div><div class="line">importjavax.jms.MessageConsumer;</div><div class="line">importjavax.jms.Session;</div><div class="line">importjavax.jms.TextMessage;</div><div class="line">importorg.apache.activemq.ActiveMQConnection;</div><div class="line">importorg.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"> </div><div class="line"></div><div class="line">publicclass Receive &#123;</div><div class="line">    publicstaticvoid main(String[] args) &#123;</div><div class="line">        // ConnectionFactory：连接工厂，JMS用它创建连接</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        // Connection：JMS客户端到JMS Provider的连接</div><div class="line">        Connection connection = null;</div><div class="line">        // Session：一个发送或接收消息的线程</div><div class="line">        Session session;</div><div class="line">        // Destination：消息的目的地;消息发送给谁.</div><div class="line">        Destination destination;</div><div class="line">        //消费者，消息接收者</div><div class="line">        MessageConsumer consumer;</div><div class="line">        connectionFactory = new ActiveMQConnectionFactory(</div><div class="line">                ActiveMQConnection.DEFAULT_USER,</div><div class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</div><div class="line">                &quot;failover:(tcp://10.42.220.72:61617,tcp://10.42.220.72:61618)&quot;);</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            //构造从工厂得到连接对象</div><div class="line">            connection =connectionFactory.createConnection();</div><div class="line">            //启动</div><div class="line">            connection.start();</div><div class="line">            //获取操作连接</div><div class="line">            session = connection.createSession(false,</div><div class="line">                    Session.AUTO_ACKNOWLEDGE);</div><div class="line">            //获取session</div><div class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</div><div class="line">            consumer =session.createConsumer(destination);</div><div class="line">            while (true) &#123;</div><div class="line">                //设置接收者接收消息的时间，为了便于测试，这里谁定为100s</div><div class="line">                TextMessage message =(TextMessage) consumer.receive(100000);</div><div class="line">                if (null != message) &#123;</div><div class="line">                    System.out.println(&quot;收到消息&quot; + message.getText());</div><div class="line">                &#125; else &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (null != connection)</div><div class="line">                    connection.close();</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3、通过监控查看消息堆栈的记录："><a href="#3、通过监控查看消息堆栈的记录：" class="headerlink" title="3、通过监控查看消息堆栈的记录："></a>3、通过监控查看消息堆栈的记录：</h5><p>登陆<code>http://localhost:8162/admin/queues.jsp</code>，默认的用户名和密码：<code>admin/admin</code></p>
<h2 id="二、ActiveMQ的多种部署方式"><a href="#二、ActiveMQ的多种部署方式" class="headerlink" title="二、ActiveMQ的多种部署方式"></a>二、ActiveMQ的多种部署方式</h2><p>单点的ActiveMQ作为企业应用无法满足高可用和集群的需求，所以ActiveMQ提供了master-slave、broker cluster等多种部署方式，但通过分析多种部署方式之后我认为需要将两种部署方式相结合才能满足我们公司分布式和高可用的需求，所以后面就重点将解如何将两种部署方式相结合。</p>
<h3 id="1、Master-Slave部署方式"><a href="#1、Master-Slave部署方式" class="headerlink" title="1、Master-Slave部署方式"></a>1、Master-Slave部署方式</h3><h4 id="1）shared-filesystem-Master-Slave部署方式"><a href="#1）shared-filesystem-Master-Slave部署方式" class="headerlink" title="1）shared filesystem Master-Slave部署方式"></a>1）shared filesystem Master-Slave部署方式</h4><p>主要是通过共享存储目录来实现master和slave的热备，所有的ActiveMQ应用都在不断地获取共享目录的控制权，哪个应用抢到了控制权，它就成为master。</p>
<p>多个共享存储目录的应用，谁先启动，谁就可以最早取得共享目录的控制权成为master，其他的应用就只能作为slave。<br><img src="/img/ActiveMQ Master-Slave部署方式.png" alt="ActiveMQ Master-Slave部署方式"></p>
<h4 id="2）shared-database-Master-Slave方式"><a href="#2）shared-database-Master-Slave方式" class="headerlink" title="2）shared database Master-Slave方式"></a>2）shared database Master-Slave方式</h4><p>与shared filesystem方式类似，只是共享的存储介质由文件系统改成了数据库而已。</p>
<h4 id="3）Replicated-LevelDB-Store方式"><a href="#3）Replicated-LevelDB-Store方式" class="headerlink" title="3）Replicated LevelDB Store方式"></a>3）Replicated LevelDB Store方式</h4><p>这种主备方式是ActiveMQ5.9以后才新增的特性，使用ZooKeeper协调选择一个node作为master。被选择的master broker node开启并接受客户端连接。<br>其他node转入slave模式，连接master并同步他们的存储状态。slave不接受客户端连接。所有的存储操作都将被复制到连接至Master的slaves。</p>
<p>如果master死了，得到了最新更新的slave被允许成为master。fialed node能够重新加入到网络中并连接master进入slave mode。所有需要同步的disk的消息操作都将等待存储状态被复制到其他法定节点的操作完成才能完成。所以，如果你配置了replicas=3，那么法定大小是(3/2)+1=2. Master将会存储并更新然后等待 (2-1)=1个slave存储和更新完成，才汇报success。至于为什么是2-1，熟悉Zookeeper的应该知道，有一个node要作为观擦者存在。</p>
<p>当一个新的master被选中，你需要至少保障一个法定node在线以能够找到拥有最新状态的node。这个node将会成为新的master。因此，推荐运行至少3个replica nodes，以防止一个node失败了，服务中断。</p>
<p><img src="/img/Replicated LevelDB Store方式.png" alt="Replicated LevelDB Store方式"></p>
<h3 id="2、Broker-Cluster部署方式"><a href="#2、Broker-Cluster部署方式" class="headerlink" title="2、Broker-Cluster部署方式"></a>2、Broker-Cluster部署方式</h3><p>前面的Master-Slave的方式虽然能解决多服务热备的高可用问题，但无法解决负载均衡和分布式的问题。Broker-Cluster的部署方式就可以解决负载均衡的问题。</p>
<p>Broker-Cluster部署方式中，各个broker通过网络互相连接，并共享queue。当broker-A上面指定的queue-A中接收到一个message处于pending状态，而此时没有consumer连接broker-A时。如果cluster中的broker-B上面有一个consumer在消费queue-A的消息，那么broker-B会先通过内部网络获取到broker-A上面的message，并通知自己的consumer来消费。</p>
<h4 id="1）static-Broker-Cluster部署"><a href="#1）static-Broker-Cluster部署" class="headerlink" title="1）static Broker-Cluster部署"></a>1）static Broker-Cluster部署</h4><p>在<code>activemq.xml</code>文件中静态指定Broker需要建立桥连接的其他Broker：</p>
<h5 id="1、首先在Broker-A节点中添加networkConnector节点："><a href="#1、首先在Broker-A节点中添加networkConnector节点：" class="headerlink" title="1、首先在Broker-A节点中添加networkConnector节点："></a>1、首先在Broker-A节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61617)&quot;duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="2、修改Broker-A节点中的服务提供端口为61616："><a href="#2、修改Broker-A节点中的服务提供端口为61616：" class="headerlink" title="2、修改Broker-A节点中的服务提供端口为61616："></a>2、修改Broker-A节点中的服务提供端口为61616：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<p>#####3、  在Broker-B节点中添加networkConnector节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61616)&quot;duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure></p>
<h5 id="4、修改Broker-A节点中的服务提供端口为61617："><a href="#4、修改Broker-A节点中的服务提供端口为61617：" class="headerlink" title="4、修改Broker-A节点中的服务提供端口为61617："></a>4、修改Broker-A节点中的服务提供端口为61617：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61617?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="5、分别启动Broker-A和Broker-B。"><a href="#5、分别启动Broker-A和Broker-B。" class="headerlink" title="5、分别启动Broker-A和Broker-B。"></a>5、分别启动Broker-A和Broker-B。</h5><h4 id="2）Dynamic-Broker-Cluster部署"><a href="#2）Dynamic-Broker-Cluster部署" class="headerlink" title="2）Dynamic Broker-Cluster部署"></a>2）Dynamic Broker-Cluster部署</h4><p>在<code>activemq.xml</code>文件中不直接指定Broker需要建立桥连接的其他Broker，由activemq在启动后动态查找：</p>
<h5 id="1、首先在Broker-A节点中添加networkConnector节点：-1"><a href="#1、首先在Broker-A节点中添加networkConnector节点：-1" class="headerlink" title="1、首先在Broker-A节点中添加networkConnector节点："></a>1、首先在Broker-A节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnectoruri=&quot;multicast://default&quot;</div><div class="line">           dynamicOnly=&quot;true&quot;</div><div class="line">           networkTTL=&quot;3&quot;</div><div class="line">           prefetchSize=&quot;1&quot;</div><div class="line">           decreaseNetworkConsumerPriority=&quot;true&quot; /&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="2、修改Broker-A节点中的服务提供端口为61616：-1"><a href="#2、修改Broker-A节点中的服务提供端口为61616：-1" class="headerlink" title="2、修改Broker-A节点中的服务提供端口为61616："></a>2、修改Broker-A节点中的服务提供端口为61616：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61616? &quot; discoveryUri=&quot;multicast://default&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="3、在Broker-B节点中添加networkConnector节点："><a href="#3、在Broker-B节点中添加networkConnector节点：" class="headerlink" title="3、在Broker-B节点中添加networkConnector节点："></a>3、在Broker-B节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">                &lt;networkConnectoruri=&quot;multicast://default&quot;</div><div class="line">           dynamicOnly=&quot;true&quot;</div><div class="line">           networkTTL=&quot;3&quot;</div><div class="line">           prefetchSize=&quot;1&quot;</div><div class="line">           decreaseNetworkConsumerPriority=&quot;true&quot; /&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="4、修改Broker-B节点中的服务提供端口为61617："><a href="#4、修改Broker-B节点中的服务提供端口为61617：" class="headerlink" title="4、修改Broker-B节点中的服务提供端口为61617："></a>4、修改Broker-B节点中的服务提供端口为61617：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61617&quot; discoveryUri=&quot;multicast://default&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="5、启动Broker-A和Broker-B"><a href="#5、启动Broker-A和Broker-B" class="headerlink" title="5、启动Broker-A和Broker-B"></a>5、启动Broker-A和Broker-B</h5><h3 id="2、Master-Slave与Broker-Cluster相结合的部署方式"><a href="#2、Master-Slave与Broker-Cluster相结合的部署方式" class="headerlink" title="2、Master-Slave与Broker-Cluster相结合的部署方式"></a>2、Master-Slave与Broker-Cluster相结合的部署方式</h3><p>可以看到Master-Slave的部署方式虽然解决了高可用的问题，但不支持负载均衡，Broker-Cluster解决了负载均衡，但当其中一个Broker突然宕掉的话，那么存在于该Broker上处于Pending状态的message将会丢失，无法达到高可用的目的。</p>
<p><img src="/img/activemqMaster-Slave与Broker-Cluster相结合的部署方式.png" alt="activemqMaster-Slave与Broker-Cluster相结合的部署方式"></p>
<h4 id="1、部署的配置修改"><a href="#1、部署的配置修改" class="headerlink" title="1、部署的配置修改"></a>1、部署的配置修改</h4><p>这里以Broker-A + Broker-B建立cluster，Broker-C作为Broker-B的slave为例：</p>
<h5 id="1）首先在Broker-A节点中添加networkConnector节点："><a href="#1）首先在Broker-A节点中添加networkConnector节点：" class="headerlink" title="1）首先在Broker-A节点中添加networkConnector节点："></a>1）首先在Broker-A节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;masterslave:(tcp://0.0.0.0:61617,tcp:// 0.0.0.0:61618)&quot; duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="2）修改Broker-A节点中的服务提供端口为61616："><a href="#2）修改Broker-A节点中的服务提供端口为61616：" class="headerlink" title="2）修改Broker-A节点中的服务提供端口为61616："></a>2）修改Broker-A节点中的服务提供端口为61616：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">     &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61616?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<h5 id="3）在Broker-B节点中添加networkConnector节点："><a href="#3）在Broker-B节点中添加networkConnector节点：" class="headerlink" title="3）在Broker-B节点中添加networkConnector节点："></a>3）在Broker-B节点中添加networkConnector节点：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61616)&quot;duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure>
<h4 id="4）修改Broker-B节点中的服务提供端口为61617："><a href="#4）修改Broker-B节点中的服务提供端口为61617：" class="headerlink" title="4）修改Broker-B节点中的服务提供端口为61617："></a>4）修改Broker-B节点中的服务提供端口为61617：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line"></div><div class="line">         &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61617?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line"></div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure>
<p>5）修改Broker-B节点中的持久化方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">     &lt;kahaDB directory=&quot;/localhost/kahadb&quot;/&gt;</div><div class="line">  &lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure></p>
<p>6）在Broker-C节点中添加networkConnector节点：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;networkConnectors&gt; </div><div class="line">    &lt;networkConnector   uri=&quot;static:(tcp:// 0.0.0.0:61616)&quot;duplex=&quot;false&quot;/&gt;</div><div class="line">&lt;/networkConnectors&gt;</div></pre></td></tr></table></figure></p>
<p>7）修改Broker-C节点中的服务提供端口为61618：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;transportConnectors&gt;</div><div class="line">    &lt;transportConnectorname=&quot;openwire&quot;uri=&quot;tcp://0.0.0.0:61618?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600&quot;/&gt;</div><div class="line">&lt;/transportConnectors&gt;</div></pre></td></tr></table></figure></p>
<p>8）修改Broker-C节点中的持久化方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;persistenceAdapter&gt;</div><div class="line">     &lt;kahaDB directory=&quot;/localhost/kahadb&quot;/&gt;</div><div class="line"> &lt;/persistenceAdapter&gt;</div></pre></td></tr></table></figure></p>
<p>9）分别启动broker-A、broker-B、broker-C，因为是broker-B先启动，所以“/localhost/kahadb”目录被lock住，broker-C将一直处于挂起状态，当人为停掉broker-B之后，broker-C将获取目录“/localhost/kahadb”的控制权，重新与broker-A组成cluster提供服务。</p>
]]></content>
    
    <summary type="html">
    
      ActiveMQ实现负载均衡+高可用部署方案
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActiveMQ/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ理解</title>
    <link href="http://jishusuishouji.github.io/2017/04/06/activemq/ActiveMQ%E7%90%86%E8%A7%A3/"/>
    <id>http://jishusuishouji.github.io/2017/04/06/activemq/ActiveMQ理解/</id>
    <published>2017-04-05T20:25:34.000Z</published>
    <updated>2017-04-05T22:12:57.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Running-Broker"><a href="#Running-Broker" class="headerlink" title="Running Broker"></a>Running Broker</h2><p>直接运行bin/activemq脚本可以启动一个broker。</p>
<p>此外也可以通过Broker Configuration URI或Broker XBean URI对broker进行配置，以下是一些命令行参数的例子：</p>
<ul>
<li><code>activemq</code> Runs a broker using the default ‘<code>xbean:activemq.xml</code>‘ as the broker configuration file. </li>
<li><code>activemq xbean:myconfig.xml</code> Runs a broker using the file <code>myconfig.xml</code> as the broker configuration file that is located in the classpath. </li>
<li><code>activemq xbean:file:./conf/broker1.xml</code> Runs a broker using the file <code>broker1.xml</code> as the broker configuration file that is located in the relative file path <code>./conf/broker1.xml</code> </li>
<li><code>activemq xbean:file:C:/ActiveMQ/conf/broker2.xml</code> Runs a broker using the file <code>broker2.xml</code> as the broker configuration file that is located in the absolute file path <code>C:/ActiveMQ/conf/broker2.xml</code> </li>
<li><code>activemq broker:(tcp://localhost:61616, tcp://localhost:5000)?useJmx=true</code> Runs a broker with two transport connectors and JMX enabled. </li>
<li><code>activemq broker:(tcp://localhost:61616, network:tcp://localhost:5000)?persistent=false</code> Runs a broker with 1 transport connector and 1 network connector with persistence disabled. </li>
</ul>
<h2 id="Embedded-Broker"><a href="#Embedded-Broker" class="headerlink" title="Embedded Broker"></a>Embedded Broker</h2><p>可以通过在应用程序中以编码的方式启动broker，例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = new BrokerService(); </div><div class="line">broker.addConnector(&quot;tcp://localhost:61616&quot;); </div><div class="line">broker.start();</div></pre></td></tr></table></figure>
<p>如果需要启动多个broker，那么需要为broker设置一个名字。例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = new BrokerService(); </div><div class="line">broker.setName(&quot;fred&quot;); </div><div class="line">broker.addConnector(&quot;tcp://localhost:61616&quot;); </div><div class="line">broker.start();</div></pre></td></tr></table></figure>
<p>如果希望在同一个JVM内访问这个broker，那么可以使用VM Transport，URI是：<code>vm://brokerName</code>。 </p>
<h2 id="可以通过BrokerFactory来创建broker，例如："><a href="#可以通过BrokerFactory来创建broker，例如：" class="headerlink" title="可以通过BrokerFactory来创建broker，例如："></a>可以通过<code>BrokerFactory</code>来创建broker，例如：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = BrokerFactory.createBroker(new URI(someURI));</div></pre></td></tr></table></figure>
<p><code>someURI</code>的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">示例</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>xbean:</code></td>
<td style="text-align:center"><code>xbean:activemq.xml</code></td>
<td style="text-align:center">Searches the classpath for an XML document with the given URI (<code>activemq.xml</code> in this case) which will then be used as the Xml Configuration</td>
</tr>
<tr>
<td style="text-align:center"><code>file:</code></td>
<td style="text-align:center"><code>file:foo/bar/activemq.xml</code></td>
<td style="text-align:center">Loads the given file (in this example <code>foo/bar/activemq.xml</code>) as the Xml Configuration</td>
</tr>
<tr>
<td style="text-align:center"><code>broker:</code></td>
<td style="text-align:center"><code>broker:tcp://localhost:61616</code></td>
<td style="text-align:center">Uses the Broker Configuration URI to configure the broker</td>
</tr>
</tbody>
</table>
<p>当使用<code>XBean</code>的配置方式的时候，需要指定一个xml配置文件，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BrokerService broker = BrokerFactory.createBroker(new URI(&quot;xbean:com/test/activemq.xml&quot;));</div></pre></td></tr></table></figure></p>
<p>使用Spring的配置方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;broker&quot; class=&quot;org.apache.activemq.xbean.BrokerFactoryBean&quot;&gt; </div><div class="line">   &lt;property name=&quot;config&quot; value=&quot;classpath:org/apache/activemq/xbean/activemq.xml&quot; /&gt; </div><div class="line">   &lt;property name=&quot;start&quot; value=&quot;true&quot; /&gt; </div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Monitoring-Broker"><a href="#Monitoring-Broker" class="headerlink" title="Monitoring Broker"></a>Monitoring Broker</h2><h3 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h3><p>在使用JMX监控broker之前，首先要启用broker的JMX监控功能，例如在配置文件中设置<code>useJmx=&quot;true&quot;</code>，如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;broker useJmx=&quot;true&quot; brokerName=&quot;broker1&gt; </div><div class="line">    &lt;managementContext&gt; </div><div class="line">         &lt;managementContext createConnector=&quot;true&quot;/&gt; </div><div class="line">    &lt;/managementContext&gt; </div><div class="line"> ... </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure>
<p>接下来运行JDK自带的jconsole。在运行了jconsole后，它会弹出对话框来选择需要连接到的<code>agent</code>。如果是在启动broker的主机上运行jconsole，那么ActiveMQ broker会出现在jconsole的Local标签中。如果要连接到远程的broker，那么可以在Advanced标签中指定JMX URL，以下是一个连接到本机的JMX URL：<br><code>service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi</code><br>在jconsole的MBeans标签中，可以查看详细信息，也可以执行相应的operation。需要注意的是，在jconsole连接到broker的时候，并不需要输入用户名和密码，如果这存在潜在的安全问题，那么就需要为JMX Connector配置密码保护（需要使用1.5以上版本的JDK）。 </p>
<p>首先要禁止ActiveMQ创建自己的connector，例如： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.org/config/1.0&quot; brokerName=&quot;localhost&quot;useJmx=&quot;true&quot;&gt; </div><div class="line">    &lt;managementContext&gt; </div><div class="line">        &lt;managementContext createConnector=&quot;false&quot;/&gt; </div><div class="line">    &lt;/managementContext&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure>
<p>然后在ActiveMQ的<code>conf</code>目录下创建一个访问控制文件和密码文件，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">conf/jmx.access： </div><div class="line"># The &quot;monitorRole&quot; role has readonly access. </div><div class="line"># The &quot;controlRole&quot; role has readwrite access. </div><div class="line">monitorRole readonly </div><div class="line">controlRole readwrite</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">conf/jmx.password： </div><div class="line"># The &quot;monitorRole&quot; role has password &quot;abc123&quot;. </div><div class="line"># The &quot;controlRole&quot; role has password &quot;abcd1234&quot;. </div><div class="line">monitorRole abc123 </div><div class="line">controlRole abcd1234</div></pre></td></tr></table></figure>
<p>然后修改ActiveMQ的bin目录下activemq的启动脚本，查找包含”<code>SUNJMX=</code>“的一行如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">REM set SUNJMX=-Dcom.sun.management.jmxremote.port=1616 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false</div></pre></td></tr></table></figure>
<p>把它替换成 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">set SUNJMX=-Dcom.sun.management.jmxremote.port=1616 -Dcom.sun.management.jmxremote.authenticate=true -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.password.file=%ACTIVEMQ_BASE%/conf/jmx.password -Dcom.sun.management.jmxremote.access.file=%ACTIVEMQ_BASE%/conf/jmx.access</div></pre></td></tr></table></figure>
<p>最后重启ActiveMQ和jconsole，这时候需要强制login。如果在启动activemq的过程中出现以下错误，那么需要为这个文件增加访问控制。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error: Password file read access must be restricted: D:\apache-activemq-5.0.0\bin\../conf/jmx.password</div></pre></td></tr></table></figure></p>
<h3 id="Web-Console"><a href="#Web-Console" class="headerlink" title="Web Console"></a>Web Console</h3><p>Web Console被集成到了ActiveMQ的二进制发布包中，因此缺省访问<code>http://localhost:8161/admin</code>即可访问Web Console。<br>在配置文件中，可以通过修改<code>nioConnector</code>的<code>port</code>属性来修改Web console的缺省端口： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;jetty xmlns=&quot;http://mortbay.com/schemas/jetty/1.0&quot;&gt; </div><div class="line">        &lt;connectors&gt; </div><div class="line">                &lt;nioConnector port=&quot;8161&quot; /&gt; </div><div class="line">        &lt;/connectors&gt; </div><div class="line">        ... </div><div class="line">&lt;/jetty&gt;</div></pre></td></tr></table></figure>
<p>出于安全性或者可靠性的考虑，Web Console可以被部署到不同于ActiveMQ的进程中。例如把<code>activemq-web-console.war</code>部署到一个单独的web容器中（Tomcat，Jetty等）。在ActiveMQ5.0的二进制发布包中不包含<code>activemq-web-console.war</code>，因此需要下载 ActiveMQ的源码，然后进入到<code>${activemq.base}/src/activemq-web-console</code>目录中执行<code>mvn instanll</code>。如果一切正常，那么缺省会在<code>${activemq.base}/src/activemq-web-console/target</code>目录中生成<code>activemq-web-console-5.0.0.war</code>。然后将<code>activemq-web-console-5.0.0.war</code>拷贝到Tomcat的<code>webapps</code>目录中，并重命名成<code>activemq-web-console.war</code>。<br>需要注意的是，要将<code>activemq-all-5.0.0.jar</code>拷贝到<code>WEB-INF\lib</code>目录中（可能还需要拷贝<code>jms.jar</code>）。还要为Tomcat设置以下五个系统属性（修改<code>catalina.bat</code>文件）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.type=&quot;properties&quot; </div><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.jms.url=&quot;tcp://localhost:61616&quot; </div><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.jmx.url=&quot;service:jmx:rmi:///jndi/rmi://localhost:1099/jmxrmi&quot; </div><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.jmx.role=&quot;&quot; </div><div class="line">set JAVA_OPTS=%JAVA_OPTS% -Dwebconsole.jmx.password=&quot;&quot;</div></pre></td></tr></table></figure></p>
<p>如果JMX没有配置密码保护，那么<code>webconsole.jmx.role</code>和<code>webconsole.jmx.password</code>设置成<code>&quot;&quot;</code>即可。如果broker被配置成了Master/Slave模式，那么可以配置成使用failover transport，例如： </p>
<pre><code>-Dwebconsole.jms.url=failover:(tcp://serverA:61616,tcp://serverB:61616)
</code></pre><p>顺便说一下，由于<code>webconsole.type</code>属性是<code>properties</code>，因此实际上起作用的Web Console的配置文件是<code>WEB-INF/webconsole-properties.xml</code>。最后启动被监控的ActiveMQ，访问<code>http://localhost:8080 /activemq-web-console/</code>，查看显示是否正常。 </p>
<h3 id="Advisory-Message"><a href="#Advisory-Message" class="headerlink" title="Advisory Message"></a>Advisory Message</h3><p>ActiveMQ支持Advisory Messages，它允许你通过标准的JMS消息来监控系统。目前的Advisory Messages支持：<br>• consumers, producers and connections starting and stopping<br>• temporary destinations being created and destroyed<br>• messages expiring on topics and queues<br>• brokers sending messages to destinations with no consumers.<br>• connections starting and stopping </p>
<p>Advisory Messages可以被想象成某种的管理通道，通过它你可以得到关于JMS provider、producers、consumers和destinations的信息。Advisory topics都使用<code>ActiveMQ.Advisory.</code>这个前缀，以下是目前支持的topics： </p>
<p>Client based advisories<br>Advisory Topics Description<br>ActiveMQ.Advisory.Connection Connection start &amp; stop messages<br>ActiveMQ.Advisory.Producer.Queue Producer start &amp; stop messages on a Queue<br>ActiveMQ.Advisory.Producer.Topic Producer start &amp; stop messages on a Topic<br>ActiveMQ.Advisory.Consumer.Queue Consumer start &amp; stop messages on a Queue<br>ActiveMQ.Advisory.Consumer.Topic Consumer start &amp; stop messages on a Topic </p>
<p>在消费者启动/停止的Advisory Messages的消息头中有个<code>consumerCount</code>属性，它用来指明目前desination上活跃的consumer的数量。<br>Destination and Message based advisories<br>Advisory Topics Description<br>ActiveMQ.Advisory.Queue Queue create &amp; destroy<br>ActiveMQ.Advisory.Topic Topic create &amp; destroy<br>ActiveMQ.Advisory.TempQueue Temporary Queue create &amp; destroy<br>ActiveMQ.Advisory.TempTopic Temporary Topic create &amp; destroy<br>ActiveMQ.Advisory.Expired.Queue Expired messages on a Queue<br>ActiveMQ.Advisory.Expired.Topic Expired messages on a Topic<br>ActiveMQ.Advisory.NoConsumer.Queue No consumer is available to process messages being sent on a Queue<br>ActiveMQ.Advisory.NoConsumer.Topic No consumer is available to process messages being sent on a Topic </p>
<p>以上的这些destnations都可以用来作为前缀，在其后面追加其它的重要信息，例如topic、queue、clientID、 producderID和consumerID等。这令你可以利用Wildcards和Selectors来过滤Advisory Messages。<br>例如，如果你希望订阅<code>FOO.BAR</code>这个queue上Consumer的start/stop的消息，那么可以订阅<code>ActiveMQ.Advisory.Consumer.Queue.FOO.BAR</code>；如果希望订阅所有queue上的start/stop消息，那么可以订阅<code>ActiveMQ.Advisory.Consumer.Queue.</code>；如果希望订阅所有queue或者topic上的start/stop消息，那么可以订阅<code>ActiveMQ.Advisory.Consumer.</code>。<br><code>org.apache.activemq.advisory.AdvisorySupport</code>类上有如下的helper methods，用来在程序中得到advisory destination objects。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">AdvisorySupport.getConsumerAdvisoryTopic() </div><div class="line">AdvisorySupport.getProducerAdvisoryTopic() </div><div class="line">AdvisorySupport.getDestinationAdvisoryTopic() </div><div class="line">AdvisorySupport.getExpiredTopicMessageAdvisoryTopic() </div><div class="line">AdvisorySupport.getExpiredQueueMessageAdvisoryTopic() </div><div class="line">AdvisorySupport.getNoTopicConsumersAdvisoryTopic() </div><div class="line">AdvisorySupport.getNoQueueConsumersAdvisoryTopic()</div></pre></td></tr></table></figure></p>
<p>以下是段使用Advisory Messages的程序代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Destination advisoryDestination = AdvisorySupport.getProducerAdvisoryTopic(destination) </div><div class="line">MessageConsumer consumer = session.createConsumer(advisoryDestination); </div><div class="line">consumer.setMessageListener(this); </div><div class="line">... </div><div class="line">public void onMessage(Message msg)&#123; </div><div class="line">        if (msg instanceof ActiveMQMessage)&#123; </div><div class="line">                try &#123; </div><div class="line">                        ActiveMQMessage aMsg = (ActiveMQMessage)msg; </div><div class="line">                        ProducerInfo prod = (ProducerInfo) aMsg.getDataStructure(); </div><div class="line">                &#125; catch (JMSException e) &#123; </div><div class="line">                        log.error(&quot;Failed to process message: &quot; + msg); </div><div class="line">                &#125; </div><div class="line">        &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Command-Agent"><a href="#Command-Agent" class="headerlink" title="Command Agent"></a>Command Agent</h3><p>在介绍Command Agent前首先简要介绍一下XMPP(Jabber)协议，XMPP是一种基于XML的即时通信协议，它由Jabber软件基金会开发。在配置文件中通过增加<code>transportConnector</code>来支持XMPP协议：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.org/config/1.0&quot;&gt; </div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">        ... </div><div class="line">                &lt;transportConnector name=&quot;xmpp&quot; uri=&quot;xmpp://localhost:61222&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>ActiveMQ提供了ActiveMQ messages和XMPP之间的双向桥接：<br>• 如果客户加入了一个聊天室，那么这个聊天室的名字会被映射到一个JMS topic。<br>• 尝试在聊天室内发送消息会导致一个JMS消息被发送到这个topic。<br>• 呆在一个聊天室中意味着这将保持一个对相应JMS topic的订阅。因此发送到这个topic的JMS消息也会被发送到聊天室。</p>
<p>从4.2版本起，ActiveMQ支持<code>Command Agent</code>。在配置文件中，通过设置<code>commandAgent</code>来启用Command Agent： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt; </div><div class="line">        &lt;broker useJmx=&quot;true&quot; xmlns=&quot;http://activemq.org/config/1.0&quot;&gt; </div><div class="line">        ... </div><div class="line">        &lt;/broker&gt; </div><div class="line">        &lt;commandAgent xmlns=&quot;http://activemq.org/config/1.0&quot;/&gt; </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>启用了Command Agent的broker上会有一个来自Command Agent的连接，它同时订阅topic：<code>ActiveMQ.Agent</code>。在你启动XMPP客户端，加入到<code>ActiveMQ.Agent</code>聊天室后，就可以同broker进行交谈了。通过在XMPP客户端中键入help，可以得到帮助信息。<br>需要注意的是，ActiveMQ5.0版本有个小bug，如果broker没有采用缺省的用户名和密码，那么Command Agent便无法正常启动。Apache官方文档说，此bug已经被修正，预定在5.2.0版本上体现。修改方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;commandAgent xmlns=&quot;http://activemq.org/config/1.0&quot; brokerUser=&quot;user&quot; brokerPassword=&quot;passward&quot;/&gt;</div></pre></td></tr></table></figure></p>
<h3 id="Visualization-plugin"><a href="#Visualization-plugin" class="headerlink" title="Visualization plugin"></a>Visualization plugin</h3><p>ActiveMQ支持以broker插件的形式生成DOT文件(可以用agrviewer来查看)，以图表的方式描述connections、sessions、producers、consumers、destinations等信息。配置方式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;broker xmlns=&quot;http://activemq.org/config/1.0&quot; brokerName=&quot;localhost&quot; useJmx=&quot;true&quot;&gt; </div><div class="line">        ... </div><div class="line">    &lt;plugins&gt; </div><div class="line">        &lt;connectionDotFilePlugin file=&quot;connection.dot&quot;/&gt; </div><div class="line">        &lt;destinationDotFilePlugin file=&quot;destination.dot&quot;/&gt; </div><div class="line">        &lt;/plugins&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>需要注意的是，笔者认为ActiveMQ5.0版本的Visualization Plugin尚不稳定，存在诸多问题。例如：如果使用<code>connectionDotFilePlugin</code>，那么<code>brokerName</code>必须是<code>localhost</code>；如果使用<code>destinationDotFilePlugin</code>可能会导致<code>ArrayStoreException</code>。 </p>
<h2 id="Transport"><a href="#Transport" class="headerlink" title="Transport"></a>Transport</h2><p>ActiveMQ目前支持的transport有：VM Transport、TCP Transport、SSL Transport、Peer Transport、UDP Transport、Multicast Transport、HTTP and HTTPS Transport、Failover Transport、Fanout Transport、Discovery Transport、ZeroConf Transport等。</p>
<h3 id="VM-Transport"><a href="#VM-Transport" class="headerlink" title="VM Transport"></a>VM Transport</h3><p>VM transport允许在VM内部通信，从而避免了网络传输的开销。这时候采用的连接不是socket连接，而是直接地方法调用。 第一个创建VM连接的客户会启动一个embed VM broker，接下来所有使用相同的broker name的VM连接都会使用这个broker。当这个broker上所有的连接都关闭的时候，这个broker也会自动关闭。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vm://brokerName?transportOptions</div></pre></td></tr></table></figure>
<p>例如：<code>vm://broker1?marshal=false&amp;broker.persistent=false</code><br>Transport Options的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Option Name</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Marshal</td>
<td style="text-align:center">false</td>
<td style="text-align:center">If true, forces each command sent over the transport to be marshlled and unmarshlled using a WireFormat</td>
</tr>
<tr>
<td style="text-align:center">wireFormat</td>
<td style="text-align:center">default</td>
<td style="text-align:center">The name of the WireFormat to use </td>
</tr>
</tbody>
</table>
<p>wireFormat.<em> All the properties with this prefix are used to configure the wireFormat |<br>| create |  true |  If the broker should be created on demand if it does not allready exist. Only supported in ActiveMQ 4.1 |<br>| broker.</em>  | All  | the properties with this prefix are used to configure the broker. See Configuring Wire Formats for more information  | </p>
<p>以下是高级配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">vm:(broker:(tcp://localhost)?brokerOptions)?transportOptions </div><div class="line">vm:broker:(tcp://localhost)?brokerOptions</div></pre></td></tr></table></figure></p>
<p>例如：<code>vm:(broker:(tcp://localhost:6000)?persistent=false)?marshal=false</code> </p>
<p>使用配置文件的配置语法：<br><code>vm://localhost?brokerConfig=xbean:activemq.xml</code><br>例如：<code>vm:// localhost?brokerConfig=xbean:com/test/activemq.xml</code></p>
<p>使用Spring的配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;broker&quot; class=&quot;org.apache.activemq.xbean.BrokerFactoryBean&quot;&gt; </div><div class="line">        &lt;property name=&quot;config&quot; value=&quot;classpath:org/apache/activemq/xbean/activemq.xml&quot; /&gt; </div><div class="line">        &lt;property name=&quot;start&quot; value=&quot;true&quot; /&gt; </div><div class="line">        &lt;/bean&gt; </div><div class="line"></div><div class="line">&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot; depends-on=&quot;broker&quot;&gt; </div><div class="line">&lt;property name=&quot;brokerURL&quot; value=&quot;vm://localhost&quot;/&gt; </div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure></p>
<p>如果<code>persistent</code>是<code>true</code>，那么ActiveMQ会在当前目录下创建一个缺省值是<code>activemq-data</code>的目录用于持久化保存数据。需要注意的是，如果程序中启动了多个不同名字的VM broker，那么可能会有如下警告：<code>Failed to start jmx connector: Cannot bind to URL [rmi://localhost:1099/jmxrmi]:javax.naming.NameAlreadyBoundException…</code>可以通过在<code>transportOptions</code>中追加<code>broker.useJmx=false</code>来禁用JMX来避免这个警告。 </p>
<h3 id="TCP-Transport"><a href="#TCP-Transport" class="headerlink" title="TCP Transport"></a>TCP Transport</h3><p>TCP transport 允许客户端通过TCP socket连接到远程的broker。以下是配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tcp://hostname:port?transportOptions</div></pre></td></tr></table></figure></p>
<p>Transport Options的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Option Name</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">minmumWireFormatVersion</td>
<td style="text-align:center">0</td>
<td style="text-align:center">The minimum version wireformat that is allowed</td>
</tr>
<tr>
<td style="text-align:center">trace</td>
<td style="text-align:center">false</td>
<td style="text-align:center">Causes all commands that are sent over the transport to be logged</td>
</tr>
<tr>
<td style="text-align:center">useLocalHost</td>
<td style="text-align:center">true</td>
<td style="text-align:center">When true, it causes the local machines name to resolve to “localhost”.</td>
</tr>
<tr>
<td style="text-align:center">socketBufferSize</td>
<td style="text-align:center">64 * 1024</td>
<td style="text-align:center">Sets the socket buffer size in bytes </td>
</tr>
</tbody>
</table>
<p>soTimeout 0 sets the socket timeout in milliseconds |<br>| connectionTimeout | 30000 | A non-zero value specifies the connection timeout in milliseconds. A zero value means wait forever for the connection to be established. Negative values are ignored. |<br>| wireFormat | default | The name of the WireFormat to use wireFormat.* All the properties with this prefix are used to configure the wireFormat. See Configuring Wire Formats for more information  | </p>
<p>例如：<code>tcp://localhost:61616?trace=false</code> </p>
<h3 id="Failover-Transport"><a href="#Failover-Transport" class="headerlink" title="Failover Transport"></a>Failover Transport</h3><p>Failover Transport是一种重新连接的机制，它工作于其它transport的上层，用于建立可靠的传输。它的配置语法允许制定任意多个复合的URI。Failover transport会自动选择其中的一个URI来尝试建立连接。如果没有成功，那么会选择一个其它的URI来建立一个新的连接。以下是配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">failover:(uri1,...,uriN)?transportOptions </div><div class="line">failover:uri1,...,uriN</div></pre></td></tr></table></figure></p>
<p>Transport Options的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Option Name</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">initialReconnectDelay</td>
<td style="text-align:center">10</td>
<td style="text-align:center">How long to wait before the first reconnect attempt (in ms)</td>
</tr>
<tr>
<td style="text-align:center">maxReconnectDelay</td>
<td style="text-align:center">30000</td>
<td style="text-align:center">The maximum amount of time we ever wait between reconnect attempts (in ms)</td>
</tr>
<tr>
<td style="text-align:center">useExponentialBackOff</td>
<td style="text-align:center">true</td>
<td style="text-align:center">Should an exponential backoff be used between reconnect attempts</td>
</tr>
<tr>
<td style="text-align:center">backOffMultiplier</td>
<td style="text-align:center">2</td>
<td style="text-align:center">The exponent used in the exponential backoff attempts</td>
</tr>
<tr>
<td style="text-align:center">maxReconnectAttempts</td>
<td style="text-align:center">0</td>
<td style="text-align:center">If not 0, then this is the maximum number of reconnect attempts before an error is sent back to the client</td>
</tr>
<tr>
<td style="text-align:center">randomize</td>
<td style="text-align:center">true</td>
<td style="text-align:center">use a random algorithm to choose the URI to use for reconnect from the list provided</td>
</tr>
<tr>
<td style="text-align:center">backup</td>
<td style="text-align:center">false</td>
<td style="text-align:center">initialize and hold a second transport connection - to enable fast failover</td>
</tr>
</tbody>
</table>
<p>例如：<code>failover:(tcp://localhost:61616,tcp://remotehost:61616)?initialReconnectDelay=100</code></p>
<h3 id="Discovery-transport"><a href="#Discovery-transport" class="headerlink" title="Discovery transport"></a>Discovery transport</h3><p>Discovery transport是可靠的tranport。它使用Discovery transport来定位用来连接的URI列表。以下是配置语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">discovery:(discoveryAgentURI)?transportOptions </div><div class="line">discovery:discoveryAgentURI</div></pre></td></tr></table></figure></p>
<p>Transport Options的可选值如下： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Option Name</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">initialReconnectDelay</td>
<td style="text-align:center">10</td>
<td style="text-align:center">How long to wait before the first reconnect attempt</td>
</tr>
<tr>
<td style="text-align:center">maxReconnectDelay</td>
<td style="text-align:center">30000</td>
<td style="text-align:center">The maximum amount of time we ever wait between reconnect attempts</td>
</tr>
<tr>
<td style="text-align:center">useExponentialBackOff</td>
<td style="text-align:center">true</td>
<td style="text-align:center">Should an exponential backoff be used btween reconnect attempts</td>
</tr>
<tr>
<td style="text-align:center">backOffMultiplier</td>
<td style="text-align:center">2</td>
<td style="text-align:center">The exponent used in the exponential backoff attempts</td>
</tr>
<tr>
<td style="text-align:center">maxReconnectAttempts</td>
<td style="text-align:center">0</td>
<td style="text-align:center">If not 0, then this is the maximum number of reconnect attempts before an error is sent back to the client</td>
</tr>
</tbody>
</table>
<p>例如：<code>discovery:(multicast://default)?initialReconnectDelay=100</code><br>为了使用Discovery来发现broker，需要为broker启用discovery agent。 以下是XML配置文件中的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;broker name=&quot;foo&quot;&gt; </div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">                &lt;transportConnector uri=&quot;tcp://localhost:0&quot; discoveryUri=&quot;multicast://default&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line">... </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>在使用Failover Transport或Discovery transport等能够自动重连的transport的时候，需要注意的是：设想有两个broker，它们都启用AMQ Message Store作为持久化存储，有一个producer和一个consumer连接到某个queue。当因其中一个broker失效时而切换到另一个 broker的时候，如果失效的broker的queue中还有未被consumer消费的消息，那么这个queue里的消息仍然滞留在失效broker 的中，直到失效的broker被修复并重新切换回这个被修复的broker后，之前被保留的消息才会被consumer消费掉。如果被处理的消息有时序限制，那么应用程序就需要处理这个问题。另外也可以通过ActiveMQ集群来解决这个问题。<br>在transport重连的时候，可以在connection上注册<code>TransportListener</code>来获得回调，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(ActiveMQConnection)connection).addTransportListener(new TransportListener() &#123; </div><div class="line">public void onCommand(Object cmd) &#123; </div><div class="line">&#125; </div><div class="line"></div><div class="line">public void onException(IOException exp) &#123; </div><div class="line">&#125; </div><div class="line"></div><div class="line">public void transportInterupted() &#123; </div><div class="line">// The transport has suffered an interruption from which it hopes to recover. </div><div class="line">&#125; </div><div class="line"> </div><div class="line">public void transportResumed() &#123; </div><div class="line">// The transport has resumed after an interruption. </div><div class="line">&#125; </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h2><h3 id="AMQ-Message-Store"><a href="#AMQ-Message-Store" class="headerlink" title="AMQ Message Store"></a>AMQ Message Store</h3><p>AMQ Message Store是ActiveMQ5.0缺省的持久化存储。Message commands被保存到transactional journal（由rolling data logs组成）。Messages被保存到data logs中，同时被reference store进行索引以提高存取速度。Date logs由一些单独的data log文件组成，缺省的文件大小是32M，如果某个消息的大小超过了data log文件的大小，那么可以修改配置以增加data log文件的大小。如果某个data log文件中所有的消息都被成功消费了，那么这个data log文件将会被标记，以便在下一轮的清理中被删除或者归档。以下是其配置的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=&quot;broker&quot; persistent=&quot;true&quot; useShutdownHook=&quot;false&quot;&gt; </div><div class="line">        &lt;persistenceAdapter&gt; </div><div class="line">                &lt;amqPersistenceAdapter directory=&quot;$&#123;activemq.base&#125;/data&quot; maxFileLength=&quot;32mb&quot;/&gt; </div><div class="line">        &lt;/persistenceAdapter&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th style="text-align:center">Property name</th>
<th style="text-align:center">Default value</th>
<th style="text-align:center">Comments</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">directory</td>
<td style="text-align:center">activemq-data</td>
<td style="text-align:center">the path to the directory to use to store the message store data and log files</td>
</tr>
<tr>
<td style="text-align:center">useNIO</td>
<td style="text-align:center">true</td>
<td style="text-align:center">use NIO to write messages to the data logs</td>
</tr>
<tr>
<td style="text-align:center">syncOnWrite</td>
<td style="text-align:center">false</td>
<td style="text-align:center">sync every write to disk</td>
</tr>
<tr>
<td style="text-align:center">maxFileLength</td>
<td style="text-align:center">32mb</td>
<td style="text-align:center">a hint to set the maximum size of the message data logs</td>
</tr>
<tr>
<td style="text-align:center">persistentIndex</td>
<td style="text-align:center">true</td>
<td style="text-align:center">use a persistent index for the message logs. If this is false, an in-memory structure is maintained</td>
</tr>
<tr>
<td style="text-align:center">maxCheckpointMessageAddSize</td>
<td style="text-align:center">4kb</td>
<td style="text-align:center">the maximum number of messages to keep in a transaction before automatically committing</td>
</tr>
<tr>
<td style="text-align:center">cleanupInterval</td>
<td style="text-align:center">30000</td>
<td style="text-align:center">time (ms) before checking for a discarding/moving message data logs that are no longer used</td>
</tr>
<tr>
<td style="text-align:center">indexBinSize</td>
<td style="text-align:center">1024</td>
<td style="text-align:center">default number of bins used by the index. The bigger the bin size - the better the relative performance of the index</td>
</tr>
<tr>
<td style="text-align:center">indexKeySize</td>
<td style="text-align:center">96</td>
<td style="text-align:center">the size of the index key - the key is the message id </td>
</tr>
</tbody>
</table>
<p>indexPageSize 16kb the size of the index page - the bigger the page - the better the write performance of the index  |<br>| directoryArchive | archive | the path to the directory to use to store discarded data logs |<br>| archiveDataLogs | false | if true data logs are moved to the archive directory instead of being deleted | </p>
<h3 id="Kaha-Persistence"><a href="#Kaha-Persistence" class="headerlink" title="Kaha Persistence"></a>Kaha Persistence</h3><p>Kaha Persistence 是一个专门针对消息持久化的解决方案。它对典型的消息使用模式进行了优化。在Kaha中，数据被追加到data logs中。当不再需要log文件中的数据的时候，log文件会被丢弃。以下是其配置的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=&quot;broker&quot; persistent=&quot;true&quot; useShutdownHook=&quot;false&quot;&gt; </div><div class="line">        &lt;persistenceAdapter&gt; </div><div class="line">                &lt;kahaPersistenceAdapter directory=&quot;activemq-data&quot;       maxDataFileLength=&quot;33554432&quot;/&gt; </div><div class="line">        &lt;/persistenceAdapter&gt; </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<h3 id="JDBC-Persistence"><a href="#JDBC-Persistence" class="headerlink" title="JDBC Persistence"></a>JDBC Persistence</h3><p>目前支持的数据库有Apache Derby, Axion, DB2, HSQL, Informix, MaxDB, MySQL, Oracle, Postgresql, SQLServer, Sybase。<br>如果你使用的数据库不被支持，那么可以调整<code>StatementProvider</code>来保证使用正确的SQL方言（flavour of SQL）。通常绝大多数数据库支持以下adaptor：<br>• org.activemq.store.jdbc.adapter.BlobJDBCAdapter<br>• org.activemq.store.jdbc.adapter.BytesJDBCAdapter<br>• org.activemq.store.jdbc.adapter.DefaultJDBCAdapter<br>• org.activemq.store.jdbc.adapter.ImageJDBCAdapter</p>
<p>也可以在配置文件中直接指定JDBC adaptor，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;jdbcPersistenceAdapter adapterClass=&quot;org.apache.activemq.store.jdbc.adapter.ImageBasedJDBCAdaptor&quot;/&gt;</div></pre></td></tr></table></figure></p>
<p>以下是其配置的一个例子： </p>
<pre><code>&lt;persistence&gt; 
     &lt;jdbcPersistence dataSourceRef=&quot; mysql-ds&quot;/&gt; 
&lt;/persistence&gt; 

&lt;bean id=&quot;mysql-ds&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; 
     &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; 
     &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/activemq?relaxAutoCommit=true&quot;/&gt; 
     &lt;property name=&quot;username&quot; value=&quot;activemq&quot;/&gt; 
     &lt;property name=&quot;password&quot; value=&quot;activemq&quot;/&gt; 
     &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt; 
&lt;/bean&gt; 
</code></pre><p>需要注意的是，如果使用MySQL，那么需要设置<code>relaxAutoCommit</code>标志为<code>true</code>。 </p>
<h3 id="Disable-Persistence"><a href="#Disable-Persistence" class="headerlink" title="Disable Persistence"></a>Disable Persistence</h3><p>以下是其配置的一个例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;broker persistent=&quot;false&quot;&gt;&lt;/broker&gt;</div></pre></td></tr></table></figure>
<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><p>ActiveMQ支持可插拔的安全机制，用以在不同的provider之间切换。 </p>
<h3 id="Simple-Authentication-Plugin"><a href="#Simple-Authentication-Plugin" class="headerlink" title="Simple Authentication Plugin"></a>Simple Authentication Plugin</h3><p>Simple Authentication Plugin适用于简单的认证需求，或者用于建立测试环境。它允许在XML配置文件中指定用户、用户组和密码等信息。以下是ActiveMQ配置的一个例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;plugins&gt; </div><div class="line">        ... </div><div class="line">        &lt;simpleAuthenticationPlugin&gt; </div><div class="line">                &lt;users&gt; </div><div class="line">                     &lt;authenticationUser username=&quot;system&quot; password=&quot;manager&quot;   groups=&quot;users,admins&quot;/&gt; </div><div class="line">                     &lt;authenticationUser username=&quot;user&quot; password=&quot;password&quot; groups=&quot;users&quot;/&gt; </div><div class="line">                     &lt;authenticationUser username=&quot;guest&quot; password=&quot;password&quot; groups=&quot;guests&quot;/&gt; </div><div class="line">                &lt;/users&gt; </div><div class="line">        &lt;/simpleAuthenticationPlugin&gt; </div><div class="line">&lt;/plugins&gt;</div></pre></td></tr></table></figure>
<h3 id="JAAS-Authentication-Plugin"><a href="#JAAS-Authentication-Plugin" class="headerlink" title="JAAS Authentication Plugin"></a>JAAS Authentication Plugin</h3><p>JAAS Authentication Plugin依赖标准的JAAS机制来实现认证。通常情况下，你需要通过设置<code>java.security.auth.login.config</code>系统属性来配置login modules的配置文件。如果没有指定这个系统属性，那么JAAS Authentication Plugin会缺省使用<code>login.config</code>作为文件名。以下是一个<code>login.config</code>文件的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">activemq-domain &#123; </div><div class="line">        org.apache.activemq.jaas.PropertiesLoginModule required debug=true org.apache.activemq.jaas.properties.user=&quot;users.properties&quot; org.apache.activemq.jaas.properties.group=&quot;groups.properties&quot;; </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这个<code>login.config</code>文件中设置了两个属性：<code>org.apache.activemq.jaas.properties.user</code>和<code>org.apache.activemq.jaas.properties.group</code>分别用来指向<code>user.properties</code>和<code>group.properties</code>文件。需要注意的是，<code>PropertiesLoginModule</code>使用本地文件的查找方式，而且查找时采用的base directory是<code>login.config</code>文件所在的目录。因此这个<code>login.config</code>说明<code>user.properties</code>和<code>group.properties</code>文件存放在跟<code>login.config</code>文件相同的目录里。<br>以下是ActiveMQ配置的一个例子： </p>
<pre><code>&lt;plugins&gt; 
        ... 
        &lt;jaasAuthenticationPlugin configuration=&quot;activemq-domain&quot; /&gt; 
&lt;/plugins&gt; 
</code></pre><p>基于以上的配置，在JAAS的<code>LoginContext</code>中会使用<code>activemq-domain</code>中配置的<code>PropertiesLoginModule</code>来进行登陆。<br>ActiveMQ JAAS还支持<code>LDAPLoginModule</code>、<code>CertificateLoginModule</code>、<code>TextFileCertificateLoginModule</code>等login module。 </p>
<h3 id="Custom-Authentication-Implementation"><a href="#Custom-Authentication-Implementation" class="headerlink" title="Custom Authentication Implementation"></a>Custom Authentication Implementation</h3><p>可以通过编码的方式为ActiveMQ增加认证功能。例如编写一个类继承自<code>XBeanBrokerService</code>。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">package com.yourpackage; </div><div class="line"></div><div class="line">import java.net.URI; </div><div class="line">import java.util.HashMap; </div><div class="line">import java.util.Map; </div><div class="line"></div><div class="line">import org.apache.activemq.broker.Broker; </div><div class="line">import org.apache.activemq.broker.BrokerFactory; </div><div class="line">import org.apache.activemq.broker.BrokerService; </div><div class="line">import org.apache.activemq.security.SimpleAuthenticationBroker; </div><div class="line">import org.apache.activemq.xbean.XBeanBrokerService; </div><div class="line"></div><div class="line">public class SimpleAuthBroker extends XBeanBrokerService &#123; </div><div class="line">        // </div><div class="line">        private String user; </div><div class="line">        private String password; </div><div class="line"></div><div class="line">        @SuppressWarnings(&quot;unchecked&quot;) </div><div class="line">        protected Broker addInterceptors(Broker broker) throws Exception &#123; </div><div class="line">                broker = super.addInterceptors(broker); </div><div class="line">                Map passwords = new HashMap(); </div><div class="line">                passwords.put(getUser(), getPassword()); </div><div class="line">                broker = new SimpleAuthenticationBroker(broker, passwords, new HashMap()); </div><div class="line">                return broker; </div><div class="line">        &#125; </div><div class="line"></div><div class="line">        public String getUser() &#123; </div><div class="line">              return user; </div><div class="line">        &#125; </div><div class="line"></div><div class="line">        public void setUser(String user) &#123; </div><div class="line">                this.user = user; </div><div class="line">        &#125; </div><div class="line"> </div><div class="line">    public String getPassword() &#123; </div><div class="line">         return password; </div><div class="line">    &#125; </div><div class="line">     </div><div class="line">    public void setPassword(String password) &#123; </div><div class="line">            this.password = password; </div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是ActiveMQ配置文件的一个例子： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt; </div><div class="line">    … </div><div class="line">    &lt;auth:SimpleAuthBroker </div><div class="line">    xmlns:auth=&quot;java://com.yourpackage&quot; </div><div class="line">    xmlns=&quot;http://activemq.org/config/1.0&quot; brokerName=&quot;SimpleAuthBroker1&quot; user=&quot;user&quot; password=&quot;password&quot; useJmx=&quot;true&quot;&gt; </div><div class="line"></div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">                &lt;transportConnector uri=&quot;tcp://localhost:61616&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line">    &lt;/auth:SimpleAuthBroker&gt; </div><div class="line">    … </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure>
<p>在这个配置文件中增加了一个namespace auth，用于指向之前编写的哪个类。同时为<code>SimpleAuthBroker</code>注入了两个属性值<code>user</code>和<code>password</code>，因此在被<code>SimpleAuthBroker</code>改写的<code>addInterceptors</code>方法里，可以使用这两个属性进行认证了。ActiveMQ提供的<code>SimpleAuthenticationBroker</code>类继承自<code>BrokerFilter</code>可以简单的看成是Broker的Adaptor），它的构造函数中的两个<code>Map</code>分别是<code>userPasswords</code>和<code>userGroups</code>。<br><code>SimpleAuthenticationBroker</code>在<code>addConnection</code>方法中使用<code>userPasswords</code>进行认证，同时会把<code>userGroups</code>的信息保存到<code>ConnectionContext</code>中。</p>
<h3 id="Authorization-Plugin"><a href="#Authorization-Plugin" class="headerlink" title="Authorization Plugin"></a>Authorization Plugin</h3><p>可以通过Authorization Plugin为认证后的用户授权，以下ActiveMQ配置文件的一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;plugins&gt; </div><div class="line">    &lt;jaasAuthenticationPlugin configuration=&quot;activemq-domain&quot;/&gt;  </div><div class="line">    &lt;authorizationPlugin&gt; </div><div class="line">        &lt;map&gt; </div><div class="line">            &lt;authorizationMap&gt; </div><div class="line">                &lt;authorizationEntries&gt; </div><div class="line">                    &lt;authorizationEntry queue=&quot;&gt;&quot; read=&quot;admins&quot; write=&quot;admins&quot; admin=&quot;admins&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry queue=&quot;USERS.&gt;&quot; read=&quot;users&quot; write=&quot;users&quot; admin=&quot;users&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry queue=&quot;GUEST.&gt;&quot; read=&quot;guests&quot; write=&quot;guests,users&quot; admin=&quot;guests,users&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry topic=&quot;&gt;&quot; read=&quot;admins&quot; write=&quot;admins&quot; admin=&quot;admins&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry topic=&quot;USERS.&gt;&quot; read=&quot;users&quot; write=&quot;users&quot; admin=&quot;users&quot; /&gt; </div><div class="line">                    &lt;authorizationEntry topic=&quot;GUEST.&gt;&quot; read=&quot;guests&quot; write=&quot;guests,users&quot; admin=&quot;guests,users&quot; /&gt; </div><div class="line">     </div><div class="line">                    &lt;authorizationEntry topic=&quot;ActiveMQ.Advisory.&gt;&quot; read=&quot;guests,users&quot; write=&quot;guests,users&quot; admin=&quot;guests,users&quot;/&gt; </div><div class="line">                &lt;/authorizationEntries&gt; </div><div class="line">            &lt;/authorizationMap&gt; </div><div class="line">        &lt;/map&gt; </div><div class="line">    &lt;/authorizationPlugin&gt; </div><div class="line">&lt;/plugins&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Clustering"><a href="#Clustering" class="headerlink" title="Clustering"></a>Clustering</h2><p>ActiveMQ从多种不同的方面提供了集群的支持。 </p>
<h3 id="Queue-consumer-clusters"><a href="#Queue-consumer-clusters" class="headerlink" title="Queue consumer clusters"></a>Queue consumer clusters</h3><p>ActiveMQ支持订阅同一个queue的consumers上的集群。如果一个consumer失效，那么所有未被确认 （unacknowledged）的消息都会被发送到这个queue上其它的consumers。如果某个consumer的处理速度比其它consumers更快，那么这个consumer就会消费更多的消息。<br>需要注意的是，笔者发现AcitveMQ5.0版本的Queue consumer clusters存在一个bug：采用AMQ Message Store，运行一个producer，两个consumer，并采用如下的配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;beans&gt; </div><div class="line">    &lt;broker xmlns=&quot;http://activemq.org/config/1.0&quot; brokerName=&quot;BugBroker1&quot; useJmx=&quot;true&quot;&gt; </div><div class="line"></div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">            &lt;transportConnector uri=&quot;tcp://localhost:61616&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line"></div><div class="line">        &lt;persistenceAdapter&gt; </div><div class="line">            &lt;amqPersistenceAdapter directory=&quot;activemq-data/BugBroker1&quot; maxFileLength=&quot;32mb&quot;/&gt; </div><div class="line">        &lt;/persistenceAdapter&gt; </div><div class="line">     </div><div class="line">    &lt;/broker&gt; </div><div class="line">&lt;/beans&gt;</div></pre></td></tr></table></figure></p>
<p>那么经过一段时间后可能会报出如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ERROR [ActiveMQ Transport: tcp:///127.0.0.1:1843 - RecoveryListenerAdapter.java:58 - RecoveryListenerAdapter] Message id ID:versus-1837-1203915536609-0:2:1:1:419 could not be recovered from the data store!</div></pre></td></tr></table></figure></p>
<p>Apache官方文档说，此bug已经被修正，预定在5.1.0版本上体现。 </p>
<h3 id="Broker-clusters"><a href="#Broker-clusters" class="headerlink" title="Broker clusters"></a>Broker clusters</h3><p>一个常见的场景是有多个JMS broker，一个客户连接到其中一个broker。如果这个broker失效，那么客户会自动重新连接到其它的broker。在ActiveMQ中使用<code>failover://</code> 协议来实现这个功能。ActiveMQ3.x版本的<code>reliable://</code>协议已经变更为<code>failover://</code>。<br>如果某个网络上有多个brokers而且客户使用静态发现（使用Static Transport或Failover Transport）或动态发现（使用Discovery Transport），那么客户可以容易地在某个broker失效的情况下切换到其它的brokers。然而，stand alone brokers并不了解其它brokers上的consumers，也就是说如果某个broker上没有consumers，那么这个broker上的消息可能会因得不到处理而积压起来。目前的解决方案是使用Network of brokers，以便在broker之间存储转发消息。ActiveMQ在未来会有更好的特性，用来在客户端处理这个问题。<br>从ActiveMQ1.1版本起，ActiveMQ支持networks of brokers。它支持分布式的queues和topics。一个broker会相同对待所有的订阅（subscription）：不管他们是来自本地的客户连接，还是来自远程broker，它都会递送有关的消息拷贝到每个订阅。远程broker得到这个消息拷贝后，会依次把它递送到其内部的本地连接上。有两种方式配置Network of brokers，一种是使用static transport：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;broker brokerName=&quot;receiver&quot; persistent=&quot;false&quot; useJmx=&quot;false&quot;&gt; </div><div class="line">        &lt;transportConnectors&gt; </div><div class="line">                &lt;transportConnector uri=&quot;tcp://localhost:62002&quot;/&gt; </div><div class="line">        &lt;/transportConnectors&gt; </div><div class="line">        </div><div class="line">        &lt;networkConnectors&gt; </div><div class="line">                &lt;networkConnector uri=&quot;static:( tcp://localhost:61616,tcp://remotehost:61616)&quot;/&gt; </div><div class="line">        &lt;/networkConnectors&gt; </div><div class="line">… </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>另外一种是使用multicast discovery，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;broker name=&quot;sender&quot; persistent=&quot;false&quot; useJmx=&quot;false&quot;&gt; </div><div class="line">    &lt;transportConnectors&gt; </div><div class="line">        &lt;transportConnector uri=&quot;tcp://localhost:0&quot; discoveryUri=&quot;multicast://default&quot;/&gt; </div><div class="line">    &lt;/transportConnectors&gt; </div><div class="line">    &lt;networkConnectors&gt; </div><div class="line">        &lt;networkConnector uri=&quot;multicast://default&quot;/&gt; </div><div class="line">    &lt;/networkConnectors&gt; </div><div class="line">... </div><div class="line">&lt;/broker&gt;</div></pre></td></tr></table></figure></p>
<p>Network Connector有以下属性： </p>
<table>
<thead>
<tr>
<th style="text-align:center">Property</th>
<th style="text-align:center">Default Value</th>
<th style="text-align:center">Description</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">name</td>
<td style="text-align:center">bridge</td>
<td style="text-align:center">name of the network - for more than one network connector between the same two brokers - use different names</td>
</tr>
<tr>
<td style="text-align:center">dynamicOnly</td>
<td style="text-align:center">false</td>
<td style="text-align:center">if true, only forward messages if a consumer is active on the connected broker</td>
</tr>
<tr>
<td style="text-align:center">decreaseNetworkConsumerPriority</td>
<td style="text-align:center">false</td>
<td style="text-align:center">decrease the priority for dispatching to a Queue consumer the further away it is (in network hops) from the producer</td>
</tr>
<tr>
<td style="text-align:center">networkTTL</td>
<td style="text-align:center">1</td>
<td style="text-align:center">the number of brokers in the network that messages and subscriptions can pass through</td>
</tr>
<tr>
<td style="text-align:center">conduitSubscriptions</td>
<td style="text-align:center">true</td>
<td style="text-align:center">multiple consumers subscribing to the same destination are treated as one consumer by the network</td>
</tr>
<tr>
<td style="text-align:center">excludedDestinations</td>
<td style="text-align:center">empty</td>
<td style="text-align:center">destinations matching this list won’t be forwarded across the network</td>
</tr>
<tr>
<td style="text-align:center">dynamicallyIncludedDestinations</td>
<td style="text-align:center">empty</td>
<td style="text-align:center">destinations that match this list will be forwarded across the network n.b. an empty list means all destinations not in the excluded list will be forwarded</td>
</tr>
<tr>
<td style="text-align:center">staticallyIncludedDestinations</td>
<td style="text-align:center">empty</td>
<td style="text-align:center">destinations that match will always be passed across the network - even if no consumers have ever registered an interest</td>
</tr>
<tr>
<td style="text-align:center">duplex</td>
<td style="text-align:center">false</td>
<td style="text-align:center">if true, a network connection will be used to both produce AND Consume messages. This is useful for hub and spoke scenarios when the hub is behind a firewall etc.</td>
</tr>
</tbody>
</table>
<p>关于conduitSubscriptions属性，这里稍稍说明一下。设想有两个brokers，分别是brokerA和brokerB，它们之间用 forwarding bridge连接。有一个consumer连接到brokerA并订阅queue：<code>Q.TEST</code>。有两个consumers连接到brokerB，也是订 阅queue：<code>Q.TEST</code>。这三个consumers有相同的优先级。然后启动一个producer。</p>
]]></content>
    
    <summary type="html">
    
      ActiveMQ理解
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActiveMQ/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>JMS概念</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMQ_%E5%88%9D%E6%AD%A5%E5%85%A5%E9%97%A8%E5%8F%8A%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMQ_初步入门及相关概念理解/</id>
    <published>2017-04-05T05:45:24.000Z</published>
    <updated>2017-04-05T20:24:34.087Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JMS的基本构件"><a href="#JMS的基本构件" class="headerlink" title="JMS的基本构件"></a>JMS的基本构件</h2><h3 id="连接工厂"><a href="#连接工厂" class="headerlink" title="连接工厂"></a>连接工厂</h3><p>连接工厂是客户用来创建连接的对象，例如ActiveMQ提供的<code>ActiveMQConnectionFactory</code>。 </p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>JMS <code>Connection</code>封装了客户与JMS提供者之间的一个虚拟的连接。 </p>
<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>JMS <code>Session</code>是生产和消费消息的一个单线程上下文。会话用于创建消息生产者（producer）、消息消费者（consumer）和消息（message）等。会话提供了一个事务性的上下文，在这个上下文中，一组发送和接收被组合到了一个原子操作中。 </p>
<h3 id="目的地"><a href="#目的地" class="headerlink" title="目的地"></a>目的地</h3><p>目的地是客户用来指定它生产的消息的目标和它消费的消息的来源的对象。JMS1.0.2规范中定义了两种消息传递域：点对点（PTP）消息传递域和发布/订阅消息传递域。 </p>
<h4 id="点对点消息传递域的特点如下："><a href="#点对点消息传递域的特点如下：" class="headerlink" title="点对点消息传递域的特点如下："></a>点对点消息传递域的特点如下：</h4><p>• 每个消息只能有一个消费者。<br>• 消息的生产者和消费者之间没有时间上的相关性。无论消费者在生产者发送消息的时候是否处于运行状态，它都可以提取消息。(前提是没有其他消费者消费了该消息)<br>• 在点对点消息传递域中，目的地被称为队列（queue）</p>
<h4 id="发布-订阅消息传递域的特点如下："><a href="#发布-订阅消息传递域的特点如下：" class="headerlink" title="发布/订阅消息传递域的特点如下："></a>发布/订阅消息传递域的特点如下：</h4><p>• 每个消息可以有多个消费者。<br>• 生产者和消费者之间有时间上的相关性。订阅一个主题的消费者只能消费自它订阅之后发布的消息。JMS规范允许客户创建持久订阅，这在一定程度上放松了时间上的相关性要求。持久订阅允许消费者消费它在未处于激活状态时发送的消息。<br>• 在发布/订阅消息传递域中，目的地被称为主题（topic）。 </p>
<h3 id="消息生产者"><a href="#消息生产者" class="headerlink" title="消息生产者"></a>消息生产者</h3><p>消息生产者是由会话创建的一个对象，用于把消息发送到一个目的地。 </p>
<h3 id="消息消费者"><a href="#消息消费者" class="headerlink" title="消息消费者"></a>消息消费者</h3><p>消息消费者是由会话创建的一个对象，它用于接收发送到目的地的消息。消息的消费可以采用以下两种方法之一： </p>
<p>• 同步消费。通过调用消费者的<code>receive</code>方法从目的地中显式提取消息。<code>receive</code>方法可以一直阻塞到消息到达。<br>• 异步消费。客户可以为消费者注册一个消息监听器，以定义在消息到达时所采取的动作。 </p>
<h3 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h3><p>JMS消息由以下三部分组成：<br>• 消息头。每个消息头字段都有相应的getter和setter方法。<br>• 消息属性。如果需要除消息头字段以外的值，那么可以使用消息属性。<br>• 消息体。JMS定义的消息类型有<code>TextMessage</code>、<code>MapMessage</code>、<code>BytesMessage</code>、<code>StreamMessage</code>和<code>ObjectMessage</code>。 </p>
<h2 id="JMS的可靠性机制"><a href="#JMS的可靠性机制" class="headerlink" title="JMS的可靠性机制"></a>JMS的可靠性机制</h2><h3 id="确认"><a href="#确认" class="headerlink" title="确认"></a>确认</h3><p>JMS消息只有在被确认之后，才认为已经被成功地消费了。消息的成功消费通常包含三个阶段：客户接收消息、客户处理消息和消息被确认。<br>在事务性会话中，当一个事务被提交的时候，确认自动发生。在非事务性会话中，消息何时被确认取决于创建会话时的应答模式（acknowledgement mode）。该参数有以下三个可选值：<br>• <code>Session.AUTO_ACKNOWLEDGE</code>。当客户成功地从<code>receive</code>方法返回的时候，或者从<code>MessageListener.onMessage</code>方法成功返回的时候，会话自动确认客户收到的消息。<br>• <code>Session.CLIENT_ACKNOWLEDGE</code>。 客户通过消息的<code>acknowledge</code>方法确认消息。需要注意的是，在这种模式中，确认是在会话层上进行：确认一个被消费的消息将自动确认所有已被会话消费的消息。例如，如果一个消息消费者消费了10个消息，然后确认第5个消息，那么所有10个消息都被确认。<br>• <code>Session.DUPS_OK_ACKNOWLEDGE</code>。 </p>
<p>The duplicates okay acknowledgement mode closely resembles the auto acknowledgement mode. However, rather than pass <code>Session.AUTO_ACKNOWLEDGE</code>, you specify <code>Session.DUPS_OK_ACKNOWLEDGE</code> as the acknowledgement mode of <code>createSession()</code>‘s second argument. With less overhead than auto mode, in duplicates okay mode, the JMS provider guarantees at-least-once message delivery. During failure recovery, certain messages are probably delivered more than once.如果JMS provider失败，那么可能会导致一些重复的消息。如果是重复的消息，那么JMS provider必须把消息头的<code>JMSRedelivered</code>字段设置为true。 </p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>JMS 支持以下两种消息提交模式：<br>• <code>PERSISTENT</code>。指示JMS provider持久保存消息，以保证消息不会因为JMS provider的失败而丢失。<br>• <code>NON_PERSISTENT</code>。不要求JMS provider持久保存消息。 </p>
<h3 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h3><p>可以使用消息优先级来指示JMS provider首先提交紧急的消息。优先级分10个级别，从0（最低）到9（最高）。如果不指定优先级，默认级别是4。需要注意的是，JMS provider并不一定保证按照优先级的顺序提交消息。 </p>
<h3 id="消息过期"><a href="#消息过期" class="headerlink" title="消息过期"></a>消息过期</h3><p>可以设置消息在一定时间后过期，默认是永不过期。 </p>
<h3 id="临时目的地"><a href="#临时目的地" class="headerlink" title="临时目的地"></a>临时目的地</h3><p>可以通过会话上的<code>createTemporaryQueue</code>方法和<code>createTemporaryTopic</code>方法来创建临时目的地。它们的存在时间只限于创建它们的连接所保持的时间。只有创建该临时目的地的连接上的消息消费者才能够从临时目的地中提取消息。 </p>
<h3 id="持久订阅"><a href="#持久订阅" class="headerlink" title="持久订阅"></a>持久订阅</h3><p>首先消息生产者必须使用<code>PERSISTENT</code>提交消息。客户可以通过会话上的<code>createDurableSubscriber</code>方法来创建一个持久订阅，该方法的第一个参数必须是一个<code>topic</code>。第二个参数是订阅的名称。<br>JMS provider会存储发布到持久订阅对应的topic上的消息。如果最初创建持久订阅的客户或者任何其它客户使用相同的连接工厂和连接的客户ID、相同的主题和相同的订阅名再次调用会话上的<code>createDurableSubscriber</code>方法，那么该持久订阅就会被激活。JMS provider会向客户发送客户处于非激活状态时所发布的消息。<br><strong>持久订阅在某个时刻只能有一个激活的订阅者。</strong>持久订阅在创建之后会一直保留，直到应用程序调用会话上的<code>unsubscribe</code>方法。 </p>
<h3 id="本地事务"><a href="#本地事务" class="headerlink" title="本地事务"></a>本地事务</h3><p>在一个JMS客户端，可以使用本地事务来组合消息的发送和接收。JMS Session接口提供了<code>commit</code>和<code>rollback</code>方法。<br>事务提交意味着生产的所有消息被发送，消费的所有消息被确认；事务回滚意味着生产的所有消息被销毁，消费的所有消息被恢复并重新提交，除非它们已经过期。 </p>
<blockquote>
<p>需要注意的是，如果使用请求/回复机制，即发送一个消息，同时希望在同一个事务中等待接收该消息的回复，那么程序将被挂起，因为直到事务提交，发送操作才会真正执行。<br>所以，消息的生产和消费不能包含在同一个事务中。 </p>
</blockquote>
<h2 id="JMS-规范的变迁"><a href="#JMS-规范的变迁" class="headerlink" title="JMS 规范的变迁"></a>JMS 规范的变迁</h2><p>JMS最新版本是1.1。它和1.0.2版本最大的差别是，JMS1.1通过统一消息传递域简化了消息传递。这不仅简化了JMS API，也有利于开发人员灵活选择消息传递域，同时也有助于程序的重用和维护。<br>以下是不同消息传递域的相应接口： </p>
<table>
<thead>
<tr>
<th style="text-align:center">JMS公共</th>
<th style="text-align:center">点对点域</th>
<th style="text-align:center">发布/订阅域</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>ConnectionFactory</code></td>
<td style="text-align:center"><code>QueueConnectionFactory</code></td>
<td style="text-align:center"><code>TopicConnectionFactory</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Connection</code></td>
<td style="text-align:center"><code>QueueConnection</code></td>
<td style="text-align:center"><code>TopicConnection</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Destination</code></td>
<td style="text-align:center"><code>Queue</code></td>
<td style="text-align:center"><code>Topic</code></td>
</tr>
<tr>
<td style="text-align:center"><code>Session</code></td>
<td style="text-align:center"><code>QueueSession</code></td>
<td style="text-align:center"><code>TopicSession</code></td>
</tr>
<tr>
<td style="text-align:center"><code>MessageProducer</code></td>
<td style="text-align:center"><code>QueueSender</code></td>
<td style="text-align:center"><code>TopicPublisher</code></td>
</tr>
<tr>
<td style="text-align:center"><code>MessageConsumer</code></td>
<td style="text-align:center"><code>QueueReceiver</code></td>
<td style="text-align:center"><code>TopicSubscriber</code></td>
</tr>
</tbody>
</table>
]]></content>
    
    <summary type="html">
    
      JMS概念
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMq性能优化</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMq%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMq性能优化/</id>
    <published>2017-04-05T05:30:41.000Z</published>
    <updated>2017-04-05T05:38:01.424Z</updated>
    
    <content type="html"><![CDATA[<p>ActiveMq是比较稳定的，吞吐速度也很快，如果出现入队列或者出队列慢问题，先检查一下自己的代码，是不是本身取到数据后处理过慢。</p>
<h2 id="1-使用spring的JmsTemplate"><a href="#1-使用spring的JmsTemplate" class="headerlink" title="1. 使用spring的JmsTemplate"></a>1. 使用spring的<code>JmsTemplate</code></h2><p><code>JmsTemplate</code>的<code>send</code>和<code>convertAndSend</code>会使用持久化<code>mode</code>，即使你设置了<code>NON_PERSISTENT</code>。这会导致入队列速度变得非常慢。</p>
<p>解决办法，使用下面的<code>MyJmsTemplate</code>代替<code>JmsTemplate</code>。</p>
<pre><code>public class MyJmsTemplate extends JmsTemplate {
    private Session session;

    public MyJmsTemplate() {
        super();
    }

    public MyJmsTemplate(ConnectionFactory connectionFactory) {
        super(connectionFactory);
    }

    public void doSend(MessageProducer producer, Message message) throws JMSException {
        if (isExplicitQosEnabled()) {
            producer.send(message, getDeliveryMode(), getPriority(), getTimeToLive());
        } else {
            producer.send(message);
        }
    }

    public Session getSession() {
        return session;
    }

    public void setSession(Session session) {
        this.session = session;
    }
}
</code></pre><h2 id="2-DeliveryMode的选择，如果你入队列的数据，不考虑MQ挂掉的情况（这概率很小），使用NON-PERSISTENT会显著提高数据写入速度。"><a href="#2-DeliveryMode的选择，如果你入队列的数据，不考虑MQ挂掉的情况（这概率很小），使用NON-PERSISTENT会显著提高数据写入速度。" class="headerlink" title="2. DeliveryMode的选择，如果你入队列的数据，不考虑MQ挂掉的情况（这概率很小），使用NON_PERSISTENT会显著提高数据写入速度。"></a>2. <code>DeliveryMode</code>的选择，如果你入队列的数据，不考虑MQ挂掉的情况（这概率很小），使用<code>NON_PERSISTENT</code>会显著提高数据写入速度。</h2><h2 id="3-生产者使用事务会提高入队列性能，但是消费者如果启动了事务则会显著影响数据的消费速度。"><a href="#3-生产者使用事务会提高入队列性能，但是消费者如果启动了事务则会显著影响数据的消费速度。" class="headerlink" title="3. 生产者使用事务会提高入队列性能，但是消费者如果启动了事务则会显著影响数据的消费速度。"></a>3. 生产者使用事务会提高入队列性能，但是消费者如果启动了事务则会显著影响数据的消费速度。</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);</div></pre></td></tr></table></figure>
<p>代码中的<code>false</code>代表不启动事物。</p>
<h2 id="4-消费者的消息处理即onMessage方法优化"><a href="#4-消费者的消息处理即onMessage方法优化" class="headerlink" title="4. 消费者的消息处理即onMessage方法优化:"></a>4. 消费者的消息处理即<code>onMessage方</code>法优化:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">public class SmsMoPool implements MessageListener &#123;</div><div class="line">    private final static Logger logger = LoggerFactory.getLogger(SmsMoPool.class);</div><div class="line">    private DefaultEventPubliser moEventPublisher;</div><div class="line">    private final EventFactory eventFactory = new DefaultEventFactory();</div><div class="line">    private DefaultDataGather dataGather;</div><div class="line">    private ExecutorService pool = Executors.newFixedThreadPool(5);</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public void onMessage(final Message message) &#123;</div><div class="line">        pool.execute(new Runnable() &#123;</div><div class="line">            @Override</div><div class="line">            public void run() &#123;</div><div class="line">                final ObjectMessage msg = (ObjectMessage) message;</div><div class="line">                Serializable obj = null;</div><div class="line">                try &#123;</div><div class="line">                    obj = msg.getObject();</div><div class="line">                &#125; catch (JMSException e) &#123;</div><div class="line">                    logger.error(&quot;从消息队列获得上行信息异常&#123;&#125;&quot;, e);</div><div class="line">                &#125;</div><div class="line">                if (obj != null) &#123;</div><div class="line">                    dataGather.incrementDateCount(MasEntityConstants.TRAFFIC_SMS_MO_IN);</div><div class="line">                    AgentToServerReq req = (AgentToServerReq) obj;</div><div class="line">                    if (logger.isInfoEnabled()) &#123;</div><div class="line">                        logger.info(&quot;驱动--&gt;调度：&#123;&#125;&quot;, req.toXmlStr());</div><div class="line">                    &#125;</div><div class="line">                    Event event = eventFactory.createMoEvent(req);</div><div class="line">                    moEventPublisher.publishEvent(event);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码使用了线程池，另一点要注意的是<code>msg.getObject();</code>这个方法是一个比较耗时的方法，你的代码中不应该出现多次<code>getObject()</code>。</p>
<h2 id="5-消费者使用预取，如何使用预取，下面以spring版本为例"><a href="#5-消费者使用预取，如何使用预取，下面以spring版本为例" class="headerlink" title="5. 消费者使用预取，如何使用预取，下面以spring版本为例"></a>5. 消费者使用预取，如何使用预取，下面以spring版本为例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;bean class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&gt;</div><div class="line">    &lt;constructor-arg value=&quot;data.mo?consumer.prefetchSize=100&quot;/&gt;</div><div class="line">&lt;/bean&gt;</div></pre></td></tr></table></figure>
<p>预取数量根据具体入队列数据而定，以上设置100，是针对2000/sec入队列速度设定的。<br>另外如果是慢消费者，这里可设置为1。</p>
<h2 id="6-检查你的MQ数据吞吐速度，保持生产和消费的平衡，不会出现大量积压。"><a href="#6-检查你的MQ数据吞吐速度，保持生产和消费的平衡，不会出现大量积压。" class="headerlink" title="6. 检查你的MQ数据吞吐速度，保持生产和消费的平衡，不会出现大量积压。"></a>6. 检查你的MQ数据吞吐速度，保持生产和消费的平衡，不会出现大量积压。</h2><h2 id="7-ActiveMQ使用TCP协议时tcpNoDelay-默认是false-，设置为true可以提高性能。"><a href="#7-ActiveMQ使用TCP协议时tcpNoDelay-默认是false-，设置为true可以提高性能。" class="headerlink" title="7. ActiveMQ使用TCP协议时tcpNoDelay=默认是false ，设置为true可以提高性能。"></a>7. ActiveMQ使用TCP协议时<code>tcpNoDelay=</code>默认是<code>false</code> ，设置为<code>true</code>可以提高性能。</h2><p>还是spring版本的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;bean id=&quot;mqPoolConnectionFactory&quot; class=&quot;org.apache.activemq.pool.PooledConnectionFactory&quot; destroy-method=&quot;stop&quot;&gt;</div><div class="line">       &lt;property name=&quot;connectionFactory&quot;&gt;</div><div class="line">           &lt;bean id=&quot;mqConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot; p:useAsyncSend=&quot;true&quot;</div><div class="line">                 p:brokerURL=&quot;failover://(tcp://127.0.0.1:61616?tcpNoDelay=true)&quot;/&gt;</div><div class="line">       &lt;/property&gt;</div><div class="line">   &lt;/bean&gt;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      ActiveMq性能优化
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActivefMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActivefMQ/"/>
    
    
      <category term="java" scheme="http://jishusuishouji.github.io/tags/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出JMS(一)--JMS基本概念</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJMS_%E4%B8%80_--JMS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/深入浅出JMS_一_--JMS基本概念/</id>
    <published>2017-04-05T05:15:49.000Z</published>
    <updated>2017-04-05T05:28:39.827Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>The Java Message Service (JMS) API is a messaging standard that allows application components based on the Java Platform Enterprise Edition (Java EE) to create, send, receive, and read messages. It enables distributed communication that is loosely coupled, reliable, and asynchronous.</p>
</blockquote>
<p>JMS（JAVA Message Service,java消息服务）API是一个消息服务的标准(规范)，允许基于JavaEE平台的应用程序组件创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠并采用异步方式。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>JMS是java的消息服务，JMS的客户端之间通过JMS服务进行异步消息传输。</p>
<h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><ul>
<li>Point-to-Point(P2P)</li>
<li>Publish/Subscribe(Pub/Sub)</li>
</ul>
<p>即点对点和发布订阅模型</p>
<h4 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h4><p><img src="/img/JMS P2P模式" alt="JMS P2P模式"></p>
<ul>
<li>消息队列（Queue）</li>
<li>发送者(Sender)</li>
<li>接收者(Receiver)</li>
</ul>
<p>每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到它们被消费或超时。</p>
<h5 id="P2P的特点"><a href="#P2P的特点" class="headerlink" title="P2P的特点"></a>P2P的特点</h5><p>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)<br>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列；接收者在成功接收消息之后需向队列应答成功；如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式。</p>
<h4 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h4><p><img src="/img/Pub Sub模式图" alt="Pub/Sub模式图"> </p>
<ul>
<li>主题（Topic）</li>
<li>发布者（Publisher）</li>
<li>订阅者（Subscriber） </li>
</ul>
<p>多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者。</p>
<h5 id="Pub-Sub的特点"><a href="#Pub-Sub的特点" class="headerlink" title="Pub/Sub的特点"></a>Pub/Sub的特点</h5><ul>
<li>每个消息可以有多个消费者</li>
<li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。</li>
<li>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</li>
<li>如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型</li>
</ul>
<h2 id="消息的消费"><a href="#消息的消费" class="headerlink" title="消息的消费"></a>消息的消费</h2><p>在JMS中，消息的产生和消息是异步的。</p>
<ul>
<li>同步<br>订阅者或接收者调用<code>receive</code>方法来接收消息，<code>receive</code>方法在能够接收到消息之前（或超时之前）将一直阻塞 </li>
<li>异步<br>订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的<code>onMessage</code>方法。</li>
</ul>
<h2 id="JMS编程模型"><a href="#JMS编程模型" class="headerlink" title="JMS编程模型"></a>JMS编程模型</h2><p>(1) <code>ConnectionFactory</code></p>
<p>创建<code>Connection</code>对象的工厂，针对两种不同的jms消息模型，分别有<code>QueueConnectionFactory</code>和<code>TopicConnectionFactory</code>两种。可以通过JNDI来查找<code>ConnectionFactory</code>对象。</p>
<p>(2) <code>Destination</code></p>
<p><code>Destination</code>的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者或消费者来说，它的<code>Destination</code>是某个队列（Queue）或某个主题（Topic）。</p>
<p><code>Destination</code>实际上就是两种类型的对象：<code>Queue</code>、<code>Topic</code>。<br>(3) <code>Connection</code></p>
<p><code>Connection</code>表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。<code>Connection</code>可以产生一个或多个<code>Session</code>。跟<code>ConnectionFactory</code>一样，<code>Connection</code>也有两种类型：<code>QueueConnection</code>和<code>TopicConnection</code>。</p>
<p>(4) <code>Session</code></p>
<p><code>Session</code>是操作消息的接口。可以通过session创建生产者、消费者、消息等。<code>Session</code>提供了事务的功能。当需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分<code>QueueSession</code>和<code>TopicSession</code>。</p>
<p>(5) 消息的生产者</p>
<p>消息生产者由<code>Session</code>创建，并用于将消息发送到<code>Destination</code>。同样，消息生产者分两种类型：<code>QueueSender</code>和<code>TopicPublisher</code>。可以调用消息生产者的方法（<code>send</code>或<code>publish</code>方法）发送消息。</p>
<p>(6) 消息消费者</p>
<p>消息消费者由<code>Session</code>创建，用于接收被发送到<code>Destination</code>的消息。两种类型：<code>QueueReceiver</code>和<code>TopicSubscriber</code>。可分别通过<code>session</code>的<code>createReceiver(Queue)</code>或<code>createSubscriber(Topic)</code>来创建。当然，也可以<code>session</code>的<code>creatDurableSubscriber</code>方法来创建持久化的订阅者。</p>
<p>(7) <code>MessageListener</code></p>
<p>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的<code>onMessage</code>方法。EJB中的MDB（Message-Driven Bean）就是一种<code>MessageListener</code>。</p>
<h2 id="企业消息系统的好处"><a href="#企业消息系统的好处" class="headerlink" title="企业消息系统的好处"></a>企业消息系统的好处</h2><p>应用程序A将Message发送到服务器上，然后应用程序B从服务器中接收A发来的消息： </p>
<p><img src="/img/企业消息系统的好处" alt="企业消息系统的好处"></p>
<ul>
<li>提供消息灵活性</li>
<li>松散耦合</li>
<li>异步性</li>
</ul>
]]></content>
    
    <summary type="html">
    
      深入浅出JMS(一)--JMS基本概念
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/tags/JMS/"/>
    
  </entry>
  
  <entry>
    <title>ActiveMQ入门实例</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMQ%E5%85%A5%E9%97%A8%E5%AE%9E%E4%BE%8B/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/ActiveMQ入门实例/</id>
    <published>2017-04-05T05:08:11.000Z</published>
    <updated>2017-04-05T05:14:59.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-下载ActiveMQ"><a href="#1-下载ActiveMQ" class="headerlink" title="1.下载ActiveMQ"></a>1.下载ActiveMQ</h2><p>去官方网站下载：<a href="http://activemq.apache.org/" target="_blank" rel="external">http://activemq.apache.org/</a></p>
<h2 id="2-运行ActiveMQ"><a href="#2-运行ActiveMQ" class="headerlink" title="2.运行ActiveMQ"></a>2.运行ActiveMQ</h2><p>解压缩<code>apache-activemq-5.5.1-bin.zip</code>，然后双击<code>apache-activemq-5.5.1\bin\activemq.bat</code>运行ActiveMQ程序。</p>
<p>启动ActiveMQ以后，登陆：<code>http://localhost:8161/admin/</code>，创建一个<code>Queue</code>，命名为<code>FirstQueue</code>。</p>
<h2 id="3-创建Eclipse项目并运行"><a href="#3-创建Eclipse项目并运行" class="headerlink" title="3.创建Eclipse项目并运行"></a>3.创建Eclipse项目并运行</h2><p>创建project：<code>ActiveMQ-5.5</code>，并导入<code>apache-activemq-5.5.1\lib</code>目录下需要用到的jar文件，项目结构如下图所示：</p>
<p><img src="/img/ActiveMQ的Eclipse项目.jpg" alt="ActiveMQ的Eclipse项目"></p>
<h3 id="3-1-Sender-java"><a href="#3-1-Sender-java" class="headerlink" title="3.1.Sender.java"></a>3.1.<code>Sender.java</code></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.activemq;</div><div class="line"></div><div class="line">import javax.jms.Connection;</div><div class="line">import javax.jms.ConnectionFactory;</div><div class="line">import javax.jms.DeliveryMode;</div><div class="line">import javax.jms.Destination;</div><div class="line">import javax.jms.MessageProducer;</div><div class="line">import javax.jms.Session;</div><div class="line">import javax.jms.TextMessage;</div><div class="line">import org.apache.activemq.ActiveMQConnection;</div><div class="line">import org.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"></div><div class="line">public class Sender &#123;</div><div class="line">    private static final int SEND_NUMBER = 5;</div><div class="line"></div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // ConnectionFactory ：连接工厂，JMS 用它创建连接</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        // Connection ：JMS 客户端到JMS Provider 的连接</div><div class="line">        Connection connection = null;</div><div class="line">        // Session： 一个发送或接收消息的线程</div><div class="line">        Session session;</div><div class="line">        // Destination ：消息的目的地;消息发送给谁.</div><div class="line">        Destination destination;</div><div class="line">        // MessageProducer：消息发送者</div><div class="line">        MessageProducer producer;</div><div class="line">        // TextMessage message;</div><div class="line">        // 构造ConnectionFactory实例对象，此处采用ActiveMq的实现jar</div><div class="line">        connectionFactory = new ActiveMQConnectionFactory(</div><div class="line">                ActiveMQConnection.DEFAULT_USER,</div><div class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</div><div class="line">                &quot;tcp://localhost:61616&quot;);</div><div class="line">        try &#123;</div><div class="line">            // 构造从工厂得到连接对象</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            // 启动</div><div class="line">            connection.start();</div><div class="line">            // 获取操作连接</div><div class="line">            session = connection.createSession(Boolean.TRUE,</div><div class="line">                    Session.AUTO_ACKNOWLEDGE);</div><div class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</div><div class="line">            // 得到消息生成者【发送者】</div><div class="line">            producer = session.createProducer(destination);</div><div class="line">            // 设置不持久化，此处学习，实际根据项目决定</div><div class="line">            producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);</div><div class="line">            // 构造消息，此处写死</div><div class="line">            sendMessage(session, producer);</div><div class="line">            session.commit();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (null != connection)</div><div class="line">                    connection.close();</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void sendMessage(Session session, MessageProducer producer)</div><div class="line">            throws Exception &#123;</div><div class="line">        for (int i = 1; i &lt;= SEND_NUMBER; i++) &#123;</div><div class="line">            TextMessage message = session</div><div class="line">                    .createTextMessage(&quot;ActiveMq 发送的消息&quot; + i);</div><div class="line">            // 发送消息到目的地方</div><div class="line">            System.out.println(&quot;发送消息：&quot; + &quot;ActiveMq 发送的消息&quot; + i);</div><div class="line">            producer.send(message);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-Receiver-java"><a href="#3-2-Receiver-java" class="headerlink" title="3.2.Receiver.java"></a>3.2.Receiver.java</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">package com.xuwei.activemq;</div><div class="line"></div><div class="line">import javax.jms.Connection;</div><div class="line">import javax.jms.ConnectionFactory;</div><div class="line">import javax.jms.Destination;</div><div class="line">import javax.jms.MessageConsumer;</div><div class="line">import javax.jms.Session;</div><div class="line">import javax.jms.TextMessage;</div><div class="line">import org.apache.activemq.ActiveMQConnection;</div><div class="line">import org.apache.activemq.ActiveMQConnectionFactory;</div><div class="line"></div><div class="line">public class Receiver &#123;</div><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        // ConnectionFactory ：连接工厂，JMS 用它创建连接</div><div class="line">        ConnectionFactory connectionFactory;</div><div class="line">        // Connection ：JMS 客户端到JMS Provider 的连接</div><div class="line">        Connection connection = null;</div><div class="line">        // Session： 一个发送或接收消息的线程</div><div class="line">        Session session;</div><div class="line">        // Destination ：消息的目的地;消息发送给谁.</div><div class="line">        Destination destination;</div><div class="line">        // 消费者，消息接收者</div><div class="line">        MessageConsumer consumer;</div><div class="line">        connectionFactory = new ActiveMQConnectionFactory(</div><div class="line">                ActiveMQConnection.DEFAULT_USER,</div><div class="line">                ActiveMQConnection.DEFAULT_PASSWORD,</div><div class="line">                &quot;tcp://localhost:61616&quot;);</div><div class="line">        try &#123;</div><div class="line">            // 构造从工厂得到连接对象</div><div class="line">            connection = connectionFactory.createConnection();</div><div class="line">            // 启动</div><div class="line">            connection.start();</div><div class="line">            // 获取操作连接</div><div class="line">            session = connection.createSession(Boolean.FALSE,</div><div class="line">                    Session.AUTO_ACKNOWLEDGE);</div><div class="line">   </div><div class="line">            destination = session.createQueue(&quot;FirstQueue&quot;);</div><div class="line">            consumer = session.createConsumer(destination);</div><div class="line">            while (true) &#123;</div><div class="line">                //设置接收者接收消息的时间，为了便于测试，这里谁定为100s</div><div class="line">                TextMessage message = (TextMessage) consumer.receive(100000);</div><div class="line">                if (null != message) &#123;</div><div class="line">                    System.out.println(&quot;收到消息&quot; + message.getText());</div><div class="line">                &#125; else &#123;</div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; finally &#123;</div><div class="line">            try &#123;</div><div class="line">                if (null != connection)</div><div class="line">                    connection.close();</div><div class="line">            &#125; catch (Throwable ignore) &#123;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4.注意事项"></a>4.注意事项</h2><p>最后接收者跟发送者在不同的机器上测试</p>
<h2 id="5-测试过程"><a href="#5-测试过程" class="headerlink" title="5.测试过程"></a>5.测试过程</h2><p>运行<code>Receiver</code>后没有任何信息，运行Sender以后，显示如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">发送消息：ActiveMq 发送的消息1</div><div class="line">发送消息：ActiveMq 发送的消息2</div><div class="line">发送消息：ActiveMq 发送的消息3</div><div class="line">发送消息：ActiveMq 发送的消息4</div><div class="line">发送消息：ActiveMq 发送的消息5</div></pre></td></tr></table></figure></p>
<p>而<code>Receiver</code>现如下信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">收到消息ActiveMq 发送的消息1</div><div class="line">收到消息ActiveMq 发送的消息2</div><div class="line">收到消息ActiveMq 发送的消息3</div><div class="line">收到消息ActiveMq 发送的消息4</div><div class="line">收到消息ActiveMq 发送的消息5</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      ActiveMQ入门实例
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS" scheme="http://jishusuishouji.github.io/categories/java/JMS/"/>
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS/ActiveMQ/"/>
    
    
      <category term="ActiveMQ" scheme="http://jishusuishouji.github.io/tags/ActiveMQ/"/>
    
  </entry>
  
  <entry>
    <title>activemq的几种基本通信方式总结</title>
    <link href="http://jishusuishouji.github.io/2017/04/05/activemq/activemq%E7%9A%84%E5%87%A0%E7%A7%8D%E5%9F%BA%E6%9C%AC%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://jishusuishouji.github.io/2017/04/05/activemq/activemq的几种基本通信方式总结/</id>
    <published>2017-04-05T03:09:12.000Z</published>
    <updated>2017-04-05T05:07:35.171Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>面向消息队列是一个总体比较合理的应用系统集成方案。<br>ActiveMQ是JMS消息通信规范的一个实现。消息通信模式主要有发布-订阅、点对点。</p>
<h2 id="基础流程"><a href="#基础流程" class="headerlink" title="基础流程"></a>基础流程</h2><p>ActiveMQ启动服务的过程:</p>
<ol>
<li>获得JMS connection factory，通过提供特定环境的连接信息来构造factory。</li>
<li>利用factory构造JMS connection.</li>
<li>启动connection</li>
<li>通过connection创建JMS session.</li>
<li>指定JMS destination.</li>
<li>创建JMS producer和JMS message并提供destination.</li>
<li>创建JMS consumer和注册JMS message listener.</li>
<li>发送和接收JMS message.</li>
<li>关闭所有JMS资源，包括connection, session, producer, consumer等。</li>
</ol>
<h2 id="publish-subscribe"><a href="#publish-subscribe" class="headerlink" title="publish-subscribe"></a>publish-subscribe</h2><p>发布订阅模式类似于订阅报纸。</p>
<p><img src="/img/JMS发布订阅模式示意图.jpg" alt="JMS发布订阅模式示意图"></p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="publisher"><a href="#publisher" class="headerlink" title="publisher"></a>publisher</h4><p>publisher是属于发布信息的一方，它通过定义一个或者多个topic，然后给这些topic发送消息。<br>publisher的构造函数如下：</p>
<pre><code>public Publisher() throws JMSException {  
    factory = new ActiveMQConnectionFactory(brokerURL);  
    connection = factory.createConnection();  
    try {  
        connection.start();  
    } catch (JMSException jmse) {  
        connection.close();  
        throw jmse;  
    }  
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
    producer = session.createProducer(null);  
}
</code></pre><p>按照前面说的流程定义了基本的<code>connectionFactory</code>, <code>connection</code>,<code>session</code>,<code>producer</code>。。</p>
<h4 id="接着定义一系列的topic让所有的consumer来订阅"><a href="#接着定义一系列的topic让所有的consumer来订阅" class="headerlink" title="接着定义一系列的topic让所有的consumer来订阅"></a>接着定义一系列的topic让所有的consumer来订阅</h4><pre><code>protected void setTopics(String[] stocks) throws JMSException {  
    destinations = new Destination[stocks.length];  
    for(int i = 0; i &lt; stocks.length; i++) {  
        destinations[i] = session.createTopic(&quot;STOCKS.&quot; + stocks[i]);  
    }  
}  
</code></pre><h4 id="定义好topic之后要给这些指定的topic发消息："><a href="#定义好topic之后要给这些指定的topic发消息：" class="headerlink" title="定义好topic之后要给这些指定的topic发消息："></a>定义好topic之后要给这些指定的topic发消息：</h4><pre><code>protected void sendMessage(String[] stocks) throws JMSException {  
    for(int i = 0; i &lt; stocks.length; i++) {  
        Message message = createStockMessage(stocks[i], session);  
        System.out.println(&quot;Sending: &quot; + ((ActiveMQMapMessage)message).getContentMap() + &quot; on destination: &quot; + destinations[i]);  
        producer.send(destinations[i], message);  
    }  
}  

protected Message createStockMessage(String stock, Session session) throws JMSException {  
    MapMessage message = session.createMapMessage();  
    message.setString(&quot;stock&quot;, stock);  
    message.setDouble(&quot;price&quot;, 1.00);  
    message.setDouble(&quot;offer&quot;, 0.01);  
    message.setBoolean(&quot;up&quot;, true);          
    return message;  
}  
</code></pre><p>在<code>sendMessage</code>方法里遍历每个<code>topic</code>，然后给每个<code>topic</code>发送定义的<code>Message</code>消息。</p>
<h4 id="publisher发布消息"><a href="#publisher发布消息" class="headerlink" title="publisher发布消息"></a>publisher发布消息</h4><pre><code>public static void main(String[] args) throws JMSException {  
    if(args.length &lt; 1)  
        throw new IllegalArgumentException();  

    // Create publisher       
    Publisher publisher = new Publisher();  

    // Set topics  
    publisher.setTopics(args);  

    for(int i = 0; i &lt; 10; i++) {  
        publisher.sendMessage(args);  
        System.out.println(&quot;Publisher &apos;&quot; + i + &quot; price messages&quot;);  
        try {  
            Thread.sleep(1000);  
        } catch(InterruptedException e) {  
            e.printStackTrace();  
        }  
    }  
    // Close all resources  
    publisher.close();  
}  
</code></pre><h4 id="close方法关闭资源："><a href="#close方法关闭资源：" class="headerlink" title="close方法关闭资源："></a><code>close</code>方法关闭资源：</h4><pre><code>public void close() throws JMSException {  
    if (connection != null) {  
        connection.close();  
    }  
}  
</code></pre><h3 id="consumer"><a href="#consumer" class="headerlink" title="consumer"></a>consumer</h3><p>具体的步骤:<br>1.初始化资源。 </p>
<ol>
<li>接收消息。 </li>
<li>必要的时候关闭资源。</li>
</ol>
<h4 id="初始化资源放到构造函数里面："><a href="#初始化资源放到构造函数里面：" class="headerlink" title="初始化资源放到构造函数里面："></a>初始化资源放到构造函数里面：</h4><pre><code>public Consumer() throws JMSException {  
    factory = new ActiveMQConnectionFactory(brokerURL);  
    connection = factory.createConnection();  
    connection.start();  
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
}  
</code></pre><h4 id="接收和处理消息的方法"><a href="#接收和处理消息的方法" class="headerlink" title="接收和处理消息的方法"></a>接收和处理消息的方法</h4><p>分为同步和异步的：</p>
<ul>
<li>同步  <code>MessageConsumer.receive()</code>方法</li>
<li><p>异步  注册<code>MessageListener</code>，使用<code>MessageConsumer.setMessageListener()</code>。</p>
<p>  public static void main(String[] args) throws JMSException {  </p>
<pre><code>Consumer consumer = new Consumer();  
for (String stock : args) {  
    Destination destination = consumer.getSession().createTopic(&quot;STOCKS.&quot; + stock);  
    MessageConsumer messageConsumer = consumer.getSession().createConsumer(destination);  
    messageConsumer.setMessageListener(new Listener());  
}  
</code></pre><p>  }  </p>
<p>  public Session getSession() {  </p>
<pre><code>return session;  
</code></pre><p>  }  </p>
</li>
</ul>
<blockquote>
<p>这里的代码不要当真了，写得很烂</p>
</blockquote>
<h4 id="Listener负责处理接收到的消息："><a href="#Listener负责处理接收到的消息：" class="headerlink" title="Listener负责处理接收到的消息："></a><code>Listener</code>负责处理接收到的消息：</h4><pre><code>public class Listener implements MessageListener {  
    public void onMessage(Message message) {  
        try {  
            MapMessage map = (MapMessage)message;  
            String stock = map.getString(&quot;stock&quot;);  
            double price = map.getDouble(&quot;price&quot;);  
            double offer = map.getDouble(&quot;offer&quot;);  
            boolean up = map.getBoolean(&quot;up&quot;);  
            DecimalFormat df = new DecimalFormat( &quot;#,###,###,##0.00&quot; );  
            System.out.println(stock + &quot;\t&quot; + df.format(price) + &quot;\t&quot; + df.format(offer) + &quot;\t&quot; + (up?&quot;up&quot;:&quot;down&quot;));  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  
}  
</code></pre><p>实现了<code>MessageListener</code>接口，里面的<code>onMessage</code>方法在接收到消息之后会被调用的方法。</p>
<h3 id="实现pub-sub模式的步骤"><a href="#实现pub-sub模式的步骤" class="headerlink" title="实现pub-sub模式的步骤"></a>实现pub-sub模式的步骤</h3><p>两者设定一个共同的topic。</p>
<p>在publisher端通过<code>session</code>创建<code>producer</code>，根据指定的参数创建<code>destination</code>，然后将消息和<code>destination</code>作为<code>producer.send()</code>方法的参数。</p>
<p>在consumer端也要创建类似的<code>connection</code>,<code>session</code>。通过<code>session</code>得到<code>destination</code>，再通过<code>session.createConsumer(destination)</code>来得到一个<code>MessageConsumer</code>对象。有了这个<code>MessageConsumer</code>就可以自行选择是直接同步的<code>receive</code>消息还是注册listener了。</p>
<h2 id="p2p"><a href="#p2p" class="headerlink" title="p2p"></a>p2p</h2><p><img src="/img/JMS点对点模式示意图.jpg" alt="JMS点对点模式示意图"></p>
<p>在p2p的场景里，相互通信的双方是通过一个类似于队列的方式来进行交流。和pub-sub的区别在于一个消息会发送给订阅此topic的多个订阅者，而在p2p里queue的消息只能被一个接受者接受。</p>
<h3 id="发送者"><a href="#发送者" class="headerlink" title="发送者"></a>发送者</h3><pre><code>public Publisher() throws JMSException {  
    factory = new ActiveMQConnectionFactory(brokerURL);  
    connection = factory.createConnection();  
    connection.start();  
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
    producer = session.createProducer(null);  
}
</code></pre><h4 id="发送消息："><a href="#发送消息：" class="headerlink" title="发送消息："></a>发送消息：</h4><pre><code>public void sendMessage() throws JMSException {  
    for(int i = 0; i &lt; jobs.length; i++)  
    {  
        String job = jobs[i];  
        Destination destination = session.createQueue(&quot;JOBS.&quot; + job);  
        Message message = session.createObjectMessage(i);  
        System.out.println(&quot;Sending: id: &quot; + ((ObjectMessage)message).getObject() + &quot; on queue: &quot; + destination);  
        producer.send(destination, message);  
    }  
}  
</code></pre><h4 id="消息发送者的启动代码："><a href="#消息发送者的启动代码：" class="headerlink" title="消息发送者的启动代码："></a>消息发送者的启动代码：</h4><pre><code>public static void main(String[] args) throws JMSException {  
    Publisher publisher = new Publisher();  
    for(int i = 0; i &lt; 10; i++) {  
        publisher.sendMessage();  
        System.out.println(&quot;Published &quot; + i + &quot; job messages&quot;);  
    try {  
            Thread.sleep(1000);  
        } catch (InterruptedException x) {  
            e.printStackTrace();  
        }  
    }  
    publisher.close();  
}  
</code></pre><p>在这里发送10条消息，在每个<code>sendMessage</code>的方法里实际上是针对每个<code>queue</code>发送了10条。</p>
<h3 id="接收者"><a href="#接收者" class="headerlink" title="接收者"></a>接收者</h3><pre><code>public Consumer() throws JMSException {  
    factory = new ActiveMQConnectionFactory(brokerURL);  
    connection = factory.createConnection();  
    connection.start();  
    session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);  
}  


public static void main(String[] args) throws JMSException {  
        Consumer consumer = new Consumer();  
        for (String job : consumer.jobs) {  
            Destination destination = consumer.getSession().createQueue(&quot;JOBS.&quot; + job);  
            MessageConsumer messageConsumer = consumer.getSession().createConsumer(destination);  
            messageConsumer.setMessageListener(new Listener(job));  
        }  
    }  

    public Session getSession() {  
        return session;  
    }
</code></pre><h4 id="MessageListener接口实现类"><a href="#MessageListener接口实现类" class="headerlink" title="MessageListener接口实现类"></a><code>MessageListener</code>接口实现类</h4><pre><code>import javax.jms.Message;  
import javax.jms.MessageListener;  
import javax.jms.ObjectMessage;  

public class Listener implements MessageListener {        
    private String job;  

    public Listener(String job) {  
        this.job = job;  
    }  

    public void onMessage(Message message) {  
        try {  
            //do something here  
            System.out.println(job + &quot; id:&quot; + ((ObjectMessage)message).getObject());  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }        
}
</code></pre><h2 id="比较pub-sub和p2p模式"><a href="#比较pub-sub和p2p模式" class="headerlink" title="比较pub-sub和p2p模式"></a>比较pub-sub和p2p模式</h2><p>基本的处理流程都是类似的，除了在pub-sub中要通过<code>createTopic</code>来设置topic，而在p2p中要通过<code>createQueue</code>来创建通信队列。</p>
<h2 id="request-response"><a href="#request-response" class="headerlink" title="request-response"></a>request-response</h2><p>和前面两种方式比较起来，request-response的通信方式很常见，但是不是默认提供的一种模式。在前面的两种模式中都是一方负责发送消息而另外一方负责处理。而实际中的很多应用需要双方都能给对方发送消息。<br>请求-应答方式并不是JMS规范系统默认提供的一种通信方式，而是通过在现有通信方式的基础上稍微运用一点技巧实现的。</p>
<blockquote>
<p>以下这种方式只能说是很差，并不是什么高明的做法</p>
</blockquote>
<p><img src="/img/JMS实际应用中产生的应答方式示意图.jpg" alt="JMS实际应用中产生的应答方式示意图"><br>在JMS里面，如果要实现请求/应答的方式，可以利用<code>JMSReplyTo</code>和<code>JMSCorrelationID</code>消息头来将通信的双方关联起来。另外，<code>QueueRequestor</code>和<code>TopicRequestor</code>能够支持简单的请求/应答过程。</p>
<pre><code>// client side  
Destination tempDest = session.createTemporaryQueue();  
MessageConsumer responseConsumer = session.createConsumer(tempDest);  
...  

// send a request..  
message.setJMSReplyTo(tempDest)  
message.setJMSCorrelationID(myCorrelationID);  

producer.send(message);  
</code></pre><p>client端创建一个临时队列并在发送的消息里指定了发送返回消息的<code>destination</code>以及<code>correlationID</code>。那么在处理消息的server端得到这个消息后就知道该发送给谁了。Server端的大致流程如下：</p>
<pre><code>public void onMessage(Message request) {  

  Message response = session.createMessage();  
  response.setJMSCorrelationID(request.getJMSCorrelationID())  

  producer.send(request.getJMSReplyTo(), response)  
}  
</code></pre><p>这里是在server端注册<code>MessageListener</code>，通过设置返回信息的<code>CorrelationID</code>和<code>JMSReplyTo</code>将信息返回。</p>
<h3 id="Client"><a href="#Client" class="headerlink" title="Client:"></a>Client:</h3><pre><code>public Client() {  
    ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(&quot;tcp://localhost:61616&quot;);  
    Connection connection;  
    try {  
        connection = connectionFactory.createConnection();  
        connection.start();  
        Session session = connection.createSession(transacted, ackMode);  
        Destination adminQueue = session.createQueue(clientQueueName);  

        //Setup a message producer to send message to the queue the server is consuming from  
        this.producer = session.createProducer(adminQueue);  
        this.producer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);  

        //Create a temporary queue that this client will listen for responses on then create a consumer  
        //that consumes message from this temporary queue...for a real application a client should reuse  
        //the same temp queue for each message to the server...one temp queue per client  
        Destination tempDest = session.createTemporaryQueue();  
        MessageConsumer responseConsumer = session.createConsumer(tempDest);  

        //This class will handle the messages to the temp queue as well  
        responseConsumer.setMessageListener(this);  

        //Now create the actual message you want to send  
        TextMessage txtMessage = session.createTextMessage();  
        txtMessage.setText(&quot;MyProtocolMessage&quot;);  

        //Set the reply to field to the temp queue you created above, this is the queue the server  
        //will respond to  
        txtMessage.setJMSReplyTo(tempDest);  

        //Set a correlation ID so when you get a response you know which sent message the response is for  
        //If there is never more than one outstanding message to the server then the  
        //same correlation ID can be used for all the messages...if there is more than one outstanding  
        //message to the server you would presumably want to associate the correlation ID with this  
        //message somehow...a Map works good  
        String correlationId = this.createRandomString();  
        txtMessage.setJMSCorrelationID(correlationId);  
        this.producer.send(txtMessage);  
    } catch (JMSException e) {  
        //Handle the exception appropriately  
    }  
}  
</code></pre><p>这里的代码除了初始化构造函数里的参数还同时设置了两个destination，一个是自己要发送消息出去的destination，在<code>session.createProducer(adminQueue);</code>这一句设置。另外一个是自己要接收的消息destination, 通过<code>Destination tempDest = session.createTemporaryQueue(); responseConsumer = session.createConsumer(tempDest);</code> 这两句指定了要接收消息的目的地。这里是用的一个临时队列。在前面指定了返回消息的通信队列之后，需要通知server端知道发送返回消息给哪个队列。于是<code>txtMessage.setJMSReplyTo(tempDest);</code>指定了这一部分，同时<code>txtMessage.setJMSCorrelationID(correlationId);</code>方法主要是为了保证每次发送回来请求的server端能够知道对应的是哪个请求。这里一个请求和一个应答是相当于对应一个相同的序列号一样。</p>
<p>同时，因为client端在发送消息之后还要接收server端返回的消息，所以它也要实现一个消息receiver的功能。这里采用实现<code>MessageListener</code>接口的方式：</p>
<pre><code>public void onMessage(Message message) {  
    String messageText = null;  
    try {  
        if (message instanceof TextMessage) {  
            TextMessage textMessage = (TextMessage) message;  
            messageText = textMessage.getText();  
            System.out.println(&quot;messageText = &quot; + messageText);  
        }  
    } catch (JMSException e) {  
        //Handle the exception appropriately  
    }  
}  
</code></pre><h3 id="Server"><a href="#Server" class="headerlink" title="Server:"></a>Server:</h3><p>这里server端要执行的过程和client端相反，它是先接收消息，在接收到消息后根据提供的<code>JMSCorelationID</code>来发送返回的消息：</p>
<pre><code>public void onMessage(Message message) {  
    try {  
        TextMessage response = this.session.createTextMessage();  
        if (message instanceof TextMessage) {  
            TextMessage txtMsg = (TextMessage) message;  
            String messageText = txtMsg.getText();  
            response.setText(this.messageProtocol.handleProtocolMessage(messageText));  
        }  

        //Set the correlation ID from the received message to be the correlation id of the response message  
        //this lets the client identify which message this is a response to if it has more than  
        //one outstanding message to the server  
        response.setJMSCorrelationID(message.getJMSCorrelationID());  

        //Send the response to the Destination specified by the JMSReplyTo field of the received message,  
        //this is presumably a temporary queue created by the client  
        this.replyProducer.send(message.getJMSReplyTo(), response);  
    } catch (JMSException e) {  
        //Handle the exception appropriately  
    }  
}
</code></pre><p>前面，在<code>replyProducer.send()</code>方法里，<code>message.getJMSReplyTo()</code>就得到了要发送消息回去的destination。<br>另外，设置这些发送返回信息的replyProducer的信息主要在构造函数相关的方法里实现了：</p>
<pre><code>public Server() {  
    try {  
        //This message broker is embedded  
        BrokerService broker = new BrokerService();  
        broker.setPersistent(false);  
        broker.setUseJmx(false);  
        broker.addConnector(messageBrokerUrl);  
        broker.start();  
    } catch (Exception e) {  
        //Handle the exception appropriately  
    }  

    //Delegating the handling of messages to another class, instantiate it before setting up JMS so it  
    //is ready to handle messages  
    this.messageProtocol = new MessageProtocol();  
    this.setupMessageQueueConsumer();  
}  

private void setupMessageQueueConsumer() {  
    ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(messageBrokerUrl);  
    Connection connection;  
    try {  
        connection = connectionFactory.createConnection();  
        connection.start();  
        this.session = connection.createSession(this.transacted, ackMode);  
        Destination adminQueue = this.session.createQueue(messageQueueName);  

        //Setup a message producer to respond to messages from clients, we will get the destination  
        //to send to from the JMSReplyTo header field from a Message  
        this.replyProducer = this.session.createProducer(null);  
        this.replyProducer.setDeliveryMode(DeliveryMode.NON_PERSISTENT);  

        //Set up a consumer to consume messages off of the admin queue  
        MessageConsumer consumer = this.session.createConsumer(adminQueue);  
        consumer.setMessageListener(this);  
    } catch (JMSException e) {  
        //Handle the exception appropriately  
    }  
}
</code></pre><p>对于请求/应答的方式来说，这种典型交互的过程就是Client端在设定正常发送请求的Queue同时也设定一个临时的Queue。同时在要发送的message里头指定要返回消息的destination以及CorelationID，这些就好比是一封信里面所带的回执。根据这个信息人家才知道怎么给你回信。对于Server端来说则要额外创建一个producer，在处理接收到消息的方法里再利用producer将消息发回去。这一系列的过程看起来很像http协议里面请求-应答的方式，都是一问一答。</p>
<h2 id="一些应用和改进"><a href="#一些应用和改进" class="headerlink" title="一些应用和改进"></a>一些应用和改进</h2><p>回顾前面三种基本的通信方式，发现它们都存在着一定的共同点，比如说都要初始化<code>ConnectionFactory</code>, <code>Connection</code>, <code>Session</code>等。在使用完之后都要将这些资源关闭。如果每一个实现它的通信端都这么写一通的话，其实是一种简单的重复。从工程的角度来看是完全没有必要的。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>通过工厂方法封装这些对象的创建和销毁，然后简单的通过调用工厂方法的方式得到它们。<br>既然基本的流程都是在开头创建资源在结尾销毁，也可以采用Template Method模式的思路。通过继承一个抽象类，在抽象类里提供了资源的封装。所有继承的类只要实现怎么去使用这些资源的方法就可以了。</p>
]]></content>
    
    <summary type="html">
    
      activemq的几种基本通信方式总结
    
    </summary>
    
      <category term="java" scheme="http://jishusuishouji.github.io/categories/java/"/>
    
      <category term="JMS，ActiveMQ" scheme="http://jishusuishouji.github.io/categories/java/JMS%EF%BC%8CActiveMQ/"/>
    
    
      <category term="activeMQ" scheme="http://jishusuishouji.github.io/tags/activeMQ/"/>
    
  </entry>
  
</feed>
